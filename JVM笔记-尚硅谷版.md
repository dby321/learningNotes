# JVM上篇

## 01. JVM与Java体系结构

### 2. 面向人群和参考书目

> 《深入理解Java虚拟机-周志明-第三版》

### 3. Java及JVM简介

![JVM：跨语言的平台](.\images\1628584302265.png)

> `Java虚拟机平台上可以运行非Java语言编写的程序`
>
> `Java不是最强大的语言，但JVM是最强大的虚拟机`
>
> `Java平台上的多语言混合秉承正成为主流，因为各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为他们最终都运行在一个虚拟机上。`

### 4. Java发展的重大事件

### 5. 虚拟机和Java虚拟机

> 虚拟机的分类：
>
> - 虚拟机可以分为系统虚拟机和程序虚拟机
>
> - VMware就属于系统虚拟机，他们完全是对物理计算机的仿真
>
> - 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计
>
> Java虚拟机的作用：`Java虚拟机就是二进制字节码的运行环境`
>
> Java虚拟机的特点：`一次编译，到处运行`。`自动内存管理`。`自动垃圾回收功能`。
>
> `JVM是运行在操作系统之上的，它与硬件没有直接交互`

![JVM的位置](.\images\1628585789031.png)

### 6. JVM的整体结构

> 运行时数据区哪些是线程共享的，哪些是线程独占的？
>
> - 线程共享：方法区 堆，
>
> - 线程独占：Java栈、本地方法栈、程序计数器
>
> 执行引擎包含几个部分：
>
> - 解释器
> - JIT(即时编译器/后端编译器)   ps:前端编译器是编译.java文件为.class文件的编译器
> - 垃圾回收器

![JVM简图](.\images\1628586039264.png)



### 7. Java代码执行流程

![宏观的Java代码执行流程](.\images\1628756709478.png)

### 8. JVM的架构模型

> JVM的架构模型：
>
> - 基于`栈式架构`的特点
>   - 设计和实现更简单，适用于资源受限的系统
>   - 避开了寄存器的分配难题，使用零地址指令方式分配
>   - 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
>   - 不需要硬件支持，可以执行更好，更好的跨平台
> - 基于`寄存器架构`的特点
>   - 典型的应用是x86的二进制指令集
>   - 指令集架构则完全依赖硬件，可以执行差
>   - 性能优秀和执行更高效
>   - 花费更少的指令去完成一项操作
>   - 大部分情况下，基于寄存器架构的指令集往往都以一地址指令，二地址指令和三地址指令为主
>
> - 总结：由于跨平台性的设计(不同平台的CPU架构是不同的，所以不能设计为基于寄存器的)，`Java的指令都是根据栈来设计的`
> - ![基于栈的指令和基于寄存器的指令](./images/image-20230112194742853.png)



> `javap`的使用：解析字节码文件
>
> ```
> dongbinyu@dongbinyudeMacBook-Pro binyu % javap -v StackStructTest.class
> Classfile /Users/dongbinyu/IdeaProjects/JVM_Study/out/production/chapter01/com/binyu/StackStructTest.class
>   Last modified 2023-1-12; size 474 bytes
>   MD5 checksum c2762b1b18991f78848d098f0378b2cc
>   Compiled from "StackStructTest.java"
> public class com.binyu.StackStructTest
>   minor version: 0
>   major version: 52
>   flags: ACC_PUBLIC, ACC_SUPER
> Constant pool:
>    #1 = Methodref          #3.#21         // java/lang/Object."<init>":()V
>    #2 = Class              #22            // com/binyu/StackStructTest
>    #3 = Class              #23            // java/lang/Object
>    #4 = Utf8               <init>
>    #5 = Utf8               ()V
>    #6 = Utf8               Code
>    #7 = Utf8               LineNumberTable
>    #8 = Utf8               LocalVariableTable
>    #9 = Utf8               this
>   #10 = Utf8               Lcom/binyu/StackStructTest;
>   #11 = Utf8               main
>   #12 = Utf8               ([Ljava/lang/String;)V
>   #13 = Utf8               args
>   #14 = Utf8               [Ljava/lang/String;
>   #15 = Utf8               i
>   #16 = Utf8               I
>   #17 = Utf8               j
>   #18 = Utf8               k
>   #19 = Utf8               SourceFile
>   #20 = Utf8               StackStructTest.java
>   #21 = NameAndType        #4:#5          // "<init>":()V
>   #22 = Utf8               com/binyu/StackStructTest
>   #23 = Utf8               java/lang/Object
> {
>   public com.binyu.StackStructTest();
>     descriptor: ()V
>     flags: ACC_PUBLIC
>     Code:
>       stack=1, locals=1, args_size=1
>          0: aload_0
>          1: invokespecial #1                  // Method java/lang/Object."<init>":()V
>          4: return
>       LineNumberTable:
>         line 3: 0
>       LocalVariableTable:
>         Start  Length  Slot  Name   Signature
>             0       5     0  this   Lcom/binyu/StackStructTest;
> 
>   public static void main(java.lang.String[]);
>     descriptor: ([Ljava/lang/String;)V
>     flags: ACC_PUBLIC, ACC_STATIC
>     Code:
>       stack=2, locals=4, args_size=1
>          0: iconst_2
>          1: istore_1
>          2: iconst_3
>          3: istore_2
>          4: iload_1
>          5: iload_2
>          6: iadd
>          7: istore_3
>          8: return
>       LineNumberTable:
>         line 5: 0
>         line 6: 2
>         line 7: 4
>         line 8: 8
>       LocalVariableTable:
>         Start  Length  Slot  Name   Signature
>             0       9     0  args   [Ljava/lang/String;
>             2       7     1     i   I
>             4       5     2     j   I
>             8       1     3     k   I
> }
> SourceFile: "StackStructTest.java"
> 
> ```
>
> 





### 9. JVM的生命周期

> JVM的生命周期：
>
> - 虚拟机的启动：是通过引导类加载器bootstrap class loader创建一个初始类来完成的，这个类是由虚拟机的具体实现指定的
> - 虚拟机的执行：
>   - 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序
>   - 程序开始执行他才运行，程序结束他就停止
>   - 执行一个所谓的Java程序的时候，真正执行的是一个叫做Java虚拟机的进程
> - 虚拟机的退出：
>   - 程序正常执行结束
>   - 程序在执行过程中遇到了异常或错误而异常终止
>   - 由于操作系统出现错误而导致Java虚拟机进程终止
>   - 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
>   - JNI规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机退出情况

> `JPS`的使用：JPS是JDK提供的一个可以列出正在运行的Java虚拟机的进程信息的命令行工具
>
> ```
> dongbinyu@dongbinyudeMacBook-Pro JVM_Study % jps
> 2992 
> 3251 Jps
> 3245 Launcher
> 3246 StackStructTest
> ```
>
> 





### 10. JVM发展历程

> ###### 历史上出现的JVM:
>
> - Sun Classic VM:`世界上第一款商用的java虚拟机`。虚拟机内部只提供了解释器，程序执行慢。如果外挂了JIT即时编译器，就不能使用解释器了。那么全部用JIT即时编译器好吗？不好，会导致程序运行暂停时间过长。解释器就像步行，JIT就像要等待的公交车，上了车自然是JIT快，但是两者搭配使用才最好。
> - Exact VM
> - HotSpot VM：名称中的HotSpot指的是`热点代码探测技术`：通过计数器找到最具编译价值代码，触发`即时编译`或`栈上替换`；通过`编译器与解释器协同工作`，在`最优化的程序响应时间与最佳执行性能中取得平衡`
> - BEA的JRocket：专注于服务器端的应用
> - IBM的J9：号称世界上最快的虚拟机，在IBM设备中运行快
> - KVM和CDC/CLDC HotSpot 
> - Azul VM
> - Liquid VM
> - Apache Harmony
> - Microsoft JVM
> - Taobao JVM
> - Graal VM：Oracle未来的野心

## 02. 类加载子系统

### 2. 类加载器与类的加载过程

![JVM详细图](.\images\1628838034799.png)

> ##### 类加载器的角色与作用：
>
> - 类加载器子系统负责从文件系统或者网络中`加载class文件`，class文件在文件开头有特定的文件标识cafebabe魔数
> - ClassLoader`只负责class文件的加载`，至于它是否可以运行，则由ExecutionEngine决定
> - `加载的类信息存放于一块称为方法区的内存空间`，除了类的信息外，方法区中还会存放运行时常量池的信息，可能还包括字符串字面量和数字常量
> - ![类加载器ClassLoader的角色](./images/image-20230112224216744.png)



> 类的加载过程：
>
> - **加载Loading->链接Linking(验证Verification->准备Preparation->解析Resolution)->初始化Initialization**
>
> - `加载Loading`：
>
>   1. 通过一个类全限定名获取定义此类的二进制字节流
>   2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
>   3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
>
> - `链接Linking`:
>
>   - `验证Verify`:
>     - 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
>     - 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
>
>   - `准备(Prepare)`:
>     - 为类变量分配内存并且设置该类变量的默认初始值，即零值。
>     - 这里不包含用final修饰的static,因为final在编译的时候就会分配了，准备阶段会显式初始化
>     - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
>
>   - `解析(Resolve)`:
>     - 将常量池内的符号引用转换为直接引用的过程。
>     - 事实上，解析操作往往会伴随着M在执行完初始化之后再执行。
>     - 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
>     - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info,CONSTANT_Fieldref info,CONSTANT Methodref info
>
> - `初始化`：
>   - 初始化阶段就是执行类构造器方法<c11n1t>()的过程。
>   - 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静
>     态代码块中的语句合并而来。
>   - 构造器方法中指令按语句在源文件中出现的顺序执行。
>   - <c1init>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>())
>   - 若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<c1init>()
>     已经执行完毕。
>   - 虚拟机必须保证一个类的<c1init>()方法在多线程下被同步加锁。
>
> 



### 3. 类加载器分类

> **JVM类加载器的分类：**
>
> - `引导类加载器`和`自定义类加载器`。JVM规范将所有派生于抽象类ClassLoader的类加载器都划分为`自定义类加载器`。也就是说BootstrapClassLoader自成一类，其余类加载器成另一类。
>
> 这里的四种类加载器之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。
>
> `sun.misc.Launcher是java虚拟机的入口应用`
>
> - ![类加载器的分类](.\images\1630832390662.png)
> - ![拓展类加载器和系统类加载器间接继承于ClassLoader](./images/image-20230113105131265.png)



> **类加载器是怎么编写的？**
>
> - Bootstrap是用C/C++编写的。
> - 其他的自定类加载器使用Java编写的。
>
> **虚拟机自带的加载器有哪些？**
>
> - 启动类加载器（`引导类加载器`，Bootstrap ClassLoader)
>   - 这个类加载使用C/C++语言实现的，嵌套在JM内部。
>   - 它用来加载Java的核心库(JAVA HOME/jre/Iib/rt.jar、re3 ource3.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类
>   - 并不继承自java.lang.ClassLoader,没有父加载器。
>   - 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
>   - 出于安全考虑，Bootstrap,启动类加载器只加载包名为java、javax、sun等开头的类
>
> - `扩展类加载器`(Extension ClassLoader)》
>
>   - Java言缄写，由sun.misc.Launcher$ExtclassLoader实现。
>   - 派生于classLoader类
>   - 父类加载器为启动类加载器
>   - 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安
>     装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创
>     建的JAR放在此目录下，也会自动由扩展类加载器加载。
>
> - 应用程序类加载器(`系统类加载器`，AppClassLoader)
>   - java语言编写，由sun.misc.Launcher$AppClassLoader实现
>   - 派生于classLoader类
>   - 父类加载器为扩展类加载器
>   - 它负责加载环境变量classpath.或系统属性java.class,path指
>     定路径下的类库
>   - 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由
>     它来完成加载
>   - 通过classLoader#getSystemclassLoader()方法可以获取到该
>     类加载器
>
> - ```java
>   public class ClassLoaderTest {
>       public static void main(String[] args) {
>           // 系统类加载器/应用类加载器
>           ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
>           System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
>           // 拓展类加载器
>           ClassLoader extClassLoader = systemClassLoader.getParent();
>           System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d
>           // 引导类加载器
>           ClassLoader bootstrapClassLoader = extClassLoader.getParent();
>           System.out.println(bootstrapClassLoader);//null
>           // 用户自定义类加载器,默认使用系统类加载器
>           ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
>           System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
>           //JDK系统核心类库是使用引导类加载器加载的
>           ClassLoader classLoader1 = String.class.getClassLoader();
>           System.out.println(classLoader1);//null
>           bootstrapClassLoader();
>           extClassLoader();
>           appClassLoader();
>       }
>       /**
>        * 启动类加载器的职责
>        */
>       public static void bootstrapClassLoader() {
>           String property = System.getProperty("sun.boot.class.path");
>           List<String> list = Arrays.asList(property.split(";"));
>           list.forEach((t) -> {
>               System.out.println("启动类加载器目录:" + t);
>           });
>       }
>   
>   
>       /**
>        * 扩展类加载器
>        */
>       public static void extClassLoader() {
>           String property = System.getProperty("java.ext.dirs");
>           List<String> list = Arrays.asList(property.split(";"));
>           list.forEach((t) -> {
>               System.out.println("扩展类加载器" + t);
>           });
>       }
>                   
>       /**
>        * app 类加载器
>        */
>       public static void appClassLoader() {
>           String property = System.getProperty("java.class.path");
>           List<String> list = Arrays.asList(property.split(";"));
>           list.forEach((t) -> {
>               System.out.println("应用类加载器" + t);
>           });
>       }
>   }
>   
>   ```
>   



> **用户自定义类加载器：**
>
> - 在Java的口常应用程序开发中，类的加载几乎是由上述3种类加载器相互
>   配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方
>   式。
> - 为什么要自定义类加载器？
>   - 隔离加载类
>   - 修改类加载的方式
>   - 扩展加载源
>   - 防止源码泄漏
>
> **用户自定义类加载器实现步骤：**
>
> 1. 开发人员`可以通过继承抽象类java.lang.ClassLoader类`的方式，实现
>    自己的类加载器，以满足一些特殊的需求
> 2. 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重
>    写loadclass()方法，从而实现自定义的类加载类，但是在JDK1.2之后
>    已不再建议用户去覆盖loadclass()方法，而是建议把`自定义的类加载逻
>    辑写在findClass()方法中`
> 3. 在编写自定义类加载器时，`如果没有太过于复杂的需求，可以直接继承
>    URLClassLoader类`，这样就可以避免自己去编写findclass()方法及
>    其获取字节码流的方式，使自定义类加载器编写更加简洁。



> **获取ClassLoader的方式：**
>
> - 方式一：获取当前类的classLoader
>   clazz.getclassLoader()
> - 方式二：获取当前线程上下文的classLoader
>   Thread.currentThread().getContextclassLoader()
> - 方式三：获取系统的classLoader
>   ClassLoader.getsystemclassLoader()
> - 方式四：获取调用者的classLoader
>   DriverManager.getCallerclassLoader()

### 5. 双亲委派机制

> `Java虚拟机对class文件采用的是按需加载的方式`，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是`双亲委派模式`，即`把请求交由父类处理`，它是一种任务委派模式。
>
> **双亲委派机制是什么？**
>
> 1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行
> 2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器：
> 3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
>
> **双亲委派机制的优势：**
>
> - 避免类的重复加载
> - 保护程序安全，防止核心API被篡改
>
> **沙箱安全机制：**
>
> - 自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包java\lang\String.class),报错信息说没有main方法就是因为加载的是rt,jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。

![双亲委派机制](.\images\1630834168217.png)

![避免类的重复加载；保护程序安全，防止核心API被篡改](.\images\1630834485772.png)

### 6. 其他

> **在JVM中表示两个class对象是否为同一个类存在两个必要条件：**
>
> - 类的完整类名必须一致，包括包名。
> - 加载这个类的c1 assLoader(指classLoader实例对象)必须相同。
>
> JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么`JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中`。当解
> 析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。
>
> **Java程序对类的使用方式分为：主动使用和被动使用。**
>
> - 主动使用，又分为七种情况：
>
>   - 创建类的实例
>
>   - 访问某个类或接口的静态变量，或者对该静态变量赋值
>
>   - 调用类的静态方法
>
>   - 反射（比如：Class.forName("com.atguigu.Test"))
>
>   - 初始化一个类的子类
>
>   - Java虚拟机启动时被标明为启动类的类
>
>   - JDK7开始提供的动态语言支持：
>     java.lang.invoke.MethodHandle实例的解析结果REF getstatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化
>
> - 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，
>   都不会导致类的初始化。

## 03. 运行时数据区概述及线程

### 1. 概述

> 每个线程：程序计数器、虚拟机栈、本地方法栈
>
> 线程间共享：堆、堆外内存/非堆（永久代或元空间：是方法区落地的实现、JIT编译出的代码缓存）
>
> 一个JVM实例对应一个Runtime实例，Runtime对象相当于运行时数据区

![HotspotJVM结构图1](.\images\1630909871255.png)

![HotspotJVM结构图2](./images/image-20230113151454639.png)

![HotspotJVM结构图3](./images/image-20230113151950341.png)

### 2. 线程

> - 线程是一个程序里的运行单元。VM允许一个应用有多个线程并行的
>   执行。
> - 在Hotspot JVM.里，每个线程都与操作系统的本地线程直接映射。
>   - 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。
> - 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。

![JVM的守护线程【了解】](.\images\1630910813908.png)

## 04. 程序计数器/PC寄存器

### 1. 介绍

> **程序计数器：**用于存储下一条指令的地址。没有GC也没有OOM异常

![1630911159543](.\images\1630911159543.png)

![1630911443911](.\images\1630911443911.png)

![1630911636489](.\images\1630911636489.png)

### 2. 举例说明

![1630912543510](.\images\1630912543510.png)

### 3. 两个常见的问题

> 1. 使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢?
>    - 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
> 2. PC寄存器为什么会被设定为线程私有？
>    - 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。
>
> 简单说就是Java是多线程的，线程并发时CPU会切换线程，就需要记录现场以便切换回来时继续运行。

## 05. 虚拟机栈

### 1. 虚拟机栈概述

> **Java虚拟机栈是什么？**
>
> - Java虚拟机栈(Java Virtual Machine Stack),早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的`栈帧`(Stack Frame),对应着一次次的Java方法调用。
>
> - 是线程私有的
>
> - 生命周期和线程一致。
> - 主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。堆管存储。
>
> **栈的特点（优点）:**
>
> - 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
> - JVM直接对Java栈的操作只有两个：
>   - 每个方法执行，伴随着进栈（入栈、压栈）
>   - 执行结束后的出栈工作
> - 对于栈来说不存在垃圾回收问题，存在OOM异常
>
> **虚拟机规范中的StackOverflowError和OutOfMemoryError:**
>
> - `当某次线程运行计算时，需要占用的 Java 虚拟机栈（Java Virtual Machine Stack）大小，也就是 Java 线程栈大小，**超过规定大小**时，抛出 StackOverflowError`
> - `如果 Java 虚拟机栈大小可以动态扩容，发生扩容时发现内存不足，或者新建Java 虚拟机栈时发现内存不足，抛出 OutOfMemoryError`
> - 当所需要的堆（heap）内存大小不足时，抛出 OutOfMemoryError
> - 当方法区（Method Area）大小不够分配时，抛出 OutOfMemoryError
> - 当创建一个类或者接口时，运行时常量区剩余大小不够时，抛出 OutOfMemoryError
> - 本地方法栈（Native Method Stack）大小不足时，抛出 StackOverflowError
> - 本地方法栈（Native Method Stack）扩容时发现内存不足，或者新建本地方法栈发现内存不足，抛出 OutOfMemoryError
>
> **演示一下StackOverflowError：**
>
> ```java
> public class StackErrorTest {
>     public static void main(String[] args) {
>         main(args);
>     }
> }
> ```
>
> ```
> Exception in thread "main" java.lang.StackOverflowError
> 	at com.binyu.StackErrorTest.main(StackErrorTest.java:5)
> 	at com.binyu.StackErrorTest.main(StackErrorTest.java:5)
> 	at com.binyu.StackErrorTest.main(StackErrorTest.java:5)
> 	at com.binyu.StackErrorTest.main(StackErrorTest.java:5)
> ```
>  





> -Xss*size*
>
> Sets the thread stack size (in bytes). Append the letter `k` or `K` to indicate KB, `m` or `M` to indicate MB, `g` or `G` to indicate GB. The default value depends on the platform:
>
> - Linux/ARM (32-bit): 320 KB
> - Linux/i386 (32-bit): 320 KB
> - Linux/x64 (64-bit): 1024 KB
> - OS X (64-bit): 1024 KB
> - Oracle Solaris/i386 (32-bit): 320 KB
> - Oracle Solaris/x64 (64-bit): 1024 KB
>
> The following examples set the thread stack size to 1024 KB in different units:
>
> ```
> -Xss1m
> -Xss1024k
> -Xss1048576
> ```
>
> This option is equivalent to `-XX:ThreadStackSize`.

### 2. 栈的存储单位

>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为`当前栈帧`(Current Frame),与当前栈帧相对应的方法就是`当前方法`(Current Method),定义这个方法的类就是`当前类`(Current Class)
>
>`不同线程中所包含的栈帧是不允许存在相互引用的`，即不可能在一个栈帧之中引用另外一个线程的栈帧。
>
>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。`不管使用哪种方式，都会导致栈帧被弹出`。

![虚拟机栈的结构](.\images\1631003382715.png)

### 3. 局部变量表

> **局部变量表：**
>
> - `定义为一个数字数组`，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用(reference),以及returnAddress类型。
> - 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此`不存在线程安全问题`
> - `局部变量表所需的容量大小是在编译期确定下来的`，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。
> - 局部变量表最基本的存储单元是`Slot（变量槽）`
>   - `32位以内的类型只占用一个slot（包括returnAddress类型、引用类型），64位的类型（long和double）占用两个slot`
>   - JVM会为局部变量表中的`每一个Slot都分配一个访问素引`，通过这个素引即可成功访
>     问到局部变量表中指定的局部变量值
>   - 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会`按顺
>     序被复制`到局部变量表中的每一个S1ot上
>   - `如果需要访问局部变量表中一个64b1t的局部变量值时，只需要使用前一个素引即可`。（比
>     如：访问long或double类型变量)
>   - 如果当前帧是由构造方法或者实例方法创建的那么`该对象引用this将会存放在index为0的slot处`，其余的参数按照参数表顺序继续排列。
>   - `栈帧中的局部变量表中的槽位是可以重用的`，如果一个局部变量过了其作用域
>     那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到`节省资源`的目的。



> **静态变量与局部变量的对比：**
>
> - 类变量有两次初始化
>   - 链接Linking中的准备Prepare阶段：执行默认初始化，设置为零值
>   - 初始化Initialization阶段：代码定义的初始化
> - 局部变量必须要手动初始化
> 




> 补充说明：
>
> - 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。
>   在方法执行时，虚拟机使用局部变量表完成方法的传递。
> - 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直
>   接或间接引用的对象都不会被回收。

### 4. 操作数栈Operand Stack

> **操作数栈：**
>
> - `方法执行过程中，根据字节码指令，进行入栈或出栈`
>   - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。
>   - 比如：执行复制、交换、求和等操作
> - 操作数栈主要`用于保存计算过程的中间结果，同时作为计算过程中变量临时存储空间`
> - 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。
> - 每一个操作数栈都会拥有一个明确的`栈深度`用于存储数值，其所需的`最大深度在编译期就定义好了`，保存在方法的code属性中，为max stack的值。
> - 栈中的任何一个元素都是可以任意的Java数据类型。
>   - 32bit的类型占用一个栈单位深度
>   - 64bit的类型占用两个栈单位深度
> - 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的`入栈(push)和出栈(pop)`操作来完成一次数据访问。
> - `如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中`，并更新PC寄存器中下一条需要执行的字节码指令。
> - 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。
> - 另外，我们说Java虚拟机的`解释引擎是基于栈的执行引擎，其中的栈指的
>   就是操作数栈`。

### 5. 代码追踪

> byte、short、char、boolean都以int型来保存
>
> bipush是指byte的int的push 

### 6. 栈顶缓存技术

![1631083013561](.\images\1631083013561.png)



### 7. 动态链接

> **动态链接：指向运行时常量池的方法引用**
>
> - 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现`动态链接`(Dynamic Linking)。比如：invokedynamic指令
>
> - 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么`动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用`。
> - ![动态链接](./images/image-20230113212519376.png)

### 8. 方法的调用：解析与分派【听不懂】

> 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。
>
> - 静态链接：
>   当一个字节码文件被装载进JM内部时，如果`被调用的目标方法在编译期可知`，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
> - 动态链接：
>   如果`被调用的方法在编译期无法被确定下来`，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。
>
> 对应的方法的绑定机制为：早期绑定(Early Binding)和晚期绑定(Late Binding)。`绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程`，这仅仅发生一次。
>
> - 早期绑定：
>   早期绑定就是指`被调用的目标方法如果在编译期可知`，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。
> - 晚期绑定：
>   如果`被调用的方法在编译期无法被确定下来`，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。
>
> Java既有早期绑定又有晚期绑定
>
> Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于c++语言中的虚函数(c++中则需要使用关键字virtual来显式定义)。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。
>
> `非虚方法`：
>
> - 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。
>
> - `静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法`。他们有一个特点：都不能实现多态
>
> - 其他方法称为虚方法。
>
>   
>
> `子类对象的多态性的使用前提：①类的继承关系②方法的重写`
>
> **虚拟机中提供了以下几条方法调用指令：**
>
> - 普通调用指令：
>   1. invokestatic:调用静态方法，解析阶段确定唯一方法版本
>   2. invokespecial:调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本
>   3. invokevirtual:调用所有虚方法
>   4. invokeinterface:调用接口方法
> - 动态调用指令：
>   1. invokedynamic:动态解析出需要调用的方法，
>
> 然后执行前四条指令固化在虚拟机内部，方法的调用执行不可人为千预，而invokedynamic指令则支持由用户确定方法版本。其中`invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法`。
>
> **虚方法表：**在类的方法区
>
> - 在面向对象的编程中，会很频繁的使用到动态分派(invokedynamic)，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，`JVM采用在类的方法区建立一个虚方法表`(virtual method table)(非虚方法不会出现在表中)来实现。`使用索引表来代替查找`。
>
> - `每个类中都有一个虚方法表，表中存放着各个方法的实际入口`。
> - 那么虚方法表什么时候被创建？
>   - `虚方法表会在类加载的链接阶段被创建并开始初始化`，类的变量初始值准备完
>     成之后，JVM会把该类的虚方法表也初始化完毕。
> - ![虚方法表](./images/image-20230113222731346.png)



> **动态类型语言和静态类型语言：**
>
> - `对类型的检查是在编译期还是在运行期，如果是编译期就是静态类型语言，如果是运行期就是动态类型语言。`
> - `静态类型语言是判断变量自身的类型信息；动态类型是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息`

### 9. 方法返回地址

> **方法返回地址：**
>
> - `存放调用该方法的pc寄存器的值`。
>
> - 一个方法的结束，有两种方式：
>   - 1.正常执行完成,既正常完成出口
>     - 字节码指令有：ireturn、lreturn、freturn、dreturn 、areturn、return
>   - 2.出现未处理的异常，非正常退出
>   - 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，`调用者的PC寄存器的值作为返回地址`，即调用该方法的指令的下一条指令的地址。而`通过异常退出的，返回地址是要通过异常表来确定`，栈帧中一般不会保存这部分信息。
>   - 正常完成出口和异常完成出口的区别在于：`通过异常完成出口退出的不会给他的上层调用者产生任何的返回值`。

### 10. 一些附加信息

略

### 11. 栈的相关面试题

> - 虚拟机栈会产生StackOverflowError，不会产生GC
> - 分配的栈空间不是越大越好，因为内存资源是有限的，会限制线程数 
> - 内部产生，内部消亡的局部变量就是线程安全的；否则线程不安全，发生逃逸。
> - ![线程安全&线程不安全举例](.\images\1631332566895.png)

 

## 06. 本地方法接口

> 本地方法：
>
> - native method,即java调用非java代码（C/C++）
> - 为什么要使用native method
>   - 与java环境外交互
>   - 与操作系统交互
>   - JVM是C写的

## 07. 本地方法栈

> **本地方法栈：**
>
> - 用于管理本地方法的调用

## 08. 堆

### 1. 堆的核心概述

> 堆：
>
> - 在启动时被创建，空间大小也就确定了
> - 物理上可以不连续，逻辑上被视为连续的
> - 所有线程共享java堆，在这里还可以划分线程私有的缓冲区（TLAB）

![1631346150396](.\images\1631346150396.png)

![1631346516001](.\images\1631346516001.png)

![1631431014963](.\images\1631431014963.png)

### 2. 设置堆内存大小与OOM

![1631431789852](.\images\1631431789852.png)

查看堆空间设置的参数：

1. `jps` `jstat -gc 进程id`
2. `-XX：+PrintGCDetails`



### 3. 年轻代与老年代

![1631434332338](.\images\1631434332338.png)

设置新生代与老年代的比例（默认是1:2）：`-XX:NewRatio=2`

设置伊甸园区和幸存者区比例（默认是8:1:1，但是实际观察是6:1:1）:`-XX:SurviverRatio=8`

关闭自适应的内存分配策略：`-XX：-UseAdaptivesSizePolicy`

设置新生代的内存大小(一般不设置)：`-Xmn`

> 几乎所有的java对象都是在伊甸园区被new出来的
>
> 绝大部分的java对象的销毁都是在新生代进行，新胜达中80%的对象都是朝生夕死的

![1631435215921](.\images\1631435215921.png)

### 4. 图解对象分配过程

![1631435988937](.\images\1631435988937.png)

![1631436012538](.\images\1631436012538.png)

![1631436027544](.\images\1631436027544.png)

幸存者区到老年区的提升阈值(默认为15)：`-XX：MaxTenuringThreshold=15`

![1631436472308](.\images\1631436472308.png)

![1631499859084](.\images\1631499859084.png)

![1631500327920](.\images\1631500327920.png)

### 5. Minor GC、Major GC、Full GC

伊甸园区满触发Minor GC,进行伊甸园区和幸存者区垃圾回收

![1631502187354](.\images\1631502187354.png)

![1631502419873](.\images\1631502419873.png)

![1631502538913](.\images\1631502538913.png)

![1631502579890](.\images\1631502579890.png)

### 6. 堆空间分代思想

![1631503222701](.\images\1631503222701.png)

![1631503269820](.\images\1631503269820.png)



### 7. 内存分配策略

![1631503789218](.\images\1631503789218.png)

在发生**Minor GC**之前，虚拟机会检查**老年代最大可用的连续空间**是否**大于新生代所有对象的总空间**，

　　　　如果大于，则此次**Minor GC是安全的**

　　　　如果小于，则虚拟机会查看**HandlePromotionFailure**设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于**历次晋升到老年代的对象的平均大小**，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。

### 8. 为对象分配内存：TLAB

![1631504276627](.\images\1631504276627.png)

![1631504401715](.\images\1631504401715.png)**(去掉非)**

![1631504529412](.\images\1631504529412.png)

![1631504796976](.\images\1631504796976.png)

### 9. 小结堆空间的参数设置

[CSDN-堆空间常用参数总结](https://blog.csdn.net/qq_40381509/article/details/116094811)

### 10. 堆是分配对象的唯一选择吗？

![1631505163622](.\images\1631505163622.png)

![1631505267145](.\images\1631505267145.png)

![1631505411632](.\images\1631505411632.png)

![1631505763050](.\images\1631505763050.png)

![1631505798915](.\images\1631505798915.png)

![1631522096809](.\images\1631522096809.png)

![1631522165551](.\images\1631522165551.png)

![1631522267759](.\images\1631522267759.png)

![1631522587977](.\images\1631522587977.png)

![1631522635999](.\images\1631522635999.png)

![1631522648665](.\images\1631522648665.png)

## 09. 方法区

### 1. 栈、堆、方法区的交互关系

![1631523544943](.\images\1631523544943.png)

### 2. 方法区的理解

![1631523969813](.\images\1631523969813.png)

![1631524175180](.\images\1631524175180.png)

方法区的溢出：

![1631524352538](.\images\1631524352538.png)

![1631524549737](.\images\1631524549737.png)

![1631524720908](.\images\1631524720908.png)



### 3. 设置方法区大小与OOM

![1631524862192](.\images\1631524862192.png)

![1631525013534](.\images\1631525013534.png)

![1631525518078](.\images\1631525518078.png)



### 4. 方法区的内部结构

![1631525978389](.\images\1631525978389.png)

![1631526166395](.\images\1631526166395.png)

![1631526208003](.\images\1631526208003.png)

![1631526259150](.\images\1631526259150.png)

![1631528042382](.\images\1631528042382.png)

![1631528765068](.\images\1631528765068.png)

![1631588940366](.\images\1631588940366.png)

### 5. 方法区使用举例

略

### 6. 方法区的演进细节

![1631590149138](.\images\1631590149138.png)

![1631591269927](.\images\1631591269927.png)

### 7. 方法区的垃圾回收

![1631592128563](.\images\1631592128563.png)

![1631593746355](.\images\1631593746355.png)

![1631593782477](.\images\1631593782477.png)

![1631594034038](.\images\1631594034038.png)

### 8. 总结

![1631603886141](.\images\1631603886141.png)

## 10. 对象的实例化内存布局与访问定位

### 1. 对象的实例化

![1631604393858](.\images\1631604393858.png)

### 2. 对象的内存布局

<img src=".\images\1631606636602.png" alt="1631606636602"  />

![1631607030380](.\images\1631607030380.png)

[Java中的常量池(字符串常量池、class常量池和运行时常量池)](https://blog.csdn.net/zm13007310400/article/details/77534349)

### 3. 对象的访问定位

![1631675750471](.\images\1631675750471.png)

![1631675829108](.\images\1631675829108.png)

## 11. 直接内存

![1631676735336](.\images\1631676735336.png)

![1631677239169](.\images\1631677239169.png)

![1631677903662](.\images\1631677903662.png)

##12. 执行引擎

### 1. 执行引擎概述

![1631679071168](.\images\1631679071168.png)

![1631679219695](.\images\1631679219695.png)

![1631679865051](.\images\1631679865051.png)

### 2. Java代码编译和执行过程

![1631680003203](.\images\1631680003203.png)

![1631680147198](.\images\1631680147198.png)

![1631680185991](.\images\1631680185991.png)

![1631680225641](.\images\1631680225641.png)



### 3. 机器码、指令、汇编语言

略

### 4. 解释器

![1631688627519](.\images\1631688627519.png)

![1631688854383](.\images\1631688854383.png)

![1631689008280](.\images\1631689008280.png)

### 5. JIT编译器

热点代码用JIT编译器

![1631690059547](.\images\1631690059547.png)

![1631690080344](.\images\1631690080344.png)

![1631690274364](.\images\1631690274364.png)

![1631690388737](.\images\1631690388737.png)

![1631690580454](.\images\1631690580454.png)

![1631690676378](.\images\1631690676378.png)

![1631853820197](.\images\1631853820197.png)

![1631854636284](.\images\1631854636284.png)

![1631854700041](.\images\1631854700041.png)

![1631854851894](.\images\1631854851894.png)

![1631855059989](.\images\1631855059989.png)

![1631855153395](.\images\1631855153395.png)

## 13. StringTable

### 1. String的基本特性

![1631856199643](.\images\1631856199643.png)

**String具有不可变性**

![1631857542971](.\images\1631857542971.png)

`jps` `jinfo -flag 属性名（如StringTableSize） 进程ID`

### 2. String的内存分配

![1631858085775](.\images\1631858085775.png)

![1631858184519](.\images\1631858184519.png)

![1631858339459](.\images\1631858339459.png)



### 3. String的基本操作

略

### 4. 字符串拼接操作

![1631863276103](.\images\1631863276103.png)

![1631864110015](.\images\1631864110015.png)

> 在jdk5.0之后用的是StringBuilder,之前用的是StringBuffer 

![1631864314060](.\images\1631864314060.png)

​    **体会执行效率**：通过 StringBuilder 的 append() 的方式添加字符串的效率要远高于使用 String 的字符串拼接方式！
​    ①  StringBuilder的append()的方式：自始至终中只创建过一个 StringBuilder 的对象。
​       使用 String 的字符串拼接方式：创建过多个 StringBuilder 和 String 的对象
​    ②  使用 String 的字符串拼接方式：内存中由于创建了较多的 StringBuilder 和 String 的对象，内存占用更大；如果进行GC，需要花费额外的时间。
​    改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值 highLevel 的情况下,建议使用构造器实例化：
​       StringBuilder s = new StringBuilder(highLevel); // new char[highLevel]

     ```java
@Test
    public void test6() {
        long start = System.currentTimeMillis();
        method1(100000); // 6159
        //method2(100000); // 4
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start));
    }
    // 使用 String 的 + 进行字符串拼接
    public void method1(int highLevel) {
        String src = "";
        for (int i = 0; i < highLevel; i++) {
            src = src + "a"; // 每次循环都会创建一个 StringBuilder、String
        }
//        System.out.println(src);


    }
    // 使用 StringBuilder 的 append 方法进行拼接
    public void method2(int highLevel) {
        // 只需要创建一个 StringBuilder
        StringBuilder src = new StringBuilder();
        for (int i = 0; i < highLevel; i++) {
            src.append("a");
        }
//        System.out.println(src);
    }

     ```



### 5. intern()的使用

见上

![1631865973178](.\images\1631865973178.png)

总结String的intern()的使用：

jdk1.6中，将这个字符串对象尝试放入串池。
如果串池中有，则并不会放入。返回已有的串池中的对象的地址
如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址。
jdk1.7开始，将这个字符串尝试放入串池。
如果串池中有，则并不会放入。返回已有的串池中的对象的地址
如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址

[简书-Java String的intern方法 在JDK6和JDK7的不同行为](https://www.jianshu.com/p/697cc5381ba7)

![1631867942618](.\images\1631867942618.png)

### 6. StringTable的垃圾回收

略

### 7. G1的String去重操作

![1632020363933](.\images\1632020363933.png)

## 14. 垃圾回收概述

### 1. 什么是垃圾

![1632021263790](.\images\1632021263790.png)

### 2. 为什么需要GC

![1632021752103](.\images\1632021752103.png)

### 3. 早期垃圾回收

![1632022162405](.\images\1632022162405.png)

### 4. Java的垃圾回收机制

![1632022564286](.\images\1632022564286.png)

![1632022715715](.\images\1632022715715.png)

## 15. 垃圾回收相关算法

![1632023685664](.\images\1632023685664.png)

### 1. 标记阶段：引用计数算法

![1632024089305](.\images\1632024089305.png)

![1632024447107](.\images\1632024447107.png)

![1632040672658](.\images\1632040672658.png)

### 2. 标记阶段：可达性分析算法

![1632040859265](.\images\1632040859265.png)

![1632041163636](.\images\1632041163636.png)

![1632041209177](.\images\1632041209177.png)

![1632041427364](.\images\1632041427364.png)

![1632042094140](.\images\1632042094140.png)

### 3. 对象的finalization机制

![1632042226506](.\images\1632042226506.png)

![1632042480387](.\images\1632042480387.png)

![1632042676309](.\images\1632042676309.png)

![1632042947155](.\images\1632042947155.png)

### 4. MAT与JProfiler的GC Roots溯源

![1632043847612](.\images\1632043847612.png)

[P145-P146](https://www.bilibili.com/video/BV1PJ411n7xZ?p=146&spm_id_from=pageDriver)

### 5. 清除阶段： 标记-清除算法

![1632362655697](.\images\1632362655697.png)

 ![1632363605641](.\images\1632363605641.png)

### 6. 清除阶段：复制算法

![1632364307833](.\images\1632364307833.png)

![1632364227120](.\images\1632364227120.png)

![1632364508587](.\images\1632364508587.png)

> 类似幸存者0区和幸存者1区
>
> 新生代中适合使用复制算法 ，老年代不适合

### 7. 清除阶段：标记-压缩算法

![1632365450839](.\images\1632365450839.png)

![1632365614399](.\images\1632365614399.png)

![1632365781280](.\images\1632365781280.png)

![1632365762046](.\images\1632365762046.png)

### 8. 小结

![1632366141451](.\images\1632366141451.png)

### 9.分代收集算法

![1632366408431](.\images\1632366408431.png)

![1632366509060](.\images\1632366509060.png)

![1632366748866](.\images\1632366748866.png)

###10. 增量收集算法、分区算法

**增量收集算法：**

![1632366904444](.\images\1632366904444.png)

![1632366998459](.\images\1632366998459.png)

**分区算法：**

![1632367199209](.\images\1632367199209.png)

## 16. 垃圾回收相关概念

### 1. System.gc()的理解

![1632367829989](.\images\1632367829989.png)

![1632367973849](.\images\1632367973849.png)

### 2. 内存溢出与内存泄漏

![1632368555724](.\images\1632368555724.png)

![1632368703016](.\images\1632368703016.png)

![1632368733878](.\images\1632368733878.png)

![1632369039293](.\images\1632369039293.png)



### 3. Stop the world

![1632369238306](.\images\1632369238306.png)

![1632369350197](.\images\1632369350197.png)

### 4. 垃圾回收的并行与并发

![ds](.\images\1632378867474.png)

![1632379077497](.\images\1632379077497.png)

![1632379116717](.\images\1632379116717.png)

![1632379224552](.\images\1632379224552.png)

### 5. 安全点与安全区域

![1632379295182](.\images\1632379295182.png)

![1632379412398](.\images\1632379412398.png)

![1632379437675](.\images\1632379437675.png)

![1632379512857](.\images\1632379512857.png)

### 6. 再谈引用：强引用

![1632379815437](.\images\1632379815437.png)

![1632380063919](.\images\1632380063919.png)

### 7. 再谈引用：软引用

![1632380311961](.\images\1632380311961.png)

![1632380500199](.\images\1632380500199.png)

### 8. 再谈应用：弱引用

![1632380997906](.\images\1632380997906.png)

![1632381162044](.\images\1632381162044.png)

### 9. 再谈应用：虚引用

![1632381367965](.\images\1632381367965.png)

![1632381445822](.\images\1632381445822.png)

### 10. 再谈引用：终结器引用

![1632381952314](.\images\1632381952314.png)

## 17. 垃圾回收器

![1632453032632](.\images\1632453032632.png)

### 1. GC分类与性能指标

![1632453601431](.\images\1632453601431.png)

![1632453722952](.\images\1632453722952.png)

![1632453832503](.\images\1632453832503.png)

![1632454325135](.\images\1632454325135.png)

![1632454367753](.\images\1632454367753.png)



### 2. 不同的垃圾回收器概述

![1632455257726](.\images\1632455257726.png)

![1632455411164](.\images\1632455411164.png)

![1632469061355](.\images\1632469061355.png)

**七种经典的垃圾收集器：**

![1632455822174](.\images\1632455822174.png)

![1632456051645](.\images\1632456051645.png)

![1632468596165](.\images\1632468596165.png)

![1632469272496](.\images\1632469272496.png)

### 3. Serial回收器：串行回收

![1632469597692](.\images\1632469597692.png)

![1632469892662](.\images\1632469892662.png)

![1632470236440](.\images\1632470236440.png)

### 4. ParNew回收器：并行回收

![1632470330979](.\images\1632470330979.png)

![1632470536551](.\images\1632470536551.png)

![1632470606390](.\images\1632470606390.png)

### 5. Parallel回收器：吞吐量优先

![1632471047070](.\images\1632471047070.png)

![1632471134661](.\images\1632471134661.png)

![1632471396087](.\images\1632471396087.png)

![1632471408632](.\images\1632471408632.png)

![1632471694312](.\images\1632471694312.png)

![1632471896247](.\images\1632471896247.png)

### 6. CMS回收器：低延迟

![1632472219973](.\images\1632472219973.png)

![1632472358900](.\images\1632472358900.png)

![1632472510579](.\images\1632472510579.png)

![1632472749037](.\images\1632472749037.png)

![1632472878430](.\images\1632472878430.png)

![1632473046585](.\images\1632473046585.png)

![1632473126479](.\images\1632473126479.png)

![1632473159427](.\images\1632473159427.png)

![1632473487145](.\images\1632473487145.png)

![1632473757670](.\images\1632473757670.png)

### 7. G1回收器：区域化分代式

![1632551550481](.\images\1632551550481.png)

![1632552009948](.\images\1632552009948.png)

![1632552363100](.\images\1632552363100.png)

![1632552421234](.\images\1632552421234.png)

![1632552733155](.\images\1632552733155.png)

![1632552848340](.\images\1632552848340.png)

![1632552970106](.\images\1632552970106.png)

![1632553368291](.\images\1632553368291.png)

![1632553703412](.\images\1632553703412.png)

![1632554138858](.\images\1632554138858.png)

![1632554239743](.\images\1632554239743.png)

![1632554473524](.\images\1632554473524.png)

![1632554956447](.\images\1632554956447.png)

![1632555402205](.\images\1632555402205.png)

![1632555515871](.\images\1632555515871.png)

![1632555819197](.\images\1632555819197.png)

![1632556395432](.\images\1632556395432.png)

![1632556836885](.\images\1632556836885.png)

![1632556722155](.\images\1632556722155.png)

![1632556854042](.\images\1632556854042.png)

![1632556983024](.\images\1632556983024.png)

![1632557037354](.\images\1632557037354.png)

![1632557205296](.\images\1632557205296.png)

![1632557323181](.\images\1632557323181.png)

![1632557399794](.\images\1632557399794.png)

### 8. 垃圾回收器总结

![1632557457041](.\images\1632557457041.png)

![1632557750584](.\images\1632557750584.png)

### 9. GC日志分析

[CSDN-Java GC日志查看，GC日志时间分析](https://blog.csdn.net/xiaocai9999/article/details/88368395)

###10. 垃圾回收器的新发展

![1632558859735](.\images\1632558859735.png)

![1632558921703](.\images\1632558921703.png)

![1632559097883](.\images\1632559097883.png)

![1632559264518](.\images\1632559264518.png)

![1632559408396](.\images\1632559408396.png)

![1632559425722](.\images\1632559425722.png)

# JVM中篇

## 01. Class文件结构

[CSDN-宋红康JVM教程-中篇-第1章Class文件结构-3-Class文件结构](https://blog.csdn.net/admin741admin/article/details/108780073?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242)

### 1. 概述

**字节码文件的跨平台性：**

![1632640179599](.\images\1632640179599.png)

![1632640791628](.\images\1632640791628.png)

![1632640804195](.\images\1632640804195.png)

**Java的前端编译器：**

![1632640985854](.\images\1632640985854.png)

![1632641188932](.\images\1632641188932.png)

**透过字节码指令看代码细节：**

![1632641564782](.\images\1632641564782.png)

### 2. 虚拟机的基石：Class文件

![1632643318262](.\images\1632643318262.png) 

![1632643711512](.\images\1632643711512.png)

### 3. Class文件结构

![1632646013417](.\images\1632646013417.png)

![1632646526244](.\images\1632646526244.png)

**魔数：**

![1632647234452](.\images\1632647234452.png)

**Class文件版本号：**

![1632647585782](.\images\1632647585782.png)

![1632647564167](.\images\1632647564167.png)

**常量池：**

![1632647858162](.\images\1632647858162.png)

![1632648137352](.\images\1632648137352.png)

![1632648200518](.\images\1632648200518.png)

![1632648377547](.\images\1632648377547.png)

![1632648502174](.\images\1632648502174.png)

![1632648577600](.\images\1632648577600.png)

![1632648687498](.\images\1632648687498.png)

![1632648834883](.\images\1632648834883.png)

 ![img](http://dl.iteye.com/upload/picture/pic/116435/d0e661bb-74ec-3459-836e-6983629a85f9.bmp) 

![1632650884699](.\images\1632650884699.png)

**访问标识：**

![1632806329737](.\images\1632806329737.png)

![1632806949906](.\images\1632806949906.png)

**类索引、父类索引、接口索引集合：**

![1632807042883](.\images\1632807042883.png)

![1632807218950](.\images\1632807218950.png)

**字段表集合：**

![1632807499264](.\images\1632807499264.png)

![1632808295819](.\images\1632808295819.png)

![1632808631731](.\images\1632808631731.png)

**方法表集合：**

![1632808716508](.\images\1632808716508.png)

![1632809127539](.\images\1632809127539.png)

**属性表集合：**

[ **Chapter 6. The Java Virtual Machine Instruction Set** ](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.aload_n)

![1632809587197](.\images\1632809587197.png)

![1632809716254](.\images\1632809716254.png)

### 4. 使用javap指令解析Class文件

![1632811447234](.\images\1632811447234.png)

![1632811590356](.\images\1632811590356.png)

## 02. 字节码指令集与解析举例

[ **Chapter 6. The Java Virtual Machine Instruction Set** ](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.aload_n)

### 1. 概述

![1632974023807](.\images\1632974023807.png)

**执行模型：**

![1632974618025](.\images\1632974618025.png)

**字节码与数据类型：**

![1632974679296](.\images\1632974679296.png)

**指令分类：**

![1632975214251](.\images\1632975214251.png)

### 2. 加载与存储指令

![1632975268125](.\images\1632975268125.png)

**局部变量压栈指令：**

![1632975897166](.\images\1632975897166.png)

**常量入栈指令：**

![1632976247104](.\images\1632976247104.png)

![1632977575013](.\images\1632977575013.png)

**出栈装入局部变量表：**

![1632977820264](.\images\1632977820264.png)

### 3.算数指令

![1632978397367](.\images\1632978397367.png)

![1632978446683](.\images\1632978446683.png)

![1632978586649](.\images\1632978586649.png)

![1632979803110](.\images\1632979803110.png)

### 4. 类型转换指令

**宽化类型转换：**

![1633147314934](.\images\1633147314934.png)

![1633148250467](.\images\1633148250467.png)

**窄化类型转换：**

![1633148499702](.\images\1633148499702.png)

![1633149486825](.\images\1633149486825.png)

### 5. 对象的创建与访问指令

**创建指令：**

![1633149619331](.\images\1633149619331.png)

**字段访问指令：**

![1633150546745](.\images\1633150546745.png)

**数组操作指令：**

![1633151223579](.\images\1633151223579.png)

![1633151363949](.\images\1633151363949.png)

**类型检查指令：**

![1633152155550](.\images\1633152155550.png)

### 6. 方法调用与返回指令

![1633152298263](.\images\1633152298263.png)

![1633153194519](.\images\1633153194519.png)

### 7. 操作数栈管理指令

![1633164939723](.\images\1633164939723.png)

![1633166069469](.\images\1633166069469.png)

### 8. 控制转移指令

**条件跳转指令：**

![1633166678628](.\images\1633166678628.png)

![1633166801614](.\images\1633166801614.png)

**比较条件跳转指令：**

![1633167272513](.\images\1633167272513.png)

**多条件分支跳转：**

![1633167365919](.\images\1633167365919.png)

![1633167534999](.\images\1633167534999.png)

**无条件跳转：**

![1633167667215](.\images\1633167667215.png)

### 9. 异常处理指令

![1633167787034](.\images\1633167787034.png)

![1633168249960](.\images\1633168249960.png)

![1633168736562](.\images\1633168736562.png)

### 10. 同步控制指令

![1633169018843](.\images\1633169018843.png)

![1633169158536](.\images\1633169158536.png)

## 03. 类的加载过程

### 1. 概述

![1633169875269](.\images\1633169875269.png)

![1633169948542](.\images\1633169948542.png)

### 2. Loading（加载）阶段

![1633234542951](.\images\1633234542951.png)

![1633235201406](.\images\1633235201406.png)

![1633235476015](.\images\1633235476015.png)

![1633235759656](.\images\1633235759656.png)

### 3.Linking（链接）阶段

![1633236083226](.\images\1633236083226.png)

![1633236286701](.\images\1633236286701.png)

![1633236728388](.\images\1633236728388.png)

![1633236753615](.\images\1633236753615.png)

---

![1633238038375](.\images\1633238038375.png)

![1633238605435](.\images\1633238605435.png)

---

![1633239257753](.\images\1633239257753.png)

![1633239557354](.\images\1633239557354.png)

### 4. Initialization（初始化）阶段

![1633239823502](.\images\1633239823502.png)

![1633241093573](.\images\1633241093573.png)

![1633241285738](.\images\1633241285738.png)

---

![1633241346764](.\images\1633241346764.png)

---

![1633241630572](.\images\1633241630572.png)

![1633241645557](.\images\1633241645557.png)

 ![1633243276098](.\images\1633243276098.png)

----

### 5. 类的Using（使用）

![1633243716020](.\images\1633243716020.png)

### 6. 类的Unloading（卸载）

![1633243955972](.\images\1633243955972.png)

![1633244098715](.\images\1633244098715.png)

![1633244129470](.\images\1633244129470.png)

## 04. 再谈类的加载器

### 1. 概述

![1633331039463](.\images\1633331039463.png)

**类的加载分类：**

![1633331299658](.\images\1633331299658.png)

**类加载器的必要性：**

![1633331501935](.\images\1633331501935.png)

**命名空间：**

![1633331806230](.\images\1633331806230.png)

**类加载器的基本特征：**

![1633332547329](.\images\1633332547329.png)

### 2. 复习：类的加载器分类

![1633332675856](.\images\1633332675856.png)

![1633332773927](.\images\1633332773927.png)

**引导类加载器：**

![1633333078700](.\images\1633333078700.png)

**扩展类加载器：**

![1633333360994](.\images\1633333360994.png)

**应用程序类加载器：**

![1633333712484](.\images\1633333712484.png)

**用户自定义类加载器：**

![1633333819425](.\images\1633333819425.png)

### 3. 测试不同的类加载器

![1633333943153](.\images\1633333943153.png)

### 4. ClassLoader源码分析

![1633334771393](.\images\1633334771393.png)

![1633335810798](.\images\1633335810798.png)

### 5. 双亲委派模型

![1633335929390](.\images\1633335929390.png)

![1633336073840](.\images\1633336073840.png)

![1633336509086](.\images\1633336509086.png)

**破坏双亲委派机制：**

![1633336805518](.\images\1633336805518.png)

![1633336935264](.\images\1633336935264.png)

![1633337214273](.\images\1633337214273.png)

**热替换的实现：**

![1633337766822](.\images\1633337766822.png)

![1633337777813](.\images\1633337777813.png)

### 6. 沙箱安全机制

![1633512258029](.\images\1633512258029.png)

### 7. 自定义类的加载器

![1633512514479](.\images\1633512514479.png)

![1633512741825](.\images\1633512741825.png)

![1633512925037](.\images\1633512925037.png)

### 8. Java9新特性

![1633513769463](.\images\1633513769463.png)

![1633514040867](.\images\1633514040867.png)

# JVM下篇

## 01. 概述篇

### 1. 大厂面试题

### 2. 背景说明

![1633514691973](.\images\1633514691973.png)

### 3. 调优概述

![1633580648108](.\images\1633580648108.png)

### 4. 性能优化的步骤

![1633580716069](.\images\1633580716069.png)

![1633580868898](.\images\1633580868898.png)

![1633580919015](.\images\1633580919015.png)

![1633581011737](.\images\1633581011737.png)

### 5. 性能评价/测试指标

![1633581181553](.\images\1633581181553.png)

![1633581248317](.\images\1633581248317.png)

## 02. JVM监控及诊断工具-命令行篇

[CSDN-JVM监控及诊断工具（一）](https://blog.csdn.net/m0_45031497/article/details/114859568)

### 1. 概述

![1633582018533](.\images\1633582018533.png)

## 03. JVM监控及诊断工具-GUI篇

[CSDN-JVM监控及诊断工具-GUI篇](https://blog.csdn.net/qq_42185762/article/details/115324300?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242)

[CSDN-jvisualvm安装插件](https://blog.csdn.net/shuai825644975/article/details/78970371)

 

### 04. JVM运行时参数

[CSDN-JVM运行时参数](https://blog.csdn.net/qq_42185762/article/details/115548574?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163368196116780274143332%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163368196116780274143332&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-115548574.first_rank_v2_pc_rank_v29&utm_term=jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0&spm=1018.2226.3001.4187)