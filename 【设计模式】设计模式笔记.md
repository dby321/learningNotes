# 设计模式

> 如果想成为合格软件工程师，花时间来研究设计模式是非常必要的
>
> 编程=算法（数据结构）+设计模式
>
> 面试会问：你用过哪些设计模式，怎么使用的，解决了什么问题
>
> Spring、Mybatis、Tomcat源码都是可以研究的
>
> 设计模式有7大原则和23种设计模式

## 设计模式的7大原则

> 为了让程序具有更好的：
>
> 1. 代码重用性：相同功能的代码，不用多次编写
> 2. 可读性：编程规范性，便于其他程序员的阅读和理解
> 3. 可拓展性：增加新的功能时，非常的方便
> 4. 可靠性：增加新的功能后，对原来的功能没有影响
> 5. 使程序呈现高内聚、低耦合的特性
>
> 设计模式的原则是设计模式是怎么设计的原则

### 单一职责原则

> 单一职责是针对类、方法。

### 接口隔离原则 

> 一个类对另一个类的依赖应该建立在最小的接口上



![不符合接口隔离原则图1](./images/image-20221124221706048.png)

![接口隔离原则图1](./images/image-20221124222201751.png)



### 依赖倒转原则

> 1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象
> 2. 抽象不应该依赖细节，细节应该依赖抽象
> 3. 依赖倒转的中心思想是面向接口编程

### 里氏替换原则lsp

> 继承实际上让两个类的耦合性增强了，在适当的情况下， 可以通过聚合、组合、依赖来解决问题
>
> 可以创建一个更加基础的基类  

### 开闭原则ocp

> 是编程中最重要、最基础的原则
>
> 一个软件实体如类、模块和函数应该对拓展开放（对提供方），对修改关闭（对使用方）

### 迪米特法则

> 又叫最少知道原则，一个类对自己依赖的类知道的越少越好
>
> 我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部

### 合成复用原则

![image-20221125145436766](./images/image-20221125145436766.png)

## UML图

> 类图是UML图中的核心
>
> 聚合：整体和部分可以分开
>
> 组合：整体和部分不能分开
>
> 人头和人是组合关系，人和身份证是聚合关系

![image-20221125163215260](./images/image-20221125163215260.png)

## 二十三种设计模式

![image-20221125170801232](./images/image-20221125170801232.png)

### 单例模式

> 单例模式就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，**并且该类只提供一个取得其对象实例的静态方法。**
>
> 比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目只需要一个SessionFactory就够了，这就用到了单例模式

### 简单工厂模式

> 也叫静态工厂模式
>
> Calendar就是简单工厂模式

![订购pizza传统思路](./images/image-20221127104031980.png)

![订购pizza简单工厂](./images/image-20221127104255703.png)

### 工厂方法模式

> 将对象的实例化推迟到子类

![image-20221129112605075](./images/image-20221129112605075.png)

### 抽象工厂模式

> 定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
>
> 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
>
> 将工厂抽象成两层：抽象工厂和具体实现的工厂子类。这样将单个的简单工厂变成了工厂簇。

![image-20221129110953087](./images/image-20221129110953087.png)

### 原型模式

> Spring中原型bean的创建就用到了原型模式

![image-20221129150622230](./images/image-20221129150622230.png)

### 建造者模式

> 将产品和产品建造过程解耦
>
> StringBuilder

![image-20221129213552054](./images/image-20221129213552054.png)

![image-20221129205039195](./images/image-20221129205039195.png)

![image-20221129205217130](./images/image-20221129205217130.png)

### 适配器模式

> springMvc源码讲解没听懂

![类适配器模式](./images/image-20221201103154222.png)

![对象适配器模式](./images/image-20221201104832561.png)

![接口适配器模式](./images/image-20221201111657451.png)

### 桥接模式

> 传统方式解决存在类爆炸的问题
>
> 桥接模式：将**实现和抽象放在两个不同的类层次中**，使两个层次可以独立改变，它是一种结构型设计模式。它基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的之策。它的主要特点是把首相与行为实现分离开来，从而可以保持各部分的独立性以及应对他们的功能拓展。
>
> jdbc中使用了桥接模式
>
> 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用

![传统方式](./images/image-20221202095959002.png)

![桥接模式](./images/image-20221202101318987.png)

> 桥接模式原理类图解析：
>
> 1. client类：桥接模式的调用者
> 2. 抽象类：维护了Implementor/既它的实现类ConcreteImplementorA,二者是聚合关系，Abstraction充当桥接类
> 3. RefinedAbstraction：是Abstraction抽象类的子类
> 4. Implementor：是行为实现类的接口
> 5. ConcreteImplementorA/B:是行为的具体实现类

![桥接模式实践](./images/image-20221202102154993.png)

### 装饰者模式

> 也是用来解决类爆炸
>
> JDK中IO流使用了装饰者模式

![传统方式](./images/image-20221202111217097.png)

![传统方式2](./images/image-20221202111514858.png)

![装饰者模式（这就是套娃的力量）](./images/image-20221202112626949.png)

![装饰者模式类图](./images/image-20221202112833822.png)

![装饰者模式在jdk中的应用](./images/image-20221203114603583.png)

![DataInputStream类图](./images/DataInputStream%E7%B1%BB%E5%9B%BE.png)

### 组合模式

> HashMap和其静态内部类Node用到了组合模式

![组合模式](./images/image-20221203153239133.png)

### 外观模式

> 外观模式对外屏蔽了子系统的细节

![传统方式解决会有很多遥控器](./images/image-20221203162127746.png)

![外观模式](./images/image-20221203162528464.png)
