# JVM上篇

## 01. JVM与Java体系结构

![1628584302265](.\images\1628584302265.png)

Java虚拟机平台上运行非Java语言编写的程序

### 5. 虚拟机和Java虚拟机

虚拟机可以分为系统虚拟机和程序虚拟机

- VMware就属于系统虚拟机，他们完全是对物理计算机的仿真

- 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计

Java虚拟机的作用：Java虚拟机就是二进制字节码的运行环境

Java虚拟机的特点：一次编译，到处运行。自动内存管理。自动垃圾回收功能。

![1628585789031](.\images\1628585789031.png)

### 6. JVM的整体结构

![1628586039264](.\images\1628586039264.png)

多个线程共享方法区和堆，Java栈、本地方法栈、程序计数器是每个线程独有一份的

### 7. Java代码执行流程

![1628756709478](.\images\1628756709478.png)

### 8. JVM的架构模型

Java编译器输入的指令流基本上是一种栈的指令集架构，另一种是寄存器的指令集架构

- 基于栈式架构的特点
  - 设计和实现更简单，适用于资源受限的系统
  - 避开了寄存器的分配难题，使用零地址指令方式分配
  - 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
  - 不需要硬件支持，可以执行更好，更好的跨平台
- 基于寄存器的特点
  - 典型的应用是x86的二进制指令集
  - 指令集架构则完全依赖硬件，可以执行差
  - 性能优秀和执行更高效
  - 花费更少的指令去完成一项操作
  - 大部分情况下，基于寄存器架构的指令集往往都以一地址指令，二地址指令和三地址指令为主

总结：由于跨平台性的设计，Java的指令都是根据栈来设计的

### 9. JVM的生命周期

- 虚拟机的启动：是通过引导类加载器bootstrap class loader创建一个初始类来完成的，这个类是由虚拟机的具体实现指定的
- 虚拟机的执行：
  - 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序
  - 程序开始执行他才运行，程序结束他就停止
  - 执行一个所谓的Java程序的时候，真正执行的是一个叫做Java虚拟机的进程
- 虚拟机的退出：
  - 程序正常执行结束
  - 程序在执行过程中遇到了异常或错误而异常终止
  - 由于操作系统出现错误而导致Java虚拟机进程终止
  - 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
  - JNI规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机退出情况

### 10. JVM发展历程

- Sun Classic VM
- Exact VM
- HotSpot VM：名称中的HotSpot指的是热点代码探测技术：通过计数器找到最具编译价值代码，触发即时编译或栈上替换；通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡
- BEA的JRocket：专注于服务器端的应用
- IBM的J9：号称世界上最快的虚拟机
- KVM和CDC/CLDC HotSpot
- Azul VM
- Liquid VM
- Apache Harmony
- Microsoft JVM
- Taobao JVM
- Graal VM

## 02. 类加载子系统

![1628838034799](.\images\1628838034799.png)

类加载器子系统作用：

- 类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件表示
- ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定
- 加载的类信息存放与一块成为方法区的内存空间，除了类的信息外，方法区中还会存放运行时常量池的信息，可能还包括字符串字面量和数字常量



----

加载：

1. 通过一个类全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

----

![1630119311307](.\images\1630119311307.png)

  ![1630120501529](.\images\1630120501529.png)

类加载器的分类：

![1630832390662](.\images\1630832390662.png)

![1630832501482](.\images\1630832501482.png)

![1630832606797](.\images\1630832606797.png)

![1630832665919](.\images\1630832665919.png)

```java
import java.util.Arrays;
import java.util.List;

/**
 * 3种类加载器的加载目录
 * @ author:xxx
 * @ date:2020/8/2 00:05
 */
public class TargetForClassLoader {

    public static void main(String[] args) {
        bootstrapClassLoader();
//        extClassLoader();
//        appClassLoader();
    }·

    /**
     * 启动类加载器的职责
     */
    public static void bootstrapClassLoader() {
        String property = System.getProperty("sun.boot.class.path");
        List<String> list = Arrays.asList(property.split(";"));
        list.forEach((t) -> {
            System.out.println("启动类加载器目录:" + t);
        });
    }


    /**
     * 扩展类加载器
     */
    public static void extClassLoader() {
        String property = System.getProperty("java.ext.dirs");
        List<String> list = Arrays.asList(property.split(";"));
        list.forEach((t) -> {
            System.out.println("扩展类加载器" + t);
        });
    }

    /**
     * app 类加载器
     */
    public static void appClassLoader() {
        String property = System.getProperty("java.class.path");
        List<String> list = Arrays.asList(property.split(";"));
        list.forEach((t) -> {
            System.out.println("应用类加载器" + t);
        });
    }
}
```

![1630833293292](.\images\1630833293292.png)

![1630833474775](.\images\1630833474775.png)

![1630833613372](.\images\1630833613372.png)

---

双亲委派机制：

![1630833835800](.\images\1630833835800.png)

![1630834168217](.\images\1630834168217.png)

![1630834485772](.\images\1630834485772.png)

![1630834572871](.\images\1630834572871.png)

双亲委派机制的优势：

- 避免类的重复加载
- 保护程序安全，防止核心API被篡改

----

![1630834794699](.\images\1630834794699.png)

----

![1630834968574](.\images\1630834968574.png)

![1630835065970](.\images\1630835065970.png)

![1630835211616](.\images\1630835211616.png)

## 03. 运行时数据区概述及线程

### 1. 概述

![1630909871255](.\images\1630909871255.png)

标红色的为多个线程共享的

标灰色的为一个线程私有的

### 2. 线程

![1630910751062](.\images\1630910751062.png)

![1630910813908](.\images\1630910813908.png)

## 04. 程序计数器（PC寄存器）

### 1. PC Register介绍

![1630911159543](.\images\1630911159543.png)

![1630911443911](.\images\1630911443911.png)

![1630911636489](.\images\1630911636489.png)

### 2. 举例说明

![1630912543510](.\images\1630912543510.png)

### 3. 两个常见的问题

![1630912710827](.\images\1630912710827.png)

![1630912890344](.\images\1630912890344.png)

## 05. 虚拟机栈

### 1. 虚拟机栈概述

![1630913193831](.\images\1630913193831.png)

![1630913253381](.\images\1630913253381.png)

![1630913847996](.\images\1630913847996.png)

![1630914030825](.\images\1630914030825.png)

![1630914412324](.\images\1630914412324.png)

### 2. 栈的存储单位

![1631001757360](.\images\1631001757360.png)

![1631001857707](.\images\1631001857707.png)

 ![1631002726963](.\images\1631002726963.png)





### 3. 局部变量表

![1631003382715](.\images\1631003382715.png)

![1631003933848](.\images\1631003933848.png)

![1631003950064](.\images\1631003950064.png)

![1631004664484](.\images\1631004664484.png)

![1631005901203](.\images\1631005901203.png)

![1631006129852](.\images\1631006129852.png)

![1631006526113](.\images\1631006526113.png)

![1631007069013](.\images\1631007069013.png)

![1631007185241](.\images\1631007185241.png)

### 4. 操作数栈

![1631007450202](.\images\1631007450202.png)

![1631007842174](.\images\1631007842174.png)

![1631007902822](.\images\1631007902822.png)

### 5. 代码追踪

略

### 6. 栈顶缓存技术

![1631083013561](.\images\1631083013561.png)



### 7. 动态链接

![1631084225955](.\images\1631084225955.png)

![1631084663908](.\images\1631084663908.png)

![1631084740376](.\images\1631084740376.png)

### 8. 方法的调用：解析与分派

![1631084967032](.\images\1631084967032.png)

![1631085036385](.\images\1631085036385.png)

![1631085571848](.\images\1631085571848.png)

![1631086276722](.\images\1631086276722.png)

![1631086513625](.\images\1631086513625.png)

![1631087371871](.\images\1631087371871.png)

![1631087500336](.\images\1631087500336.png)

![1631088238459](.\images\1631088238459.png)

### 9. 方法返回地址

![1631089083890](.\images\1631089083890.png)

![1631089098440](.\images\1631089098440.png)

![1631089201627](.\images\1631089201627.png)

![1631089326328](.\images\1631089326328.png)

### 10. 一些附加信息

略

### 11. 栈的相关面试题

内部产生，内部消亡就是线程安全的

 ![1631332566895](.\images\1631332566895.png)

## 06. 本地方法接口

![1631332840932](.\images\1631332840932.png)

![1631333116017](.\images\1631333116017.png)

![1631333433507](.\images\1631333433507.png)

## 07. 本地方法栈

![1631344036174](.\images\1631344036174.png)

![1631343919671](.\images\1631343919671.png)

## 08. 堆

### 1. 堆的核心概述

![](.\images\1631345402738.png)

![1631346150396](.\images\1631346150396.png)

![1631346516001](.\images\1631346516001.png)

![1631431014963](.\images\1631431014963.png)

### 2. 设置堆内存大小与OOM

![1631431789852](.\images\1631431789852.png)

查看堆空间设置的参数：

1. `jps` `jstat -gc 进程id`
2. `-XX：+PrintGCDetails`



### 3. 年轻代与老年代

![1631434332338](.\images\1631434332338.png)

设置新生代与老年代的比例（默认是1:2）：`-XX:NewRatio=2`

设置伊甸园区和幸存者区比例（默认是8:1:1，但是实际观察是6:1:1）:`-XX:SurviverRatio=8`

关闭自适应的内存分配策略：`-XX：-UseAdaptivesSizePolicy`

设置新生代的内存大小(一般不设置)：`-Xmn`

> 几乎所有的java对象都是在伊甸园区被new出来的
>
> 绝大部分的java对象的销毁都是在新生代进行，新胜达中80%的对象都是朝生夕死的

![1631435215921](.\images\1631435215921.png)

### 4. 图解对象分配过程

![1631435988937](.\images\1631435988937.png)

![1631436012538](.\images\1631436012538.png)

![1631436027544](.\images\1631436027544.png)

幸存者区到老年区的提升阈值(默认为15)：`-XX：MaxTenuringThreshold=15`

![1631436472308](.\images\1631436472308.png)

![1631499859084](.\images\1631499859084.png)

![1631500327920](.\images\1631500327920.png)

### 5. Minor GC、Major GC、Full GC

伊甸园区满触发Minor GC,进行伊甸园区和幸存者区垃圾回收

![1631502187354](.\images\1631502187354.png)

![1631502419873](.\images\1631502419873.png)

![1631502538913](.\images\1631502538913.png)

![1631502579890](.\images\1631502579890.png)

### 6. 堆空间分代思想

![1631503222701](.\images\1631503222701.png)

![1631503269820](.\images\1631503269820.png)



### 7. 内存分配策略

![1631503789218](.\images\1631503789218.png)

在发生**Minor GC**之前，虚拟机会检查**老年代最大可用的连续空间**是否**大于新生代所有对象的总空间**，

　　　　如果大于，则此次**Minor GC是安全的**

　　　　如果小于，则虚拟机会查看**HandlePromotionFailure**设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于**历次晋升到老年代的对象的平均大小**，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。

### 8. 为对象分配内存：TLAB

![1631504276627](.\images\1631504276627.png)

![1631504401715](.\images\1631504401715.png)**(去掉非)**

![1631504529412](.\images\1631504529412.png)

![1631504796976](.\images\1631504796976.png)

### 9. 小结堆空间的参数设置

[CSDN-堆空间常用参数总结](https://blog.csdn.net/qq_40381509/article/details/116094811)

### 10. 堆是分配对象的唯一选择吗？

![1631505163622](.\images\1631505163622.png)

![1631505267145](.\images\1631505267145.png)

![1631505411632](.\images\1631505411632.png)

![1631505763050](.\images\1631505763050.png)

![1631505798915](.\images\1631505798915.png)

![1631522096809](.\images\1631522096809.png)

![1631522165551](.\images\1631522165551.png)

![1631522267759](.\images\1631522267759.png)

![1631522587977](.\images\1631522587977.png)

![1631522635999](.\images\1631522635999.png)

![1631522648665](.\images\1631522648665.png)

## 09. 方法区

### 1. 栈、堆、方法区的交互关系

![1631523544943](.\images\1631523544943.png)

### 2. 方法区的理解

![1631523969813](.\images\1631523969813.png)

![1631524175180](.\images\1631524175180.png)

方法区的溢出：

![1631524352538](.\images\1631524352538.png)

![1631524549737](.\images\1631524549737.png)

![1631524720908](.\images\1631524720908.png)



### 3. 设置方法区大小与OOM

![1631524862192](.\images\1631524862192.png)

![1631525013534](.\images\1631525013534.png)

![1631525518078](.\images\1631525518078.png)



### 4. 方法区的内部结构

![1631525978389](.\images\1631525978389.png)

![1631526166395](.\images\1631526166395.png)

![1631526208003](.\images\1631526208003.png)

![1631526259150](.\images\1631526259150.png)

![1631528042382](.\images\1631528042382.png)

![1631528765068](.\images\1631528765068.png)

![1631588940366](.\images\1631588940366.png)

### 5. 方法区使用举例

略

### 6. 方法区的演进细节

![1631590149138](.\images\1631590149138.png)

![1631591269927](.\images\1631591269927.png)

### 7. 方法区的垃圾回收

![1631592128563](.\images\1631592128563.png)

![1631593746355](.\images\1631593746355.png)

![1631593782477](.\images\1631593782477.png)

![1631594034038](.\images\1631594034038.png)

### 8. 总结

![1631603886141](.\images\1631603886141.png)

## 10. 对象的实例化内存布局与访问定位

### 1. 对象的实例化

![1631604393858](.\images\1631604393858.png)

### 2. 对象的内存布局

<img src=".\images\1631606636602.png" alt="1631606636602"  />

![1631607030380](.\images\1631607030380.png)

[Java中的常量池(字符串常量池、class常量池和运行时常量池)](https://blog.csdn.net/zm13007310400/article/details/77534349)

### 3. 对象的访问定位

![1631675750471](.\images\1631675750471.png)

![1631675829108](.\images\1631675829108.png)

## 11. 直接内存

![1631676735336](.\images\1631676735336.png)

![1631677239169](.\images\1631677239169.png)

![1631677903662](.\images\1631677903662.png)

##12. 执行引擎

### 1. 执行引擎概述

![1631679071168](.\images\1631679071168.png)

![1631679219695](.\images\1631679219695.png)

![1631679865051](.\images\1631679865051.png)

### 2. Java代码编译和执行过程

![1631680003203](.\images\1631680003203.png)

![1631680147198](.\images\1631680147198.png)

![1631680185991](.\images\1631680185991.png)

![1631680225641](.\images\1631680225641.png)



### 3. 机器码、指令、汇编语言

略

### 4. 解释器

![1631688627519](.\images\1631688627519.png)

![1631688854383](.\images\1631688854383.png)

![1631689008280](.\images\1631689008280.png)

### 5. JIT编译器

热点代码用JIT编译器

![1631690059547](.\images\1631690059547.png)

![1631690080344](.\images\1631690080344.png)

![1631690274364](.\images\1631690274364.png)

![1631690388737](.\images\1631690388737.png)

![1631690580454](.\images\1631690580454.png)

![1631690676378](.\images\1631690676378.png)

![1631853820197](.\images\1631853820197.png)

![1631854636284](.\images\1631854636284.png)

![1631854700041](.\images\1631854700041.png)

![1631854851894](.\images\1631854851894.png)

![1631855059989](.\images\1631855059989.png)

![1631855153395](.\images\1631855153395.png)

## 13. StringTable

### 1. String的基本特性

![1631856199643](.\images\1631856199643.png)

**String具有不可变性**

![1631857542971](.\images\1631857542971.png)

`jps` `jinfo -flag 属性名（如StringTableSize） 进程ID`

### 2. String的内存分配

![1631858085775](.\images\1631858085775.png)

![1631858184519](.\images\1631858184519.png)

![1631858339459](.\images\1631858339459.png)



### 3. String的基本操作

略

### 4. 字符串拼接操作

![1631863276103](.\images\1631863276103.png)

![1631864110015](.\images\1631864110015.png)

> 在jdk5.0之后用的是StringBuilder,之前用的是StringBuffer 

![1631864314060](.\images\1631864314060.png)

​    **体会执行效率**：通过 StringBuilder 的 append() 的方式添加字符串的效率要远高于使用 String 的字符串拼接方式！
​    ①  StringBuilder的append()的方式：自始至终中只创建过一个 StringBuilder 的对象。
​       使用 String 的字符串拼接方式：创建过多个 StringBuilder 和 String 的对象
​    ②  使用 String 的字符串拼接方式：内存中由于创建了较多的 StringBuilder 和 String 的对象，内存占用更大；如果进行GC，需要花费额外的时间。
​    改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值 highLevel 的情况下,建议使用构造器实例化：
​       StringBuilder s = new StringBuilder(highLevel); // new char[highLevel]

     ```java
@Test
    public void test6() {
        long start = System.currentTimeMillis();
        method1(100000); // 6159
        //method2(100000); // 4
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start));
    }
    // 使用 String 的 + 进行字符串拼接
    public void method1(int highLevel) {
        String src = "";
        for (int i = 0; i < highLevel; i++) {
            src = src + "a"; // 每次循环都会创建一个 StringBuilder、String
        }
//        System.out.println(src);


    }
    // 使用 StringBuilder 的 append 方法进行拼接
    public void method2(int highLevel) {
        // 只需要创建一个 StringBuilder
        StringBuilder src = new StringBuilder();
        for (int i = 0; i < highLevel; i++) {
            src.append("a");
        }
//        System.out.println(src);
    }

     ```



### 5. intern()的使用

见上

![1631865973178](.\images\1631865973178.png)

总结String的intern()的使用：

jdk1.6中，将这个字符串对象尝试放入串池。
如果串池中有，则并不会放入。返回已有的串池中的对象的地址
如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址。
jdk1.7开始，将这个字符串尝试放入串池。
如果串池中有，则并不会放入。返回已有的串池中的对象的地址
如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址

[简书-Java String的intern方法 在JDK6和JDK7的不同行为](https://www.jianshu.com/p/697cc5381ba7)

![1631867942618](.\images\1631867942618.png)

### 6. StringTable的垃圾回收

略

### 7. G1的String去重操作

![1632020363933](.\images\1632020363933.png)

## 14. 垃圾回收概述

### 1. 什么是垃圾

![1632021263790](.\images\1632021263790.png)

### 2. 为什么需要GC

![1632021752103](.\images\1632021752103.png)

### 3. 早期垃圾回收

![1632022162405](.\images\1632022162405.png)

### 4. Java的垃圾回收机制

![1632022564286](.\images\1632022564286.png)

![1632022715715](.\images\1632022715715.png)

## 15. 垃圾回收相关算法

![1632023685664](.\images\1632023685664.png)

### 1. 标记阶段：引用计数算法

![1632024089305](.\images\1632024089305.png)

![1632024447107](.\images\1632024447107.png)

![1632040672658](.\images\1632040672658.png)

### 2. 标记阶段：可达性分析算法

![1632040859265](.\images\1632040859265.png)

![1632041163636](.\images\1632041163636.png)

![1632041209177](.\images\1632041209177.png)

![1632041427364](.\images\1632041427364.png)

![1632042094140](.\images\1632042094140.png)

### 3. 对象的finalization机制

![1632042226506](.\images\1632042226506.png)

![1632042480387](.\images\1632042480387.png)

![1632042676309](.\images\1632042676309.png)

![1632042947155](.\images\1632042947155.png)

### 4. MAT与JProfiler的GC Roots溯源

![1632043847612](.\images\1632043847612.png)

[P145-P146](https://www.bilibili.com/video/BV1PJ411n7xZ?p=146&spm_id_from=pageDriver)

### 5. 清除阶段： 标记-清除算法

![1632362655697](.\images\1632362655697.png)

 ![1632363605641](.\images\1632363605641.png)

### 6. 清除阶段：复制算法

![1632364307833](.\images\1632364307833.png)

![1632364227120](.\images\1632364227120.png)

![1632364508587](.\images\1632364508587.png)

> 类似幸存者0区和幸存者1区
>
> 新生代中适合使用复制算法 ，老年代不适合

### 7. 清除阶段：标记-压缩算法

![1632365450839](.\images\1632365450839.png)

![1632365614399](.\images\1632365614399.png)

![1632365781280](.\images\1632365781280.png)

![1632365762046](.\images\1632365762046.png)

### 8. 小结

![1632366141451](.\images\1632366141451.png)

### 9.分代收集算法

![1632366408431](.\images\1632366408431.png)

![1632366509060](.\images\1632366509060.png)

![1632366748866](.\images\1632366748866.png)

###10. 增量收集算法、分区算法

**增量收集算法：**

![1632366904444](.\images\1632366904444.png)

![1632366998459](.\images\1632366998459.png)

**分区算法：**

![1632367199209](.\images\1632367199209.png)

## 16. 垃圾回收相关概念

### 1. System.gc()的理解

![1632367829989](.\images\1632367829989.png)

![1632367973849](.\images\1632367973849.png)

### 2. 内存溢出与内存泄漏

![1632368555724](.\images\1632368555724.png)

![1632368703016](.\images\1632368703016.png)

![1632368733878](.\images\1632368733878.png)

![1632369039293](.\images\1632369039293.png)



### 3. Stop the world

![1632369238306](.\images\1632369238306.png)

![1632369350197](.\images\1632369350197.png)

### 4. 垃圾回收的并行与并发

![ds](.\images\1632378867474.png)

![1632379077497](.\images\1632379077497.png)

![1632379116717](.\images\1632379116717.png)

![1632379224552](.\images\1632379224552.png)

### 5. 安全点与安全区域

![1632379295182](.\images\1632379295182.png)

![1632379412398](.\images\1632379412398.png)

![1632379437675](.\images\1632379437675.png)

![1632379512857](.\images\1632379512857.png)

### 6. 再谈引用：强引用

![1632379815437](.\images\1632379815437.png)

![1632380063919](.\images\1632380063919.png)

### 7. 再谈引用：软引用

![1632380311961](.\images\1632380311961.png)

![1632380500199](.\images\1632380500199.png)

### 8. 再谈应用：弱引用

![1632380997906](.\images\1632380997906.png)

![1632381162044](.\images\1632381162044.png)

### 9. 再谈应用：虚引用

![1632381367965](.\images\1632381367965.png)

![1632381445822](.\images\1632381445822.png)

### 10. 再谈引用：终结器引用

![1632381952314](.\images\1632381952314.png)

## 17. 垃圾回收器

![1632453032632](.\images\1632453032632.png)

### 1. GC分类与性能指标

![1632453601431](.\images\1632453601431.png)

![1632453722952](.\images\1632453722952.png)

![1632453832503](.\images\1632453832503.png)

![1632454325135](.\images\1632454325135.png)

![1632454367753](.\images\1632454367753.png)



### 2. 不同的垃圾回收器概述

![1632455257726](.\images\1632455257726.png)

![1632455411164](.\images\1632455411164.png)

![1632469061355](.\images\1632469061355.png)

**七种经典的垃圾收集器：**

![1632455822174](.\images\1632455822174.png)

![1632456051645](.\images\1632456051645.png)

![1632468596165](.\images\1632468596165.png)

![1632469272496](.\images\1632469272496.png)

### 3. Serial回收器：串行回收

![1632469597692](.\images\1632469597692.png)

![1632469892662](.\images\1632469892662.png)

![1632470236440](.\images\1632470236440.png)

### 4. ParNew回收器：并行回收

![1632470330979](.\images\1632470330979.png)

![1632470536551](.\images\1632470536551.png)

![1632470606390](.\images\1632470606390.png)

### 5. Parallel回收器：吞吐量优先

![1632471047070](.\images\1632471047070.png)

![1632471134661](.\images\1632471134661.png)

![1632471396087](.\images\1632471396087.png)

![1632471408632](.\images\1632471408632.png)

![1632471694312](.\images\1632471694312.png)

![1632471896247](.\images\1632471896247.png)

### 6. CMS回收器：低延迟

![1632472219973](.\images\1632472219973.png)

![1632472358900](.\images\1632472358900.png)

![1632472510579](.\images\1632472510579.png)

![1632472749037](.\images\1632472749037.png)

![1632472878430](.\images\1632472878430.png)

![1632473046585](.\images\1632473046585.png)

![1632473126479](.\images\1632473126479.png)

![1632473159427](.\images\1632473159427.png)

![1632473487145](.\images\1632473487145.png)

![1632473757670](.\images\1632473757670.png)

### 7. G1回收器：区域化分代式

![1632551550481](.\images\1632551550481.png)

![1632552009948](.\images\1632552009948.png)

![1632552363100](.\images\1632552363100.png)

![1632552421234](.\images\1632552421234.png)

![1632552733155](.\images\1632552733155.png)

![1632552848340](.\images\1632552848340.png)

![1632552970106](.\images\1632552970106.png)

![1632553368291](.\images\1632553368291.png)

![1632553703412](.\images\1632553703412.png)

![1632554138858](.\images\1632554138858.png)

![1632554239743](.\images\1632554239743.png)

![1632554473524](.\images\1632554473524.png)

![1632554956447](.\images\1632554956447.png)

![1632555402205](.\images\1632555402205.png)

![1632555515871](.\images\1632555515871.png)

![1632555819197](.\images\1632555819197.png)

![1632556395432](.\images\1632556395432.png)

![1632556836885](.\images\1632556836885.png)

![1632556722155](.\images\1632556722155.png)

![1632556854042](.\images\1632556854042.png)

![1632556983024](.\images\1632556983024.png)

![1632557037354](.\images\1632557037354.png)

![1632557205296](.\images\1632557205296.png)

![1632557323181](.\images\1632557323181.png)

![1632557399794](.\images\1632557399794.png)

### 8. 垃圾回收器总结

![1632557457041](.\images\1632557457041.png)

![1632557750584](.\images\1632557750584.png)

### 9. GC日志分析

[CSDN-Java GC日志查看，GC日志时间分析](https://blog.csdn.net/xiaocai9999/article/details/88368395)

###10. 垃圾回收器的新发展

![1632558859735](.\images\1632558859735.png)

![1632558921703](.\images\1632558921703.png)

![1632559097883](.\images\1632559097883.png)

![1632559264518](.\images\1632559264518.png)

![1632559408396](.\images\1632559408396.png)

![1632559425722](.\images\1632559425722.png)

# JVM中篇

## 01. Class文件结构

[CSDN-宋红康JVM教程-中篇-第1章Class文件结构-3-Class文件结构](https://blog.csdn.net/admin741admin/article/details/108780073?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242)

### 1. 概述

**字节码文件的跨平台性：**

![1632640179599](.\images\1632640179599.png)

![1632640791628](.\images\1632640791628.png)

![1632640804195](.\images\1632640804195.png)

**Java的前端编译器：**

![1632640985854](.\images\1632640985854.png)

![1632641188932](.\images\1632641188932.png)

**透过字节码指令看代码细节：**

![1632641564782](.\images\1632641564782.png)

### 2. 虚拟机的基石：Class文件

![1632643318262](.\images\1632643318262.png) 

![1632643711512](.\images\1632643711512.png)

### 3. Class文件结构

![1632646013417](.\images\1632646013417.png)

![1632646526244](.\images\1632646526244.png)

**魔数：**

![1632647234452](.\images\1632647234452.png)

**Class文件版本号：**

![1632647585782](.\images\1632647585782.png)

![1632647564167](.\images\1632647564167.png)

**常量池：**

![1632647858162](.\images\1632647858162.png)

![1632648137352](.\images\1632648137352.png)

![1632648200518](.\images\1632648200518.png)

![1632648377547](.\images\1632648377547.png)

![1632648502174](.\images\1632648502174.png)

![1632648577600](.\images\1632648577600.png)

![1632648687498](.\images\1632648687498.png)

![1632648834883](.\images\1632648834883.png)

 ![img](http://dl.iteye.com/upload/picture/pic/116435/d0e661bb-74ec-3459-836e-6983629a85f9.bmp) 

![1632650884699](.\images\1632650884699.png)

**访问标识：**

![1632806329737](.\images\1632806329737.png)

![1632806949906](.\images\1632806949906.png)

**类索引、父类索引、接口索引集合：**

![1632807042883](.\images\1632807042883.png)

![1632807218950](.\images\1632807218950.png)

**字段表集合：**

![1632807499264](.\images\1632807499264.png)

![1632808295819](.\images\1632808295819.png)

![1632808631731](.\images\1632808631731.png)

**方法表集合：**

![1632808716508](.\images\1632808716508.png)

![1632809127539](.\images\1632809127539.png)

**属性表集合：**

[ **Chapter 6. The Java Virtual Machine Instruction Set** ](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.aload_n)

![1632809587197](.\images\1632809587197.png)

![1632809716254](.\images\1632809716254.png)

### 4. 使用javap指令解析Class文件

![1632811447234](.\images\1632811447234.png)

![1632811590356](.\images\1632811590356.png)

## 02. 字节码指令集与解析举例

[ **Chapter 6. The Java Virtual Machine Instruction Set** ](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.aload_n)

### 1. 概述

![1632974023807](.\images\1632974023807.png)

**执行模型：**

![1632974618025](.\images\1632974618025.png)

**字节码与数据类型：**

![1632974679296](.\images\1632974679296.png)

**指令分类：**

![1632975214251](.\images\1632975214251.png)

### 2. 加载与存储指令

![1632975268125](.\images\1632975268125.png)

**局部变量压栈指令：**

![1632975897166](.\images\1632975897166.png)

**常量入栈指令：**

![1632976247104](.\images\1632976247104.png)

![1632977575013](.\images\1632977575013.png)

**出栈装入局部变量表：**

![1632977820264](.\images\1632977820264.png)

### 3.算数指令

![1632978397367](.\images\1632978397367.png)

![1632978446683](.\images\1632978446683.png)

![1632978586649](.\images\1632978586649.png)

![1632979803110](.\images\1632979803110.png)

### 4. 类型转换指令

**宽化类型转换：**

![1633147314934](.\images\1633147314934.png)

![1633148250467](.\images\1633148250467.png)

**窄化类型转换：**

![1633148499702](.\images\1633148499702.png)

![1633149486825](.\images\1633149486825.png)

### 5. 对象的创建与访问指令

**创建指令：**

![1633149619331](.\images\1633149619331.png)

**字段访问指令：**

![1633150546745](.\images\1633150546745.png)

**数组操作指令：**

![1633151223579](.\images\1633151223579.png)

![1633151363949](.\images\1633151363949.png)

**类型检查指令：**

![1633152155550](.\images\1633152155550.png)

### 6. 方法调用与返回指令

![1633152298263](.\images\1633152298263.png)

![1633153194519](.\images\1633153194519.png)

### 7. 操作数栈管理指令

![1633164939723](.\images\1633164939723.png)

![1633166069469](.\images\1633166069469.png)

### 8. 控制转移指令

**条件跳转指令：**

![1633166678628](.\images\1633166678628.png)

![1633166801614](.\images\1633166801614.png)

**比较条件跳转指令：**

![1633167272513](.\images\1633167272513.png)

**多条件分支跳转：**

![1633167365919](.\images\1633167365919.png)

![1633167534999](.\images\1633167534999.png)

**无条件跳转：**

![1633167667215](.\images\1633167667215.png)

### 9. 异常处理指令

![1633167787034](.\images\1633167787034.png)

![1633168249960](.\images\1633168249960.png)

![1633168736562](.\images\1633168736562.png)

### 10. 同步控制指令

![1633169018843](.\images\1633169018843.png)

![1633169158536](.\images\1633169158536.png)

## 03. 类的加载过程

### 1. 概述

![1633169875269](.\images\1633169875269.png)

![1633169948542](.\images\1633169948542.png)

### 2. Loading（加载）阶段

![1633234542951](.\images\1633234542951.png)

![1633235201406](.\images\1633235201406.png)

![1633235476015](.\images\1633235476015.png)

![1633235759656](.\images\1633235759656.png)

### 3.Linking（链接）阶段

![1633236083226](.\images\1633236083226.png)

![1633236286701](.\images\1633236286701.png)

![1633236728388](.\images\1633236728388.png)

![1633236753615](.\images\1633236753615.png)

---

![1633238038375](.\images\1633238038375.png)

![1633238605435](.\images\1633238605435.png)

---

![1633239257753](.\images\1633239257753.png)

![1633239557354](.\images\1633239557354.png)

### 4. Initialization（初始化）阶段

![1633239823502](.\images\1633239823502.png)

![1633241093573](.\images\1633241093573.png)

![1633241285738](.\images\1633241285738.png)

---

![1633241346764](.\images\1633241346764.png)

---

![1633241630572](.\images\1633241630572.png)

![1633241645557](.\images\1633241645557.png)

 ![1633243276098](.\images\1633243276098.png)

----

### 5. 类的Using（使用）

![1633243716020](.\images\1633243716020.png)

### 6. 类的Unloading（卸载）

![1633243955972](.\images\1633243955972.png)

![1633244098715](.\images\1633244098715.png)

![1633244129470](.\images\1633244129470.png)

## 04. 再谈类的加载器

### 1. 概述

![1633331039463](.\images\1633331039463.png)

**类的加载分类：**

![1633331299658](.\images\1633331299658.png)

**类加载器的必要性：**

![1633331501935](.\images\1633331501935.png)

**命名空间：**

![1633331806230](.\images\1633331806230.png)

**类加载器的基本特征：**

![1633332547329](.\images\1633332547329.png)

### 2. 复习：类的加载器分类

![1633332675856](.\images\1633332675856.png)

![1633332773927](.\images\1633332773927.png)

**引导类加载器：**

![1633333078700](.\images\1633333078700.png)

**扩展类加载器：**

![1633333360994](.\images\1633333360994.png)

**应用程序类加载器：**

![1633333712484](.\images\1633333712484.png)

**用户自定义类加载器：**

![1633333819425](.\images\1633333819425.png)

### 3. 测试不同的类加载器

![1633333943153](.\images\1633333943153.png)

### 4. ClassLoader源码分析

![1633334771393](.\images\1633334771393.png)

![1633335810798](.\images\1633335810798.png)

### 5. 双亲委派模型

![1633335929390](.\images\1633335929390.png)

![1633336073840](.\images\1633336073840.png)

![1633336509086](.\images\1633336509086.png)

**破坏双亲委派机制：**

![1633336805518](.\images\1633336805518.png)

![1633336935264](.\images\1633336935264.png)

![1633337214273](.\images\1633337214273.png)

**热替换的实现：**

![1633337766822](.\images\1633337766822.png)

![1633337777813](.\images\1633337777813.png)

### 6. 沙箱安全机制

![1633512258029](.\images\1633512258029.png)

### 7. 自定义类的加载器

![1633512514479](.\images\1633512514479.png)

![1633512741825](.\images\1633512741825.png)

![1633512925037](.\images\1633512925037.png)

### 8. Java9新特性

![1633513769463](.\images\1633513769463.png)

![1633514040867](.\images\1633514040867.png)

# JVM下篇

## 01. 概述篇

### 1. 大厂面试题

### 2. 背景说明

![1633514691973](.\images\1633514691973.png)

### 3. 调优概述

![1633580648108](.\images\1633580648108.png)

### 4. 性能优化的步骤

![1633580716069](.\images\1633580716069.png)

![1633580868898](.\images\1633580868898.png)

![1633580919015](.\images\1633580919015.png)

![1633581011737](.\images\1633581011737.png)

### 5. 性能评价/测试指标

![1633581181553](.\images\1633581181553.png)

![1633581248317](.\images\1633581248317.png)

## 02. JVM监控及诊断工具-命令行篇

[CSDN-JVM监控及诊断工具（一）](https://blog.csdn.net/m0_45031497/article/details/114859568)

### 1. 概述

![1633582018533](.\images\1633582018533.png)

## 03. JVM监控及诊断工具-GUI篇

[CSDN-JVM监控及诊断工具-GUI篇](https://blog.csdn.net/qq_42185762/article/details/115324300?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242)

[CSDN-jvisualvm安装插件](https://blog.csdn.net/shuai825644975/article/details/78970371)

 

### 04. JVM运行时参数

[CSDN-JVM运行时参数](https://blog.csdn.net/qq_42185762/article/details/115548574?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163368196116780274143332%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163368196116780274143332&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-115548574.first_rank_v2_pc_rank_v29&utm_term=jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0&spm=1018.2226.3001.4187)