# 面试学习笔记



## JavaGuide-Java基础

### 字节码的好处？

**第一阶段：前端编译（源码到字节码）** Java 源代码（`.java` 文件）首先通过 `javac` 编译器进行编译。这个过程属于编译原理中的**前端编译**，主要包括词法分析、语法分析和语义分析等步骤。其输出结果是 **Java 字节码**（`.class` 文件）。字节码是一种与平台无关的**中间表示**（Intermediate Representation, IR），它使得 Java 程序具备了“一次编写，到处运行”的可移植性。

**第二阶段：运行时执行（字节码到机器码）** JVM 加载字节码文件后，进入执行阶段。这个阶段并非纯粹的解释或编译，而是两者的结合：

1. **解释执行**：JVM 的解释器会逐行读取字节码并解释执行。这种方式启动快，但持续执行的效率相对较低。
2. **即时编译（JIT）**：为了提升性能，JVM 在运行时会收集程序的执行信息（如方法调用次数、循环次数等）。当检测到某些代码（称为“热点代码”）被频繁执行时，JVM 内置的 **JIT（Just-In-Time）编译器**（属于**后端编译**）就会介入，将这些热点代码的字节码直接编译成本地机器码。编译后的机器码会被缓存起来，后续执行时便可以直接调用，从而获得接近原生代码的执行效率。

### IR是什么？

当然可以，以下是您提供内容的规整与清晰表述：

#### **Java 字节码作为中间表示（IR）**

当使用 `javac` 编译 Java 源代码（`.java` 文件）时，编译器会将其转换为一种平台无关的低级指令形式——**Java 字节码**（存储在 `.class` 文件中）。这种字节码是 Java 平台的核心 **中间表示**（Intermediate Representation, IR）。

- **平台无关性**：字节码不依赖于特定的硬件架构或操作系统，而是一种抽象的、标准化的指令集。
- **JVM 执行机制**：Java 虚拟机（JVM）负责加载并执行这些字节码。执行方式主要有两种：
  - **解释执行**：由解释器逐条读取并执行字节码指令。
  - **即时编译（JIT）**：将频繁执行的“热点代码”动态编译为本地机器码，以提升运行性能。
- **关键作用**：Java 字节码作为从源代码到最终执行之间的桥梁，既保留了程序的可移植性，又为运行时优化提供了基础。因此，**Java 字节码是 Java 语言在编译与执行流程中的关键中间表示（IR）**。

#### **其他工具中的自定义中间表示（IR）**

除了 JVM 直接使用的字节码外，一些高级的 Java 开发工具和分析框架为了实现更复杂的程序分析、优化或转换，往往会将 Java 字节码进一步转换为**自定义的中间表示（IR）**。

这些自定义 IR 通常具备更丰富的结构信息，便于进行深度分析和操作，例如：

- **控制流图**（Control Flow Graph, CFG）
- **数据流分析**（Data Flow Analysis）
- **调用图**（Call Graph）
- **表达式树或三地址码**等抽象形式

**典型应用示例**：

- **ASM**、**Javassist**：字节码操作库，在内存中解析 `.class` 文件后，可能构建内部结构化表示，用于动态生成或修改类。
- **Soot**：一个广泛使用的 Java 程序分析框架，它将 Java 字节码转换为多种 IR 形式（如 Baf、Jimple、Shimple），其中 Jimple 是一种简化后的三地址码表示，极大简化了静态分析的复杂度。
- **ProGuard / R8**：代码混淆与优化工具，利用自定义 IR 进行无用代码检测、内联、常量传播等优化。
- **IDE 静态分析插件**（如 IntelliJ、Eclipse）：在后台构建程序模型以支持代码检查、重构和智能提示。

### 什么是程序分析、优化、混淆、静态检查？

1. **程序分析 (Program Analysis)**
   - **定义**：程序分析是指系统地检查和理解程序的结构、行为、属性和潜在问题的过程。其目的是获取关于程序的深层信息，而不一定执行它（静态分析）或在执行时观察它（动态分析）。
   - 在 Java 中的应用：
     - **控制流分析 (Control Flow Analysis)**：构建程序的控制流图 (CFG)，展示代码块如何通过分支（if/else）、循环（for/while）和函数调用相互连接。这对于理解程序执行路径至关重要。
     - **数据流分析 (Data Flow Analysis)**：追踪程序中数据（变量）的定义、使用和传播。例如，分析一个变量在哪些地方被赋值，在哪些地方被读取，或者判断一个变量是否可能为 `null`。
     - **指针分析 / 别名分析 (Pointer/Alias Analysis)**：确定程序中的引用（指针）可能指向哪些对象，以及哪些不同的引用可能指向同一个对象（别名）。这在理解对象生命周期和并发问题时非常重要。
     - **调用图分析 (Call Graph Analysis)**：构建一个图，显示程序中哪些方法调用了哪些其他方法。这对于理解程序的整体结构、进行优化和检测死代码很有用。
     - **依赖分析**：分析类、方法、包之间的依赖关系。
   - **为什么需要 IR**：直接分析字节码指令序列比较复杂。自定义的 IR（如更高级的三地址码、SSA 形式）可以更清晰地表示控制流和数据流，使得分析算法（如数据流分析中的定值-引用链计算）更容易实现和优化。
2. **优化 (Optimization)**
   - **定义**：优化是指在不改变程序外部行为（语义）的前提下，修改程序以提高其性能（如运行速度、内存占用）或减小其体积（如代码大小）的过程。
   - 在 Java 中的应用：
     - **JIT 编译器优化**：JVM 的即时编译器（如 HotSpot 的 C1/C2）会将频繁执行的字节码编译成本地机器码，并在此过程中应用大量优化，如方法内联（Inlining）、循环展开（Loop Unrolling）、公共子表达式消除（CSE）、死代码消除（Dead Code Elimination）、逃逸分析（Escape Analysis）等。
     - **AOT 编译器优化**：像 GraalVM Native Image 这样的工具将 Java 程序提前编译（Ahead-of-Time）为本地可执行文件，会进行更激进的优化和链接。
     - **字节码优化工具**：一些工具专门用于优化 `.class` 文件，例如 ProGuard（也包含混淆功能）可以进行类/字段/方法名的缩短、无用代码/资源的移除、代码结构的简化等。
   - **为什么需要 IR**：优化通常需要复杂的分析（如上面提到的数据流、控制流分析）。一个设计良好的 IR 能够清晰地暴露程序的结构和数据依赖关系，使得优化算法（如识别可内联的方法、判断循环不变量）能够更有效地应用。优化后的 IR 再被转换回目标格式（字节码或机器码）。
3. **混淆 (Obfuscation)**
   - **定义**：混淆是指有意地修改程序的代码或结构，使其对人类（尤其是逆向工程师）来说变得难以阅读、理解和分析，但同时保持其原有的功能和行为。主要目的是保护知识产权和防止恶意篡改。
   - 在 Java 中的应用：
     - **名称混淆 (Name Obfuscation)**：将具有描述性意义的类名、方法名、字段名替换为无意义的短字符串（如 `a`, `b`, `c`）或 Unicode 难以阅读的字符。这是最常见和最基础的混淆。
     - **流混淆 (Flow Obfuscation)**：修改程序的控制流，例如插入无用的条件分支、循环或 try-catch 块，或者打乱代码执行顺序（在不改变逻辑的前提下），使控制流图变得复杂难懂。
     - **字符串加密 (String Encryption)**：将代码中的字符串常量加密存储，在运行时才解密使用，防止通过字符串搜索轻易找到关键逻辑。
     - **类/包结构混淆**：改变类的继承关系或包结构（在不破坏功能的情况下），增加理解难度。
   - **为什么需要 IR**：要进行有效的混淆（尤其是流混淆和高级混淆），工具需要深入理解程序的逻辑结构和数据依赖。自定义 IR 提供了一个抽象层，允许混淆器安全地插入无用代码、重排指令或修改控制流，同时利用分析确保不会破坏程序的正确性。直接在字节码层面操作风险更高。
4. **静态检查 (Static Checking)**
   - **定义**：静态检查是一种在程序**不实际运行**的情况下，通过分析其源代码或字节码来发现潜在错误、代码缺陷、安全漏洞、风格问题或违反编码规范的软件质量保证技术。
   - 在 Java 中的应用：
     - **编译器警告**：`javac` 本身会进行基本的静态检查，如未使用的变量、不可达代码、类型不匹配等。
     - **Lint 工具**：如 **Checkstyle** (检查代码风格和规范), **PMD** (检测常见编程缺陷、未使用代码、复杂度过高等), **SpotBugs** (前身是 FindBugs，利用字节码分析检测空指针解引用、资源泄漏、并发问题等潜在 bug)。
     - **安全扫描工具**：如 **SonarQube/SonarLint** (集成多种检查，包括安全漏洞、代码异味、重复代码等), **Fortify**, **Checkmarx** (专门用于发现安全漏洞，如 SQL 注入、XSS、不安全的反序列化等)。
     - **Null 安全分析**：一些工具或语言特性（如 Kotlin 的非空类型，或 Java 的 `@Nullable`/`@NonNull` 注解配合分析工具）可以静态地推断变量是否可能为 null，从而预防 `NullPointerException`。

### 什么是热点代码？

Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。

当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。

### 静态编译与动态编译

您对 JVM、JIT、AOT 以及 GraalVM 的理解非常准确和深入。确实，JIT 和 AOT 代表了两种不同的编译策略，各有其适用场景和权衡。下面我将您提到的关键点，用表格的形式进行清晰的总结和对比：

#### **JIT 与 AOT 编译对比表**

| 对比维度              | **JIT (Just-In-Time Compilation)**                           | **AOT (Ahead-Of-Time Compilation)**                          | **详细说明**                                                 |
| :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **编译时机**          | **运行时编译**在程序执行过程中，由 JVM 的 JIT 编译器动态编译。 | **提前编译**在程序运行**之前**，将 Java 字节码直接编译成本地机器码。 | JIT 是 Java “一次编写，到处运行” 的核心，字节码在运行时被优化；AOT 则在构建时就完成编译，生成独立的可执行文件。 |
| **代表技术/工具**     | HotSpot JVM (Oracle JDK, OpenJDK 默认)                       | **GraalVM Native Image** (基于 GraalVM)                      | GraalVM 是一个高性能的 JDK 发行版，它既包含强大的 JIT 编译器（作为 HotSpot 的替代或增强），也提供 `native-image` 工具来实现 AOT 编译。 |
| **启动时间**          | ❌ **较慢**需要加载 JVM、解释执行字节码、等待 JIT 预热。      | ✅ **极快**直接运行本地可执行文件，无需 JVM 启动和 JIT 预热。 | AOT 的最大优势之一，尤其适合 Serverless、微服务等需要快速冷启动的场景。 |
| **内存占用**          | ❌ **较高**JVM 本身占用内存，加上 JIT 编译、GC 等开销。       | ✅ **显著降低**没有 JVM 开销，本地镜像内存占用更小。          | AOT 生成的原生镜像内存 Footprint 更小，可以更高效地利用资源。 |
| **打包体积**          | ❌ **较大**包含整个 JVM 和所有依赖的 JAR 包。                 | ✅ **更小**（相对）只包含应用和其**实际使用到**的代码和库。   | GraalVM Native Image 会进行**静态代码分析**（Tree Shaking），移除未使用的代码，从而减小体积。但生成的可执行文件可能仍比单个 JAR 大，因为它包含了必要的运行时组件。 |
| **运行时性能 (峰值)** | ✅ **更高**JIT 可以进行**深度运行时优化**（如基于热点代码、类型推断）。 | ❌ **相对较低**优化在编译时完成，无法根据运行时数据进行动态调整。 | JIT 的优势在于“越用越快”。它能根据程序的实际执行路径（Profile-Guided Optimization）生成高度优化的机器码，理论上能达到接近 C/C++ 的性能。AOT 的优化是静态的，缺乏这种动态适应能力。 |
| **运行时性能 (延迟)** | ❌ **存在波动**请求延迟可能因 JIT 预热、GC 而出现“毛刺”（Jitter）。 | ✅ **更稳定**启动后性能立即稳定，延迟可预测。                 | AOT 避免了 JIT 预热期的性能不稳定，对于需要低且稳定延迟的场景（如高频交易）有优势。 |
| **支持的动态特性**    | ✅ **完全支持**反射、动态代理、动态类加载、JNI 等。           | ❌ **受限或不支持**必须在编译时确定，需要**显式配置**或**框架适配**。 | **这是 AOT 的核心挑战！** - **反射**：必须在 `reflect-config.json` 中预先声明。 - **动态代理 (CGLIB, JDK Proxy)**：框架（如 Spring AOT）需在构建时生成代理类。 - **JNI**：需要特殊处理。 - **资源加载**：必须在 `resource-config.json` 中声明。 |
| **对框架的影响**      | ✅ **兼容性好**Spring, Hibernate 等主流框架开箱即用。         | ⚠️ **需要适配**框架必须提供 AOT 支持（如 Spring Boot 3+ 的 AOT 模式）。 | 如您所言，CGLIB 使用 ASM 在运行时生成字节码，这在 AOT 中无法进行。因此，Spring Framework 6 / Spring Boot 3 引入了 **AOT Engine**，在构建时通过 **源码生成 (Source Generation)** 或 **提前处理** 的方式，模拟或替代这些运行时动态行为。 |
| **适用场景**          | - 传统单体应用- 长时间运行、追求极致吞吐量的服务- 使用大量动态特性的应用 | - **云原生应用** (Serverless, FaaS)- **微服务** (快速启动、低内存)- CLI 工具- 嵌入式场景 | **云原生趋势下，AOT 优势凸显**。虽然 JIT 在峰值性能上有理论优势，但 AOT 在启动、内存、稳定性方面的优势更符合现代弹性、按需伸缩的架构需求。GraalVM Native Image 正是为这些场景而生。 |
| **总结**              | **“运行时优化，性能潜力大”**                                 | **“启动快，资源省，适合云”**                                 | 两者并非完全替代关系。**GraalVM 的强大之处在于它同时提供了顶尖的 JIT 和 AOT 能力**。开发者可以根据应用的具体需求（是追求极限性能还是极致启动速度）来选择合适的编译模式。 |

1.  **GraalVM 是桥梁**：它让 Java 应用既能享受 JIT 的高性能潜力，又能通过 Native Image 获得 AOT 的云原生优势。
2.  **AOT 的代价是动态性**：放弃或限制 Java 的动态特性是使用 AOT 必须付出的代价。这推动了框架（如 Spring）向**构建时优化**和**源码生成**的方向演进。
3.  **场景驱动选择**：没有绝对的好坏。对于需要快速冷启动和低内存的微服务，**AOT (GraalVM Native Image) 是优选**；对于长时间运行、计算密集型且依赖复杂动态特性的应用，**JIT (HotSpot 或 GraalVM JIT) 仍是主力**。

### 移位运算符

| 应用领域                    | 具体用途与示例                                               | 使用的移位运算符       | 核心原理与优势                                               |
| :-------------------------- | :----------------------------------------------------------- | :--------------------- | :----------------------------------------------------------- |
| **算术优化**                | **快速乘以/除以 2 的幂次方**例如：`x << 3` 等价于 `x * 8` (2³)`x >> 2` 等价于 `x / 4` (2²，对正数) （算术右移） | `<<` (左移)`>>` (右移) | **性能极高**：CPU 的移位指令通常比乘除法指令快得多。是底层性能优化的经典技巧。 |
| **位字段 (Bit Field) 管理** | **高效存储多个布尔标志或小范围整数**例如：用一个 `int` (32位) 存储 32 个开关状态。```java// 设置第 5 位 (bit 5)flags |= (1 << 5);// 清除第 3 位 (bit 3)flags &= ~(1 << 3);// 检查第 7 位是否设置boolean isSet = (flags & (1 << 7)) != 0;// 从 flags 中提取 4-7 位表示的值int value = (flags >> 4) & 0xF; // 0xF = 1111₂``` | `<<` `>>` `&` `\|` `~` | **空间效率极高**：将多个独立的小数据打包到一个整数中，节省内存。常用于协议解析、状态寄存器、权限控制等。 |
| **哈希算法与加密**          | **数据混淆、扩散和生成哈希值**例如：在简单的哈希函数或加密轮函数中：```javaint hash = seed;hash ^= (key & 0xFF);hash = (hash << 5) + (hash >> 27); // 混合高低位```MD5, SHA 等算法内部大量使用移位和循环移位。 | `<<` `>>`              | **混淆与扩散**：移位能快速打乱数据的位模式，使得输入的微小变化导致输出的巨大差异（雪崩效应），这是密码学和哈希函数安全性的基础。 |
| **数据压缩**                | **高效处理二进制码流**例如：在实现霍夫曼编码、LZW 等算法时：- 将变长的霍夫曼码**拼接**到一个 `int` 或 `long` 的缓冲区中：`buffer |= (huffmanCode << bitPosition)`。- 从缓冲区中**提取**固定位数的数据：`(buffer >> (totalBits - neededBits)) & mask`。 | `<<` `>>` `&`          | **位级操作**：压缩算法通常处理的是位流而非字节流。移位运算符是操作和重组这些位流的最基本、最高效的工具，避免了繁琐的字节处理。 |
| **数据校验 (CRC)**          | **生成和校验循环冗余码**CRC 算法的核心是**模拟多项式除法**，其步骤包括：1.  将数据视为一个长二进制数。2.  与一个预定义的生成多项式进行异或和**移位**操作。移位是实现“除法”步骤的关键。 | `<<` `>>` `^` (异或)   | **硬件友好**：CRC 的移位-异或操作非常适合作为硬件电路实现，也易于用软件高效模拟。移位用于推进计算过程，异或用于执行模 2 减法。是网络通信、存储系统中保证数据完整性的标准方法。 |
| **内存对齐**                | **计算对齐的地址或大小**例如：将大小 `size` 向上对齐到 8 字节边界（假设 8=2³）：```javaint alignedSize = (size + 7) & ~7; // 经典方法// 或者使用移位 (当对齐边界是 2 的幂时)int alignment = 8; // 必须是 2 的幂int shift = 3; // log₂(8)int alignedSize = ((size - 1) >> shift << shift) + alignment; // 较少见，但可行``` | `>>` `<<` `&` `~`      | **高效计算**：当对齐边界是 2 的幂时，利用移位和位掩码 (`& ~mask`) 可以非常快速地完成对齐计算，比使用模运算 (`%`) 更高效。第一个 `& ~7` 的方法更常用。 |

*   **核心优势**：移位运算符操作的是**二进制位**，直接对应 CPU 的底层指令，因此具有**极高的执行效率**。
*   **主要类型**：
    *   `<<` (左移)：高位丢弃，低位补 0。等效于 * 2^n。
    *   `>>` (算术右移)：符号位不变，高位补符号位（正数补0，负数补1）。等效于 / 2^n (向下取整)。
    *   `>>>` (逻辑右移)：高位补 0，忽略符号。常用于处理无符号数或提取位。
*   **适用场景**：主要在**性能敏感**、**内存敏感**或需要**直接操作二进制数据**的领域（如底层系统编程、算法实现、网络协议、密码学、嵌入式开发）中发挥重要作用。
*   **注意事项**：使用时需注意数据类型（int vs long）、符号位的影响（`>>` vs `>>>`）以及移位位数的范围（通常对 32 或 64 取模）。

### J2EE和Spring技术对比

| 技术/功能              | Java EE (Jakarta EE) 方式                                    | Spring (Spring Boot) 方式                                    | 对比说明                                                     |
| :--------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Web 层 (MVC)**       | **Servlet & JSP**：- Servlet 处理请求/响应。- JSP 生成动态视图。- 通常结合 JSTL、自定义标签使用。 | **Spring MVC**：- 基于注解（`@Controller`, `@RequestMapping`）的控制器。- 支持 Thymeleaf、Freemarker、JSP 等多种视图技术。- 更强的类型安全和灵活性。 | ✅ **Spring 更灵活现代**：Spring MVC 提供了更简洁的注解驱动开发，解耦更好，测试更容易。JSP 在 Spring 中虽可用，但官方推荐 Thymeleaf 等模板引擎。 |
| **业务逻辑层**         | **EJB (Enterprise JavaBean)**：- 有状态/无状态 Session Bean。- MDB（消息驱动 Bean）。- 容器提供事务、安全、并发等服务。 | **Spring Bean + Service**：- 使用 `@Service`, `@Component` 等注解定义业务组件。- 通过 Spring 容器管理生命周期和依赖。 | ✅ **Spring 更轻量灵活**：EJB 配置复杂，依赖容器；Spring Bean 更简单，无需特定容器，POJO 编程，更易测试和迁移。EJB 功能在 Spring 中都能更好实现。 |
| **数据库连接**         | **JDBC**：- 原生 `java.sql` API，需手动管理连接、异常、资源释放。 | **Spring JDBC (JdbcTemplate)**：- 封装了 JDBC 模板，简化了 CRUD 操作。- 自动处理资源关闭和异常转换（转为 Spring 的 `DataAccessException`）。 | ✅ **Spring 极大简化 JDBC**：Spring 的 `JdbcTemplate` 减少了大量样板代码，提高了开发效率和安全性。 |
| **对象关系映射 (ORM)** | **JPA (Java Persistence API)**：- 标准 ORM 规范（如 Hibernate、EclipseLink 实现）。- 使用 `EntityManager`。 | **Spring Data JPA**：- 基于 JPA，提供更高级的抽象（如 `JpaRepository`）。- 方法名自动推导查询（`findByUsername`）。- 分页、排序内置支持。 | ✅ **Spring Data JPA 更高效**：两者底层都用 JPA，但 Spring Data JPA 极大减少了 DAO 层代码量，开发速度更快，是目前主流选择。 |
| **事务管理**           | **JTA (Java Transaction API)**：- 分布式事务标准。- EJB 和 JPA 可集成 JTA。- 需要支持 JTA 的应用服务器（如 WildFly, WebLogic）。 | **Spring Transaction**：- 支持本地事务（JDBC）和 JTA。- `@Transactional` 注解驱动。- 可集成 Atomikos、Bitronix 实现分布式事务。 | ✅ **Spring 更灵活通用**：Spring 事务管理不依赖完整 Java EE 服务器，可在 Tomcat 等轻量容器中使用，配置更简单，支持更广。 |
| **邮件发送**           | **JavaMail (Java EE API)**：- 标准 API，需配置 `MailSession` 等。 | **Spring Mail**：- 封装 JavaMail，提供 `JavaMailSender` 接口和 `SimpleMailMessage`。- 配置更简单（`spring.mail.*`）。- 易于测试。 | ✅ **Spring 更易用**：Spring 对 JavaMail 进行了优秀封装，配置和使用都更简洁，是实际项目中的首选。 |
| **消息队列**           | **JMS (Java Message Service)**：- 标准 API，支持点对点和发布/订阅。- 需 JMS 提供者（如 ActiveMQ）。 | **Spring JMS / Spring Messaging / Spring AMQP**：- 封装 JMS，提供 `JmsTemplate` 和 `@JmsListener`。- 支持 RabbitMQ (AMQP)、Kafka 等更多消息中间件。 | ✅ **Spring 生态更广**：Spring 不仅支持 JMS，还扩展支持 AMQP、Kafka 等现代消息系统，抽象层次更高，集成更方便。 |
| **整体架构**           | **Java EE 容器驱动**：- 需要完整的应用服务器（如 WildFly, GlassFish, WebLogic）。- 遵循规范，标准化强。 | **Spring Boot + 内嵌容器**：- 使用 Tomcat/Jetty/Undertow 内嵌服务器。- “约定优于配置”，自动装配。- 微服务友好（Spring Cloud）。 | ✅ **Spring Boot 更现代高效**：开发、部署、运维更简单，启动快，适合云原生和微服务架构。Java EE 更适合传统大型企业系统。 |
| **依赖管理**           | 依赖 Java EE 容器提供 API 实现。                             | 使用 Maven/Gradle 精确管理依赖版本，可自由选择组件组合（如只用 Spring MVC + MyBatis）。 | ✅ **Spring 更自由可控**：Spring 不强制依赖完整平台，可按需引入，避免“重量级”问题。 |

| 维度         | Java EE (Jakarta EE)                   | Spring (Spring Boot)                                       |
| :----------- | :------------------------------------- | :--------------------------------------------------------- |
| **定位**     | **标准化平台规范**                     | **全面的应用框架**                                         |
| **开发效率** | 相对较低（配置多，样板代码多）         | **极高**（自动配置，注解驱动，模板封装）                   |
| **学习曲线** | 较陡（EJB、JTA 等概念复杂）            | 相对平缓（尤其是 Spring Boot）                             |
| **部署**     | 需完整应用服务器（较重）               | 可独立运行（JAR + 内嵌容器），轻量快速                     |
| **生态**     | 标准化，厂商兼容性好                   | **极其丰富**，社区活跃，第三方集成多（如 Cloud, Security） |
| **适用场景** | 传统大型企业系统，需严格遵循标准的项目 | **现代 Web 应用、微服务、云原生应用**（主流选择）          |

> 💡 **结论**：虽然 Java EE 定义了重要的企业级标准（如 JPA, JTA, JMS），但 **Spring 框架（尤其是 Spring Boot）** 通过提供更简洁、灵活、高效的实现方式，已经成为当前企业 Java 开发的**绝对主流**。Spring 并非取代这些技术，而是更好地**集成、封装和简化**了它们的使用。

### 不要在finaly语句块中使用return

**不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。

### 注解的本质

`Annotation` （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。

注解本质是一个继承了`Annotation` 的特殊接口

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {

}

public interface Override extends Annotation{

}
```

### 注解的解析方法有哪几种

注解只有被解析之后才会生效，常见的解析方法有两种：

- **编译期直接扫描**：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过反射来进行处理的

 ### java中没有引用传递

c++中的引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？

**注意：以下为个人观点看法，并非来自于 Java 官方：**

1. 出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。
2. Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。

### 序列化

序列化是分布式系统中不同服务间数据交换的重要环节。在讨论OpenFeign和Dubbo这两种不同的远程调用框架时，它们各自支持的序列化方法有所不同。

#### OpenFeign

OpenFeign 是一个声明式的Web服务客户端，使得编写Web服务客户端变得更加简单。它本身主要关注于HTTP层面的服务调用，并不直接提供序列化机制，而是依赖于所使用的HTTP消息转换器（如Spring中的`HttpMessageConverter`）来实现请求和响应体的序列化与反序列化工作。默认情况下，如果是在Spring环境中使用OpenFeign，它通常会支持以下几种序列化方式：

- **JSON**：通过Jackson或Gson等库进行序列化/反序列化。
- **XML**：如果有相应的消息转换器配置的话，也可以支持XML格式的数据交换。

因此，在OpenFeign中，序列化的选择很大程度上取决于你使用的具体框架以及如何配置消息转换器。



#### Dubbo

Dubbo 是阿里巴巴开源的一个高性能服务框架，致力于提供高效、可靠的RPC（远程过程调用）服务。Dubbo 对序列化提供了更直接的支持，允许用户配置不同的序列化方式。Dubbo 默认支持多种序列化方式，包括但不限于：

- **Hessian2**：这是Dubbo默认的序列化方式，具有较好的性能和跨语言支持。
- **Java序列化**：使用Java自带的序列化机制，适用于纯Java环境下的应用。
- **Kryo**：一种高效的Java序列化库，相较于Java原生序列化有显著的性能提升。
- **FST**：Fast-serialization (FST) 是另一个快速且功能强大的Java序列化库。
- **Protobuf**：Google提供的语言中立、平台中立、可扩展的序列化结构数据格式，非常适合用于数据交换。
- **Avro**：Apache Avro是一种数据序列化系统，设计用于支持超大数据集的长期存储和服务间的通信。

Dubbo允许用户根据自己的需求灵活地选择合适的序列化策略，并在配置文件中指定。

#### 总结

- 在**OpenFeign**中，序列化更多地依赖于底层的HTTP消息转换器，常见的选择为JSON和XML，但主要是由集成的框架（如Spring）决定的。
- **Dubbo**则提供了对多种序列化方式的内置支持，允许用户根据性能、兼容性等要求选择最适合项目的序列化方案，比如Hessian2、Kryo、Protobuf等。这意味着在Dubbo项目中调整序列化策略可能会更加直观和方便。

### HttpMessageConverter

`HttpMessageConverter` 是 Spring 框架（特别是 Spring Web MVC 和 Spring WebFlux）中的一个核心接口，它在处理 HTTP 请求和响应时扮演着至关重要的角色。

简单来说，**`HttpMessageConverter` 的作用是在 HTTP 请求/响应的原始字节流（通常是字符串或字节数组）和 Java 对象之间进行相互转换**。

#### 为什么需要它？

1.  **客户端发送请求**：当你通过 HTTP POST 或 PUT 请求发送数据（例如，一个 JSON 字符串 `{"name": "Alice", "age": 30}`）到服务器时，Spring 需要一种机制将这个原始的 JSON 文本解析（反序列化）成一个对应的 Java 对象（如 `User user`）。
2.  **服务器返回响应**：当你的控制器方法返回一个 Java 对象（如 `return new User("Bob", 25);`）时，Spring 需要一种机制将这个 Java 对象转换（序列化）成客户端可以理解的格式（如 JSON 字符串 `{"name": "Bob", "age": 25}`），并将其写入 HTTP 响应体中。

`HttpMessageConverter` 就是完成这些转换工作的“翻译官”。

#### 核心功能

`HttpMessageConverter` 接口定义了四个主要方法：

1.  **`boolean canRead(Class<?> clazz, MediaType mediaType)`**:
    *   **作用**：判断这个转换器是否能将指定的 HTTP 内容类型（`MediaType`，如 `application/json`）的请求体读取并转换为指定的 Java 类型（`clazz`）。
    *   **场景**：用于处理 `@RequestBody` 注解。

2.  **`boolean canWrite(Class<?> clazz, MediaType mediaType)`**:
    *   **作用**：判断这个转换器是否能将指定的 Java 对象（`clazz` 的实例）写入 HTTP 响应体，并转换为指定的内容类型（`MediaType`）。
    *   **场景**：用于处理 `@ResponseBody` 注解或 `@RestController`。

3.  **`T read(Class<? extends T> clazz, HttpInputMessage inputMessage)`**:
    *   **作用**：从 `HttpInputMessage`（包含请求头和请求体输入流）中读取数据，并将其反序列化为指定类型的 Java 对象 `T`。
    *   **场景**：实现 `@RequestBody` 的功能。

4.  **`void write(T t, MediaType contentType, HttpOutputMessage outputMessage)`**:
    *   **作用**：将 Java 对象 `T` 序列化，并将其写入 `HttpOutputMessage`（包含响应头和响应体输出流），同时设置响应的内容类型。
    *   **场景**：实现 `@ResponseBody` 的功能。

#### 常见的 `HttpMessageConverter` 实现类

Spring MVC 默认注册了多个 `HttpMessageConverter` 的实现，以支持不同的数据格式：

*   **`MappingJackson2HttpMessageConverter`**:
    *   **功能**：使用 Jackson 库将 Java 对象与 **JSON** 格式相互转换。这是最常用的转换器。
    *   **处理的 MediaType**: `application/json`, `text/json` 等。

*   **`Jaxb2RootElementHttpMessageConverter`**:
    *   **功能**：使用 JAXB (Java Architecture for XML Binding) 将 Java 对象与 **XML** 格式相互转换。
    *   **处理的 MediaType**: `application/xml`, `text/xml` 等。

*   **`StringHttpMessageConverter`**:
    *   **功能**：处理 `String` 类型。能将请求体直接转换为 `String`，或将 `String` 写入响应体。
    *   **处理的 MediaType**: `text/plain` 等。

*   **`ByteArrayHttpMessageConverter`**:
    *   **功能**：处理 `byte[]` 类型。能将请求体转换为字节数组，或将字节数组写入响应体。
    *   **处理的 MediaType**: `application/octet-stream` 等。

*   **`FormHttpMessageConverter` / `SourceHttpMessageConverter`**:
    *   **功能**：分别处理表单数据和 XML Source 对象。

*   **`BufferedImageHttpMessageConverter`**:
    *   **功能**：处理图片（`BufferedImage`）的读写。

#### 工作流程

1.  当一个 HTTP 请求到达时，Spring MVC 的 `DispatcherServlet` 会根据请求的 `Content-Type` 头（对于请求体）和 `Accept` 头（对于期望的响应类型）来查找合适的 `HttpMessageConverter`。
2.  它会遍历所有注册的 `HttpMessageConverter`，调用它们的 `canRead()` 或 `canWrite()` 方法，找到第一个能够处理当前请求/响应类型和目标 Java 类型的转换器。
3.  找到后，调用该转换器的 `read()` 或 `write()` 方法完成实际的转换工作。

#### 总结

`HttpMessageConverter` 是 Spring Web 框架中实现**内容协商 (Content Negotiation)** 的关键组件。它使得开发者可以轻松地在控制器中使用 Java 对象，而无需关心底层的 HTTP 消息是如何将这些对象序列化为 JSON/XML 字符串或从字符串反序列化回来的。开发者通常只需要确保项目中包含了正确的依赖（如 Jackson 用于 JSON），Spring Boot 会自动配置好相应的转换器。

### 软件设计准则

面向对象编程来说，下面这些原则都是我们应该非常熟练的。

1. 面向对象编程的思想（继承、封装、多态、抽象）

2. 面向对象的七大设计原则：单一职责原则（Single Responsibility Principle, SRP）

- 开闭原则（Open Closed Principle，OCP）

  - ✅ **好例子**：`UserRepository` 只负责用户数据的存取，`UserService` 负责业务逻辑。
  - ❌ **坏例子**：一个类既处理数据库操作，又发邮件，又做日志记录。

  > **意义**：降低类的复杂度，提高可维护性和可测试性。

- 里氏代换原则（Liskov Substitution Principle，LSP）

  - ✅ **实现方式**：通过抽象（接口/抽象类） + 多态实现扩展。
  - ❌ 修改已有代码来增加功能是违背 OCP 的。

  > **例子**：支付系统支持新支付方式（如支付宝），应通过新增类实现，而不是修改原有 `PayService`。

- 接口隔离原则（Interface Segregation Principle，ISP）

  - 不要让客户端依赖它不需要的方法。
  - 提倡“细粒度接口”，避免“胖接口”。

  > **例子**：不要让一个 `Printer` 接口包含 `print()`, `scan()`, `fax()`，而应拆分为 `Printable`, `Scannable`, `Faxable`。

- 依赖反转原则（Dependency Inversion Principle，DIP）

  - 高层模块不依赖低层模块，两者都依赖抽象。
  - 抽象不依赖细节，细节依赖抽象。

  > **实现方式**：依赖注入（DI）、控制反转（IoC）容器（如 Spring）。

  ```
  // 好：依赖接口
  public class OrderService {
      private PaymentGateway gateway; // 接口
      public OrderService(PaymentGateway gateway) {
          this.gateway = gateway;
      }
  }
  ```

- 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）

  - 当要复用功能时，优先使用组合（has-a）而不是继承（is-a）。
  - 继承破坏封装，组合更灵活。

  > **例子**：`Car` 包含 `Engine` 对象，而不是继承 `Engine`。

- 迪米特法则（Principle of Least Knowledge，PLK，也叫最小知识原则）

  - 一个对象应对其他对象保持最少了解。
  - 只与直接“朋友”通信（如：自己、参数、成员、创建的对象）。

  > **例子**：避免 `a.getB().getC().doSomething()`，应通过 `a.doSomething()` 封装。

3. 软件设计的三大原则

- DRY（Don’t Repeat Yourself）原则：不要重复你自己

- KISS（ Keep It Simple/Stupid）原则：保持简单易懂

- YAGNI （ You Ain’t Gonna Need It）原则 ：不要进行过度设计

### Enum的本质

| 特性                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| ✅ **是一个类**                | 编译后生成 `.class` 文件，是一个完整的类。                   |
| ✅ **继承自 `java.lang.Enum`** | 所有枚举都隐式继承 `Enum` 类，不能显式继承其他类（Java 不支持多继承）。 |
| ✅ **实例是有限且固定的**      | 实例在类加载时创建，且是 `public static final` 的，不可变。  |
| ✅ **构造器是私有的**          | 防止外部通过 `new` 创建新实例。                              |
| ✅ **天然线程安全**            | 实例在类加载时初始化，JVM 保证其唯一性和线程安全。           |
| ✅ **可实现接口**              | 枚举类可以实现接口（如 `Comparable`, `Serializable`）。      |
| ✅ **可定义方法和字段**        | 枚举可以有自己的属性、方法、甚至抽象方法。                   |

💡 **核心思想**：
 枚举不是“数据”，而是一种**有限状态机（Finite State Machine）** 或 **领域常量类型** 的优雅表达。

### SpringBoot异常处理

`@ControllerAdice`和`@ExceptionHandler`处理Controller级别的异常

```java
import com.twuc.webApp.web.ExceptionController;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import javax.servlet.http.HttpServletRequest;

@ControllerAdvice(assignableTypes = {ExceptionController.class})
@ResponseBody
public class GlobalExceptionHandler {

    // 也可以将 BaseException 换为 RuntimeException
    // 因为 RuntimeException 是 BaseException 的父类
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<?> handleAppException(BaseException ex, HttpServletRequest request) {
        ErrorReponse representation = new ErrorReponse(ex, request.getRequestURI());
        returnnew ResponseEntity<>(representation, new HttpHeaders(), ex.getError().getStatus());
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity<ErrorReponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
        ErrorReponse errorReponse = new ErrorReponse(ex, request.getRequestURI());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorReponse);
    }
}

```

### 优质开源项目学习

https://javaguide.cn/open-source-project/practical-project.html

多手搓轮子！！！

### 面对HR提问

**面对** **HR** **或者其他** **Level** **比较低的面试官时**

1. 能不能谈谈你作为一个公司老员工对公司的感受? (这个问题比较容易回答，不会让面试官陷入无话

可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司

到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上

还可以拉进你与面试官的距离。)

2. 能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你?有

什么地方你觉得还不太好或者可以继续完善吗？ （类似第一个问题，都是问面试官个人对于公司的

看法，）

3. 我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？(这个是我常问的。我觉得说自己表

现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)

4. 接下来我会有一段空档期，有什么值得注意或者建议学习的吗？ （体现出你对工作比较上心，自助

学习意识比较强。）

5. 这个岗位为什么还在招人？ (岗位真实性和价值咨询)
6. 大概什么时候能给我回复呢？ (终面的时候，如果面试官没有说的话，可以问一下)

**面对部门领导**

1.  部门的主要人员分配以及对应的主要工作能简单介绍一下吗？

2. 未来如果我要加入这个团队，你对我的期望是什么？ （部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）

3. 公司对新入职的员工的培养机制是什么样的呢？ （正规的公司一般都有培养机制，提前问一下是对

   你自己的负责也会显的你比较上心）

4. 以您来看，这个岗位未来在公司内部的发展如何？ (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)

5. 团队现在面临的最大挑战是什么？ (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期。)

### 接口幂等性

**什么是幂等呢**? 在分布式系统中，幂等(idempotency)是对请求操作结果的一个描述，这个描述就是不论

执行多少次相同的请求，产生的效果和返回的结果都和发出单个请求是一样的。

🌰 举个例子：假如咱们的前后端没有保证接口幂等性，我作为用户在秒杀商品的时候，我同时点击了

多次秒杀商品按钮，后端处理了多次相同的订单请求，结果导致一个人秒杀了多个商品。这个肯定是不

能出现的，属于非常严重的 bug 了！

保证分布式接口的幂等性对于数据的一致性至关重要，特别是像支付这种涉及到钱的接口。保证幂等性

**这个操作并不是说前端做了就可以的，后端同样要做。**

前端保证幂等性的话比较简单，一般通过当用户提交请求后将按钮致灰来做到。后端保证幂等性就稍微

麻烦一点，方法也是有很多种，比如：

1. 同步锁；

2. 分布式锁；

3. 业务字段的唯一索性约束，防止重复数据产生。

4. ......

拿分布式锁来说，我们通过加锁的方式限制用户在第一次请求未结束之前，无法进行第二次请求。

分布式锁一般基于 Redis 来做比较多一些，这也是我比较推荐的一种方式。另外，如果使用 Redis 来实

现分布式锁的话，比较推荐基于 Redisson。相关阅读：分布式锁中的王者方案 - Redisson 

https://blog.csdn.net/2303_78263863/article/details/147480794

在分布式系统或微服务架构中，确保接口的**幂等性**是非常重要的，尤其是在处理如支付、订单创建等关键业务逻辑时。幂等性指的是同一个操作无论执行多少次，其结果都是相同的。对于 Spring Boot 应用来说，实现接口的幂等性可以通过多种方式来完成，下面介绍几种常见的策略：

#### 使用数据库唯一约束

如果请求涉及对数据库的操作，可以利用数据库的**唯一约束**来保证幂等性。例如，在处理订单创建时，可以为订单号设置唯一约束。当重复提交相同的订单号时，数据库会抛出异常，从而阻止重复记录的插入。

```sql
CREATE UNIQUE INDEX unique_order_number ON orders(order_number);
```

在服务端捕获此异常，并返回相应的错误信息给客户端。

#### 基于Token机制

这是一种常用的方法，特别适合于HTTP请求场景：

- **步骤1**：客户端发起请求前，先从服务器获取一个唯一的token。
- **步骤2**：客户端将此token与请求数据一同发送至服务器。
- **步骤3**：服务器接收到请求后，首先检查该token是否已经被使用过（通常通过数据库或缓存来存储已使用的token）。若未被使用，则执行业务逻辑并标记此token为已使用；否则直接返回之前的结果或错误提示。

Spring Boot 实现示例：

```java
@PostMapping("/process")
public ResponseEntity<?> processRequest(@RequestParam String token, @RequestBody RequestData data) {
    if (!tokenService.isValid(token)) {
        return new ResponseEntity<>("Duplicate request", HttpStatus.BAD_REQUEST);
    }
    // 执行业务逻辑
    tokenService.markAsUsed(token);
    return new ResponseEntity<>(result, HttpStatus.OK);
}
```

#### 利用Redis等缓存技术

Redis 提供了原子性的操作支持，非常适合用于幂等性控制。可以将每个请求的唯一标识符（如UUID）作为key存入Redis，并设置一个较短的有效期。每次请求到达时，检查Redis中是否存在对应的key。如果存在则说明是重复请求，反之则执行业务逻辑并将key存入Redis。

```java
if (Boolean.FALSE.equals(redisTemplate.hasKey(requestId))) {
    redisTemplate.opsForValue().set(requestId, "processed", Duration.ofMinutes(5));
    // 执行业务逻辑
} else {
    throw new RuntimeException("Duplicate request detected");
}
```

#### 幂等锁

在某些情况下，可以使用分布式锁来确保同一时间只有一个线程能够处理特定资源的相关请求。例如，使用 Redisson 或 Zookeeper 实现分布式锁。

#### 总结

选择哪种方法取决于具体的业务需求和应用场景：

- 如果你的操作主要是基于数据库的CRUD，那么使用数据库唯一约束可能就足够了。
- 对于需要跨多个服务协调的情况，基于Token机制或者利用Redis等缓存技术可能是更好的选择。
- 分布式锁适用于更复杂的并发控制场景。

每种方法都有其适用范围和局限性，实际应用中可以根据项目的具体情况进行选择和组合使用。同时，也要注意处理好异常情况，确保系统的健壮性和用户体验。
