# 面试学习笔记

```markmap
---
markmap:
  zoom: false
  pan: false
  height: 300px
  backgroundColor: "#f8f8f8"
---

# 面试学习笔记
## Java基础
### 字节码的好处？
### IR是什么？
#### **Java 字节码作为中间表示（IR）**
#### **其他工具中的自定义中间表示（IR）**
### 什么是程序分析、优化、混淆、静态检查？
### 什么是热点代码？
### 静态编译与动态编译
#### **JIT 与 AOT 编译对比表**
### 移位运算符
### J2EE和Spring技术对比
### 不要在finaly语句块中使用return
### 注解的本质
### 注解的解析方法有哪几种
 ### java中没有引用传递
### 序列化
#### OpenFeign
#### Dubbo
#### 总结
### HttpMessageConverter
#### 为什么需要它？
#### 核心功能
#### 常见的 `HttpMessageConverter` 实现类
#### 工作流程
#### 总结
### 软件设计准则
### Enum的本质
### SpringBoot异常处理
### 优质开源项目学习
### 面对HR提问
### 接口幂等性
#### 使用数据库唯一约束
#### 基于Token机制
#### 利用Redis等缓存技术
#### 幂等锁
#### 总结
```

## 参考资料 

- [通义千问](https://tongyi.aliyun.com/qianwen/)
- [JavaGuide](https://javaguide.cn/)

## Java基础

### 字节码的好处？

**第一阶段：前端编译（源码到字节码）** Java 源代码（`.java` 文件）首先通过 `javac` 编译器进行编译。这个过程属于编译原理中的**前端编译**，主要包括词法分析、语法分析和语义分析等步骤。其输出结果是 **Java 字节码**（`.class` 文件）。字节码是一种与平台无关的**中间表示**（Intermediate Representation, IR），它使得 Java 程序具备了“一次编写，到处运行”的可移植性。

**第二阶段：运行时执行（字节码到机器码）** JVM 加载字节码文件后，进入执行阶段。这个阶段并非纯粹的解释或编译，而是两者的结合：

1. **解释执行**：JVM 的解释器会逐行读取字节码并解释执行。这种方式启动快，但持续执行的效率相对较低。
2. **即时编译（JIT）**：为了提升性能，JVM 在运行时会收集程序的执行信息（如方法调用次数、循环次数等）。当检测到某些代码（称为“热点代码”）被频繁执行时，JVM 内置的 **JIT（Just-In-Time）编译器**（属于**后端编译**）就会介入，将这些热点代码的字节码直接编译成本地机器码。编译后的机器码会被缓存起来，后续执行时便可以直接调用，从而获得接近原生代码的执行效率。

### IR是什么？

当然可以，以下是您提供内容的规整与清晰表述：

#### **Java 字节码作为中间表示（IR）**

当使用 `javac` 编译 Java 源代码（`.java` 文件）时，编译器会将其转换为一种平台无关的低级指令形式——**Java 字节码**（存储在 `.class` 文件中）。这种字节码是 Java 平台的核心 **中间表示**（Intermediate Representation, IR）。

- **平台无关性**：字节码不依赖于特定的硬件架构或操作系统，而是一种抽象的、标准化的指令集。
- **JVM 执行机制**：Java 虚拟机（JVM）负责加载并执行这些字节码。执行方式主要有两种：
  - **解释执行**：由解释器逐条读取并执行字节码指令。
  - **即时编译（JIT）**：将频繁执行的“热点代码”动态编译为本地机器码，以提升运行性能。
- **关键作用**：Java 字节码作为从源代码到最终执行之间的桥梁，既保留了程序的可移植性，又为运行时优化提供了基础。因此，**Java 字节码是 Java 语言在编译与执行流程中的关键中间表示（IR）**。

#### **其他工具中的自定义中间表示（IR）**

除了 JVM 直接使用的字节码外，一些高级的 Java 开发工具和分析框架为了实现更复杂的程序分析、优化或转换，往往会将 Java 字节码进一步转换为**自定义的中间表示（IR）**。

这些自定义 IR 通常具备更丰富的结构信息，便于进行深度分析和操作，例如：

- **控制流图**（Control Flow Graph, CFG）
- **数据流分析**（Data Flow Analysis）
- **调用图**（Call Graph）
- **表达式树或三地址码**等抽象形式

**典型应用示例**：

- **ASM**、**Javassist**：字节码操作库，在内存中解析 `.class` 文件后，可能构建内部结构化表示，用于动态生成或修改类。
- **Soot**：一个广泛使用的 Java 程序分析框架，它将 Java 字节码转换为多种 IR 形式（如 Baf、Jimple、Shimple），其中 Jimple 是一种简化后的三地址码表示，极大简化了静态分析的复杂度。
- **ProGuard / R8**：代码混淆与优化工具，利用自定义 IR 进行无用代码检测、内联、常量传播等优化。
- **IDE 静态分析插件**（如 IntelliJ、Eclipse）：在后台构建程序模型以支持代码检查、重构和智能提示。

### 什么是程序分析、优化、混淆、静态检查？

1. **程序分析 (Program Analysis)**
   - **定义**：程序分析是指系统地检查和理解程序的结构、行为、属性和潜在问题的过程。其目的是获取关于程序的深层信息，而不一定执行它（静态分析）或在执行时观察它（动态分析）。
   - 在 Java 中的应用：
     - **控制流分析 (Control Flow Analysis)**：构建程序的控制流图 (CFG)，展示代码块如何通过分支（if/else）、循环（for/while）和函数调用相互连接。这对于理解程序执行路径至关重要。
     - **数据流分析 (Data Flow Analysis)**：追踪程序中数据（变量）的定义、使用和传播。例如，分析一个变量在哪些地方被赋值，在哪些地方被读取，或者判断一个变量是否可能为 `null`。
     - **指针分析 / 别名分析 (Pointer/Alias Analysis)**：确定程序中的引用（指针）可能指向哪些对象，以及哪些不同的引用可能指向同一个对象（别名）。这在理解对象生命周期和并发问题时非常重要。
     - **调用图分析 (Call Graph Analysis)**：构建一个图，显示程序中哪些方法调用了哪些其他方法。这对于理解程序的整体结构、进行优化和检测死代码很有用。
     - **依赖分析**：分析类、方法、包之间的依赖关系。
   - **为什么需要 IR**：直接分析字节码指令序列比较复杂。自定义的 IR（如更高级的三地址码、SSA 形式）可以更清晰地表示控制流和数据流，使得分析算法（如数据流分析中的定值-引用链计算）更容易实现和优化。
2. **优化 (Optimization)**
   - **定义**：优化是指在不改变程序外部行为（语义）的前提下，修改程序以提高其性能（如运行速度、内存占用）或减小其体积（如代码大小）的过程。
   - 在 Java 中的应用：
     - **JIT 编译器优化**：JVM 的即时编译器（如 HotSpot 的 C1/C2）会将频繁执行的字节码编译成本地机器码，并在此过程中应用大量优化，如方法内联（Inlining）、循环展开（Loop Unrolling）、公共子表达式消除（CSE）、死代码消除（Dead Code Elimination）、逃逸分析（Escape Analysis）等。
     - **AOT 编译器优化**：像 GraalVM Native Image 这样的工具将 Java 程序提前编译（Ahead-of-Time）为本地可执行文件，会进行更激进的优化和链接。
     - **字节码优化工具**：一些工具专门用于优化 `.class` 文件，例如 ProGuard（也包含混淆功能）可以进行类/字段/方法名的缩短、无用代码/资源的移除、代码结构的简化等。
   - **为什么需要 IR**：优化通常需要复杂的分析（如上面提到的数据流、控制流分析）。一个设计良好的 IR 能够清晰地暴露程序的结构和数据依赖关系，使得优化算法（如识别可内联的方法、判断循环不变量）能够更有效地应用。优化后的 IR 再被转换回目标格式（字节码或机器码）。
3. **混淆 (Obfuscation)**
   - **定义**：混淆是指有意地修改程序的代码或结构，使其对人类（尤其是逆向工程师）来说变得难以阅读、理解和分析，但同时保持其原有的功能和行为。主要目的是保护知识产权和防止恶意篡改。
   - 在 Java 中的应用：
     - **名称混淆 (Name Obfuscation)**：将具有描述性意义的类名、方法名、字段名替换为无意义的短字符串（如 `a`, `b`, `c`）或 Unicode 难以阅读的字符。这是最常见和最基础的混淆。
     - **流混淆 (Flow Obfuscation)**：修改程序的控制流，例如插入无用的条件分支、循环或 try-catch 块，或者打乱代码执行顺序（在不改变逻辑的前提下），使控制流图变得复杂难懂。
     - **字符串加密 (String Encryption)**：将代码中的字符串常量加密存储，在运行时才解密使用，防止通过字符串搜索轻易找到关键逻辑。
     - **类/包结构混淆**：改变类的继承关系或包结构（在不破坏功能的情况下），增加理解难度。
   - **为什么需要 IR**：要进行有效的混淆（尤其是流混淆和高级混淆），工具需要深入理解程序的逻辑结构和数据依赖。自定义 IR 提供了一个抽象层，允许混淆器安全地插入无用代码、重排指令或修改控制流，同时利用分析确保不会破坏程序的正确性。直接在字节码层面操作风险更高。
4. **静态检查 (Static Checking)**
   - **定义**：静态检查是一种在程序**不实际运行**的情况下，通过分析其源代码或字节码来发现潜在错误、代码缺陷、安全漏洞、风格问题或违反编码规范的软件质量保证技术。
   - 在 Java 中的应用：
     - **编译器警告**：`javac` 本身会进行基本的静态检查，如未使用的变量、不可达代码、类型不匹配等。
     - **Lint 工具**：如 **Checkstyle** (检查代码风格和规范), **PMD** (检测常见编程缺陷、未使用代码、复杂度过高等), **SpotBugs** (前身是 FindBugs，利用字节码分析检测空指针解引用、资源泄漏、并发问题等潜在 bug)。
     - **安全扫描工具**：如 **SonarQube/SonarLint** (集成多种检查，包括安全漏洞、代码异味、重复代码等), **Fortify**, **Checkmarx** (专门用于发现安全漏洞，如 SQL 注入、XSS、不安全的反序列化等)。
     - **Null 安全分析**：一些工具或语言特性（如 Kotlin 的非空类型，或 Java 的 `@Nullable`/`@NonNull` 注解配合分析工具）可以静态地推断变量是否可能为 null，从而预防 `NullPointerException`。

### 什么是热点代码？

Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。

当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。

### 静态编译与动态编译

您对 JVM、JIT、AOT 以及 GraalVM 的理解非常准确和深入。确实，JIT 和 AOT 代表了两种不同的编译策略，各有其适用场景和权衡。下面我将您提到的关键点，用表格的形式进行清晰的总结和对比：

#### **JIT 与 AOT 编译对比表**

| 对比维度              | **JIT (Just-In-Time Compilation)**                           | **AOT (Ahead-Of-Time Compilation)**                          | **详细说明**                                                 |
| :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **编译时机**          | **运行时编译**在程序执行过程中，由 JVM 的 JIT 编译器动态编译。 | **提前编译**在程序运行**之前**，将 Java 字节码直接编译成本地机器码。 | JIT 是 Java “一次编写，到处运行” 的核心，字节码在运行时被优化；AOT 则在构建时就完成编译，生成独立的可执行文件。 |
| **代表技术/工具**     | HotSpot JVM (Oracle JDK, OpenJDK 默认)                       | **GraalVM Native Image** (基于 GraalVM)                      | GraalVM 是一个高性能的 JDK 发行版，它既包含强大的 JIT 编译器（作为 HotSpot 的替代或增强），也提供 `native-image` 工具来实现 AOT 编译。 |
| **启动时间**          | ❌ **较慢**需要加载 JVM、解释执行字节码、等待 JIT 预热。      | ✅ **极快**直接运行本地可执行文件，无需 JVM 启动和 JIT 预热。 | AOT 的最大优势之一，尤其适合 Serverless、微服务等需要快速冷启动的场景。 |
| **内存占用**          | ❌ **较高**JVM 本身占用内存，加上 JIT 编译、GC 等开销。       | ✅ **显著降低**没有 JVM 开销，本地镜像内存占用更小。          | AOT 生成的原生镜像内存 Footprint 更小，可以更高效地利用资源。 |
| **打包体积**          | ❌ **较大**包含整个 JVM 和所有依赖的 JAR 包。                 | ✅ **更小**（相对）只包含应用和其**实际使用到**的代码和库。   | GraalVM Native Image 会进行**静态代码分析**（Tree Shaking），移除未使用的代码，从而减小体积。但生成的可执行文件可能仍比单个 JAR 大，因为它包含了必要的运行时组件。 |
| **运行时性能 (峰值)** | ✅ **更高**JIT 可以进行**深度运行时优化**（如基于热点代码、类型推断）。 | ❌ **相对较低**优化在编译时完成，无法根据运行时数据进行动态调整。 | JIT 的优势在于“越用越快”。它能根据程序的实际执行路径（Profile-Guided Optimization）生成高度优化的机器码，理论上能达到接近 C/C++ 的性能。AOT 的优化是静态的，缺乏这种动态适应能力。 |
| **运行时性能 (延迟)** | ❌ **存在波动**请求延迟可能因 JIT 预热、GC 而出现“毛刺”（Jitter）。 | ✅ **更稳定**启动后性能立即稳定，延迟可预测。                 | AOT 避免了 JIT 预热期的性能不稳定，对于需要低且稳定延迟的场景（如高频交易）有优势。 |
| **支持的动态特性**    | ✅ **完全支持**反射、动态代理、动态类加载、JNI 等。           | ❌ **受限或不支持**必须在编译时确定，需要**显式配置**或**框架适配**。 | **这是 AOT 的核心挑战！** - **反射**：必须在 `reflect-config.json` 中预先声明。 - **动态代理 (CGLIB, JDK Proxy)**：框架（如 Spring AOT）需在构建时生成代理类。 - **JNI**：需要特殊处理。 - **资源加载**：必须在 `resource-config.json` 中声明。 |
| **对框架的影响**      | ✅ **兼容性好**Spring, Hibernate 等主流框架开箱即用。         | ⚠️ **需要适配**框架必须提供 AOT 支持（如 Spring Boot 3+ 的 AOT 模式）。 | 如您所言，CGLIB 使用 ASM 在运行时生成字节码，这在 AOT 中无法进行。因此，Spring Framework 6 / Spring Boot 3 引入了 **AOT Engine**，在构建时通过 **源码生成 (Source Generation)** 或 **提前处理** 的方式，模拟或替代这些运行时动态行为。 |
| **适用场景**          | - 传统单体应用- 长时间运行、追求极致吞吐量的服务- 使用大量动态特性的应用 | - **云原生应用** (Serverless, FaaS)- **微服务** (快速启动、低内存)- CLI 工具- 嵌入式场景 | **云原生趋势下，AOT 优势凸显**。虽然 JIT 在峰值性能上有理论优势，但 AOT 在启动、内存、稳定性方面的优势更符合现代弹性、按需伸缩的架构需求。GraalVM Native Image 正是为这些场景而生。 |
| **总结**              | **“运行时优化，性能潜力大”**                                 | **“启动快，资源省，适合云”**                                 | 两者并非完全替代关系。**GraalVM 的强大之处在于它同时提供了顶尖的 JIT 和 AOT 能力**。开发者可以根据应用的具体需求（是追求极限性能还是极致启动速度）来选择合适的编译模式。 |

1.  **GraalVM 是桥梁**：它让 Java 应用既能享受 JIT 的高性能潜力，又能通过 Native Image 获得 AOT 的云原生优势。
2.  **AOT 的代价是动态性**：放弃或限制 Java 的动态特性是使用 AOT 必须付出的代价。这推动了框架（如 Spring）向**构建时优化**和**源码生成**的方向演进。
3.  **场景驱动选择**：没有绝对的好坏。对于需要快速冷启动和低内存的微服务，**AOT (GraalVM Native Image) 是优选**；对于长时间运行、计算密集型且依赖复杂动态特性的应用，**JIT (HotSpot 或 GraalVM JIT) 仍是主力**。

### 移位运算符

| 应用领域                    | 具体用途与示例                                               | 使用的移位运算符       | 核心原理与优势                                               |
| :-------------------------- | :----------------------------------------------------------- | :--------------------- | :----------------------------------------------------------- |
| **算术优化**                | **快速乘以/除以 2 的幂次方**例如：`x << 3` 等价于 `x * 8` (2³)`x >> 2` 等价于 `x / 4` (2²，对正数) （算术右移） | `<<` (左移)`>>` (右移) | **性能极高**：CPU 的移位指令通常比乘除法指令快得多。是底层性能优化的经典技巧。 |
| **位字段 (Bit Field) 管理** | **高效存储多个布尔标志或小范围整数**例如：用一个 `int` (32位) 存储 32 个开关状态。```java// 设置第 5 位 (bit 5)flags |= (1 << 5);// 清除第 3 位 (bit 3)flags &= ~(1 << 3);// 检查第 7 位是否设置boolean isSet = (flags & (1 << 7)) != 0;// 从 flags 中提取 4-7 位表示的值int value = (flags >> 4) & 0xF; // 0xF = 1111₂``` | `<<` `>>` `&` `\|` `~` | **空间效率极高**：将多个独立的小数据打包到一个整数中，节省内存。常用于协议解析、状态寄存器、权限控制等。 |
| **哈希算法与加密**          | **数据混淆、扩散和生成哈希值**例如：在简单的哈希函数或加密轮函数中：```javaint hash = seed;hash ^= (key & 0xFF);hash = (hash << 5) + (hash >> 27); // 混合高低位```MD5, SHA 等算法内部大量使用移位和循环移位。 | `<<` `>>`              | **混淆与扩散**：移位能快速打乱数据的位模式，使得输入的微小变化导致输出的巨大差异（雪崩效应），这是密码学和哈希函数安全性的基础。 |
| **数据压缩**                | **高效处理二进制码流**例如：在实现霍夫曼编码、LZW 等算法时：- 将变长的霍夫曼码**拼接**到一个 `int` 或 `long` 的缓冲区中：`buffer |= (huffmanCode << bitPosition)`。- 从缓冲区中**提取**固定位数的数据：`(buffer >> (totalBits - neededBits)) & mask`。 | `<<` `>>` `&`          | **位级操作**：压缩算法通常处理的是位流而非字节流。移位运算符是操作和重组这些位流的最基本、最高效的工具，避免了繁琐的字节处理。 |
| **数据校验 (CRC)**          | **生成和校验循环冗余码**CRC 算法的核心是**模拟多项式除法**，其步骤包括：1.  将数据视为一个长二进制数。2.  与一个预定义的生成多项式进行异或和**移位**操作。移位是实现“除法”步骤的关键。 | `<<` `>>` `^` (异或)   | **硬件友好**：CRC 的移位-异或操作非常适合作为硬件电路实现，也易于用软件高效模拟。移位用于推进计算过程，异或用于执行模 2 减法。是网络通信、存储系统中保证数据完整性的标准方法。 |
| **内存对齐**                | **计算对齐的地址或大小**例如：将大小 `size` 向上对齐到 8 字节边界（假设 8=2³）：```javaint alignedSize = (size + 7) & ~7; // 经典方法// 或者使用移位 (当对齐边界是 2 的幂时)int alignment = 8; // 必须是 2 的幂int shift = 3; // log₂(8)int alignedSize = ((size - 1) >> shift << shift) + alignment; // 较少见，但可行``` | `>>` `<<` `&` `~`      | **高效计算**：当对齐边界是 2 的幂时，利用移位和位掩码 (`& ~mask`) 可以非常快速地完成对齐计算，比使用模运算 (`%`) 更高效。第一个 `& ~7` 的方法更常用。 |

*   **核心优势**：移位运算符操作的是**二进制位**，直接对应 CPU 的底层指令，因此具有**极高的执行效率**。
*   **主要类型**：
    *   `<<` (左移)：高位丢弃，低位补 0。等效于 * 2^n。
    *   `>>` (算术右移)：符号位不变，高位补符号位（正数补0，负数补1）。等效于 / 2^n (向下取整)。
    *   `>>>` (逻辑右移)：高位补 0，忽略符号。常用于处理无符号数或提取位。
*   **适用场景**：主要在**性能敏感**、**内存敏感**或需要**直接操作二进制数据**的领域（如底层系统编程、算法实现、网络协议、密码学、嵌入式开发）中发挥重要作用。
*   **注意事项**：使用时需注意数据类型（int vs long）、符号位的影响（`>>` vs `>>>`）以及移位位数的范围（通常对 32 或 64 取模）。

### J2EE和Spring技术对比

| 技术/功能              | Java EE (Jakarta EE) 方式                                    | Spring (Spring Boot) 方式                                    | 对比说明                                                     |
| :--------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Web 层 (MVC)**       | **Servlet & JSP**：- Servlet 处理请求/响应。- JSP 生成动态视图。- 通常结合 JSTL、自定义标签使用。 | **Spring MVC**：- 基于注解（`@Controller`, `@RequestMapping`）的控制器。- 支持 Thymeleaf、Freemarker、JSP 等多种视图技术。- 更强的类型安全和灵活性。 | ✅ **Spring 更灵活现代**：Spring MVC 提供了更简洁的注解驱动开发，解耦更好，测试更容易。JSP 在 Spring 中虽可用，但官方推荐 Thymeleaf 等模板引擎。 |
| **业务逻辑层**         | **EJB (Enterprise JavaBean)**：- 有状态/无状态 Session Bean。- MDB（消息驱动 Bean）。- 容器提供事务、安全、并发等服务。 | **Spring Bean + Service**：- 使用 `@Service`, `@Component` 等注解定义业务组件。- 通过 Spring 容器管理生命周期和依赖。 | ✅ **Spring 更轻量灵活**：EJB 配置复杂，依赖容器；Spring Bean 更简单，无需特定容器，POJO 编程，更易测试和迁移。EJB 功能在 Spring 中都能更好实现。 |
| **数据库连接**         | **JDBC**：- 原生 `java.sql` API，需手动管理连接、异常、资源释放。 | **Spring JDBC (JdbcTemplate)**：- 封装了 JDBC 模板，简化了 CRUD 操作。- 自动处理资源关闭和异常转换（转为 Spring 的 `DataAccessException`）。 | ✅ **Spring 极大简化 JDBC**：Spring 的 `JdbcTemplate` 减少了大量样板代码，提高了开发效率和安全性。 |
| **对象关系映射 (ORM)** | **JPA (Java Persistence API)**：- 标准 ORM 规范（如 Hibernate、EclipseLink 实现）。- 使用 `EntityManager`。 | **Spring Data JPA**：- 基于 JPA，提供更高级的抽象（如 `JpaRepository`）。- 方法名自动推导查询（`findByUsername`）。- 分页、排序内置支持。 | ✅ **Spring Data JPA 更高效**：两者底层都用 JPA，但 Spring Data JPA 极大减少了 DAO 层代码量，开发速度更快，是目前主流选择。 |
| **事务管理**           | **JTA (Java Transaction API)**：- 分布式事务标准。- EJB 和 JPA 可集成 JTA。- 需要支持 JTA 的应用服务器（如 WildFly, WebLogic）。 | **Spring Transaction**：- 支持本地事务（JDBC）和 JTA。- `@Transactional` 注解驱动。- 可集成 Atomikos、Bitronix 实现分布式事务。 | ✅ **Spring 更灵活通用**：Spring 事务管理不依赖完整 Java EE 服务器，可在 Tomcat 等轻量容器中使用，配置更简单，支持更广。 |
| **邮件发送**           | **JavaMail (Java EE API)**：- 标准 API，需配置 `MailSession` 等。 | **Spring Mail**：- 封装 JavaMail，提供 `JavaMailSender` 接口和 `SimpleMailMessage`。- 配置更简单（`spring.mail.*`）。- 易于测试。 | ✅ **Spring 更易用**：Spring 对 JavaMail 进行了优秀封装，配置和使用都更简洁，是实际项目中的首选。 |
| **消息队列**           | **JMS (Java Message Service)**：- 标准 API，支持点对点和发布/订阅。- 需 JMS 提供者（如 ActiveMQ）。 | **Spring JMS / Spring Messaging / Spring AMQP**：- 封装 JMS，提供 `JmsTemplate` 和 `@JmsListener`。- 支持 RabbitMQ (AMQP)、Kafka 等更多消息中间件。 | ✅ **Spring 生态更广**：Spring 不仅支持 JMS，还扩展支持 AMQP、Kafka 等现代消息系统，抽象层次更高，集成更方便。 |
| **整体架构**           | **Java EE 容器驱动**：- 需要完整的应用服务器（如 WildFly, GlassFish, WebLogic）。- 遵循规范，标准化强。 | **Spring Boot + 内嵌容器**：- 使用 Tomcat/Jetty/Undertow 内嵌服务器。- “约定优于配置”，自动装配。- 微服务友好（Spring Cloud）。 | ✅ **Spring Boot 更现代高效**：开发、部署、运维更简单，启动快，适合云原生和微服务架构。Java EE 更适合传统大型企业系统。 |
| **依赖管理**           | 依赖 Java EE 容器提供 API 实现。                             | 使用 Maven/Gradle 精确管理依赖版本，可自由选择组件组合（如只用 Spring MVC + MyBatis）。 | ✅ **Spring 更自由可控**：Spring 不强制依赖完整平台，可按需引入，避免“重量级”问题。 |

| 维度         | Java EE (Jakarta EE)                   | Spring (Spring Boot)                                       |
| :----------- | :------------------------------------- | :--------------------------------------------------------- |
| **定位**     | **标准化平台规范**                     | **全面的应用框架**                                         |
| **开发效率** | 相对较低（配置多，样板代码多）         | **极高**（自动配置，注解驱动，模板封装）                   |
| **学习曲线** | 较陡（EJB、JTA 等概念复杂）            | 相对平缓（尤其是 Spring Boot）                             |
| **部署**     | 需完整应用服务器（较重）               | 可独立运行（JAR + 内嵌容器），轻量快速                     |
| **生态**     | 标准化，厂商兼容性好                   | **极其丰富**，社区活跃，第三方集成多（如 Cloud, Security） |
| **适用场景** | 传统大型企业系统，需严格遵循标准的项目 | **现代 Web 应用、微服务、云原生应用**（主流选择）          |

> 💡 **结论**：虽然 Java EE 定义了重要的企业级标准（如 JPA, JTA, JMS），但 **Spring 框架（尤其是 Spring Boot）** 通过提供更简洁、灵活、高效的实现方式，已经成为当前企业 Java 开发的**绝对主流**。Spring 并非取代这些技术，而是更好地**集成、封装和简化**了它们的使用。

### 不要在finaly语句块中使用return

**不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。

### 注解的本质

`Annotation` （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。

注解本质是一个继承了`Annotation` 的特殊接口

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {

}

public interface Override extends Annotation{

}
```

### 注解的解析方法有哪几种

注解只有被解析之后才会生效，常见的解析方法有两种：

- **编译期直接扫描**：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过反射来进行处理的

 ### java中没有引用传递

c++中的引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？

**注意：以下为个人观点看法，并非来自于 Java 官方：**

1. 出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。
2. Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。

### 序列化

序列化是分布式系统中不同服务间数据交换的重要环节。在讨论OpenFeign和Dubbo这两种不同的远程调用框架时，它们各自支持的序列化方法有所不同。

#### OpenFeign

OpenFeign 是一个声明式的Web服务客户端，使得编写Web服务客户端变得更加简单。它本身主要关注于HTTP层面的服务调用，并不直接提供序列化机制，而是依赖于所使用的HTTP消息转换器（如Spring中的`HttpMessageConverter`）来实现请求和响应体的序列化与反序列化工作。默认情况下，如果是在Spring环境中使用OpenFeign，它通常会支持以下几种序列化方式：

- **JSON**：通过Jackson或Gson等库进行序列化/反序列化。
- **XML**：如果有相应的消息转换器配置的话，也可以支持XML格式的数据交换。

因此，在OpenFeign中，序列化的选择很大程度上取决于你使用的具体框架以及如何配置消息转换器。



#### Dubbo

Dubbo 是阿里巴巴开源的一个高性能服务框架，致力于提供高效、可靠的RPC（远程过程调用）服务。Dubbo 对序列化提供了更直接的支持，允许用户配置不同的序列化方式。Dubbo 默认支持多种序列化方式，包括但不限于：

- **Hessian2**：这是Dubbo默认的序列化方式，具有较好的性能和跨语言支持。
- **Java序列化**：使用Java自带的序列化机制，适用于纯Java环境下的应用。
- **Kryo**：一种高效的Java序列化库，相较于Java原生序列化有显著的性能提升。
- **FST**：Fast-serialization (FST) 是另一个快速且功能强大的Java序列化库。
- **Protobuf**：Google提供的语言中立、平台中立、可扩展的序列化结构数据格式，非常适合用于数据交换。
- **Avro**：Apache Avro是一种数据序列化系统，设计用于支持超大数据集的长期存储和服务间的通信。

Dubbo允许用户根据自己的需求灵活地选择合适的序列化策略，并在配置文件中指定。

#### 总结

- 在**OpenFeign**中，序列化更多地依赖于底层的HTTP消息转换器，常见的选择为JSON和XML，但主要是由集成的框架（如Spring）决定的。
- **Dubbo**则提供了对多种序列化方式的内置支持，允许用户根据性能、兼容性等要求选择最适合项目的序列化方案，比如Hessian2、Kryo、Protobuf等。这意味着在Dubbo项目中调整序列化策略可能会更加直观和方便。

### HttpMessageConverter

`HttpMessageConverter` 是 Spring 框架（特别是 Spring Web MVC 和 Spring WebFlux）中的一个核心接口，它在处理 HTTP 请求和响应时扮演着至关重要的角色。

简单来说，**`HttpMessageConverter` 的作用是在 HTTP 请求/响应的原始字节流（通常是字符串或字节数组）和 Java 对象之间进行相互转换**。

#### 为什么需要它？

1.  **客户端发送请求**：当你通过 HTTP POST 或 PUT 请求发送数据（例如，一个 JSON 字符串 `{"name": "Alice", "age": 30}`）到服务器时，Spring 需要一种机制将这个原始的 JSON 文本解析（反序列化）成一个对应的 Java 对象（如 `User user`）。
2.  **服务器返回响应**：当你的控制器方法返回一个 Java 对象（如 `return new User("Bob", 25);`）时，Spring 需要一种机制将这个 Java 对象转换（序列化）成客户端可以理解的格式（如 JSON 字符串 `{"name": "Bob", "age": 25}`），并将其写入 HTTP 响应体中。

`HttpMessageConverter` 就是完成这些转换工作的“翻译官”。

#### 核心功能

`HttpMessageConverter` 接口定义了四个主要方法：

1.  **`boolean canRead(Class<?> clazz, MediaType mediaType)`**:
    *   **作用**：判断这个转换器是否能将指定的 HTTP 内容类型（`MediaType`，如 `application/json`）的请求体读取并转换为指定的 Java 类型（`clazz`）。
    *   **场景**：用于处理 `@RequestBody` 注解。

2.  **`boolean canWrite(Class<?> clazz, MediaType mediaType)`**:
    *   **作用**：判断这个转换器是否能将指定的 Java 对象（`clazz` 的实例）写入 HTTP 响应体，并转换为指定的内容类型（`MediaType`）。
    *   **场景**：用于处理 `@ResponseBody` 注解或 `@RestController`。

3.  **`T read(Class<? extends T> clazz, HttpInputMessage inputMessage)`**:
    *   **作用**：从 `HttpInputMessage`（包含请求头和请求体输入流）中读取数据，并将其反序列化为指定类型的 Java 对象 `T`。
    *   **场景**：实现 `@RequestBody` 的功能。

4.  **`void write(T t, MediaType contentType, HttpOutputMessage outputMessage)`**:
    *   **作用**：将 Java 对象 `T` 序列化，并将其写入 `HttpOutputMessage`（包含响应头和响应体输出流），同时设置响应的内容类型。
    *   **场景**：实现 `@ResponseBody` 的功能。

#### 常见的 `HttpMessageConverter` 实现类

Spring MVC 默认注册了多个 `HttpMessageConverter` 的实现，以支持不同的数据格式：

*   **`MappingJackson2HttpMessageConverter`**:
    *   **功能**：使用 Jackson 库将 Java 对象与 **JSON** 格式相互转换。这是最常用的转换器。
    *   **处理的 MediaType**: `application/json`, `text/json` 等。

*   **`Jaxb2RootElementHttpMessageConverter`**:
    *   **功能**：使用 JAXB (Java Architecture for XML Binding) 将 Java 对象与 **XML** 格式相互转换。
    *   **处理的 MediaType**: `application/xml`, `text/xml` 等。

*   **`StringHttpMessageConverter`**:
    *   **功能**：处理 `String` 类型。能将请求体直接转换为 `String`，或将 `String` 写入响应体。
    *   **处理的 MediaType**: `text/plain` 等。

*   **`ByteArrayHttpMessageConverter`**:
    *   **功能**：处理 `byte[]` 类型。能将请求体转换为字节数组，或将字节数组写入响应体。
    *   **处理的 MediaType**: `application/octet-stream` 等。

*   **`FormHttpMessageConverter` / `SourceHttpMessageConverter`**:
    *   **功能**：分别处理表单数据和 XML Source 对象。

*   **`BufferedImageHttpMessageConverter`**:
    *   **功能**：处理图片（`BufferedImage`）的读写。

#### 工作流程

1.  当一个 HTTP 请求到达时，Spring MVC 的 `DispatcherServlet` 会根据请求的 `Content-Type` 头（对于请求体）和 `Accept` 头（对于期望的响应类型）来查找合适的 `HttpMessageConverter`。
2.  它会遍历所有注册的 `HttpMessageConverter`，调用它们的 `canRead()` 或 `canWrite()` 方法，找到第一个能够处理当前请求/响应类型和目标 Java 类型的转换器。
3.  找到后，调用该转换器的 `read()` 或 `write()` 方法完成实际的转换工作。

#### 总结

`HttpMessageConverter` 是 Spring Web 框架中实现**内容协商 (Content Negotiation)** 的关键组件。它使得开发者可以轻松地在控制器中使用 Java 对象，而无需关心底层的 HTTP 消息是如何将这些对象序列化为 JSON/XML 字符串或从字符串反序列化回来的。开发者通常只需要确保项目中包含了正确的依赖（如 Jackson 用于 JSON），Spring Boot 会自动配置好相应的转换器。

### 软件设计准则

面向对象编程来说，下面这些原则都是我们应该非常熟练的。

1. 面向对象编程的思想（继承、封装、多态、抽象）

2. 面向对象的七大设计原则：单一职责原则（Single Responsibility Principle, SRP）

- 开闭原则（Open Closed Principle，OCP）

  - ✅ **好例子**：`UserRepository` 只负责用户数据的存取，`UserService` 负责业务逻辑。
  - ❌ **坏例子**：一个类既处理数据库操作，又发邮件，又做日志记录。

  > **意义**：降低类的复杂度，提高可维护性和可测试性。

- 里氏代换原则（Liskov Substitution Principle，LSP）

  - ✅ **实现方式**：通过抽象（接口/抽象类） + 多态实现扩展。
  - ❌ 修改已有代码来增加功能是违背 OCP 的。

  > **例子**：支付系统支持新支付方式（如支付宝），应通过新增类实现，而不是修改原有 `PayService`。

- 接口隔离原则（Interface Segregation Principle，ISP）

  - 不要让客户端依赖它不需要的方法。
  - 提倡“细粒度接口”，避免“胖接口”。

  > **例子**：不要让一个 `Printer` 接口包含 `print()`, `scan()`, `fax()`，而应拆分为 `Printable`, `Scannable`, `Faxable`。

- 依赖反转原则（Dependency Inversion Principle，DIP）

  - 高层模块不依赖低层模块，两者都依赖抽象。
  - 抽象不依赖细节，细节依赖抽象。

  > **实现方式**：依赖注入（DI）、控制反转（IoC）容器（如 Spring）。

  **不遵循 DIP 的代码：**

  ```java
  // 低层模块 (具体实现)
  class MySQLDatabase {
      public void saveOrder(Order order) {
          // 保存到 MySQL 的具体逻辑
      }
  }
  
  // 高层模块 (直接依赖低层模块)
  class OrderService {
      private MySQLDatabase database = new MySQLDatabase(); // 直接 new 一个具体实现
  
      public void processOrder(Order order) {
          // ... 业务逻辑 ...
          database.saveOrder(order); // 直接调用具体实现
      }
  }
  ```

  **遵循 DIP 的代码：**

  ```java
  // 1. 定义抽象
  interface Database {
      void saveOrder(Order order);
  }
  
  // 2. 低层模块实现抽象
  class MySQLDatabase implements Database {
      @Override
      public void saveOrder(Order order) {
          // 保存到 MySQL 的具体逻辑
      }
  }
  
  class PostgreSQLDatabase implements Database {
      @Override
      public void saveOrder(Order order) {
          // 保存到 PostgreSQL 的具体逻辑
      }
  }
  
  // 3. 高层模块依赖抽象
  class OrderService {
      private Database database; // 依赖的是抽象接口
  
      // 通过构造函数注入具体的实现
      public OrderService(Database database) {
          this.database = database;
      }
  
      public void processOrder(Order order) {
          // ... 业务逻辑 ...
          database.saveOrder(order); // 调用抽象接口
      }
  }
  
  // 4. 使用 (依赖注入)
  public class Main {
      public static void main(String[] args) {
          // 可以轻松切换不同的数据库实现
          Database db = new MySQLDatabase(); // 或 new PostgreSQLDatabase();
          OrderService service = new OrderService(db); // 注入依赖
          service.processOrder(new Order());
      }
  }
  ```

- 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）

  - 当要复用功能时，优先使用组合（has-a）而不是继承（is-a）。
  - 继承破坏封装，组合更灵活。

  > **例子**：`Car` 包含 `Engine` 对象，而不是继承 `Engine`。

- 迪米特法则（Principle of Least Knowledge，PLK，也叫最小知识原则）

  - 一个对象应对其他对象保持最少了解。
  - 只与直接“朋友”通信（如：自己、参数、成员、创建的对象）。

  > **例子**：避免 `a.getB().getC().doSomething()`，应通过 `a.doSomething()` 封装。

3. 软件设计的三大原则

- DRY（Don’t Repeat Yourself）原则：不要重复你自己

- KISS（ Keep It Simple/Stupid）原则：保持简单易懂

- YAGNI （ You Ain’t Gonna Need It）原则 ：不要进行过度设计

### Enum的本质

| 特性                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| ✅ **是一个类**                | 编译后生成 `.class` 文件，是一个完整的类。                   |
| ✅ **继承自 `java.lang.Enum`** | 所有枚举都隐式继承 `Enum` 类，不能显式继承其他类（Java 不支持多继承）。 |
| ✅ **实例是有限且固定的**      | 实例在类加载时创建，且是 `public static final` 的，不可变。  |
| ✅ **构造器是私有的**          | 防止外部通过 `new` 创建新实例。                              |
| ✅ **天然线程安全**            | 实例在类加载时初始化，JVM 保证其唯一性和线程安全。           |
| ✅ **可实现接口**              | 枚举类可以实现接口（如 `Comparable`, `Serializable`）。      |
| ✅ **可定义方法和字段**        | 枚举可以有自己的属性、方法、甚至抽象方法。                   |

💡 **核心思想**：
 枚举不是“数据”，而是一种**有限状态机（Finite State Machine）** 或 **领域常量类型** 的优雅表达。

### SpringBoot异常处理

`@ControllerAdice`和`@ExceptionHandler`处理Controller级别的异常

```java
import com.twuc.webApp.web.ExceptionController;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import javax.servlet.http.HttpServletRequest;

@ControllerAdvice(assignableTypes = {ExceptionController.class})
@ResponseBody
public class GlobalExceptionHandler {

    // 也可以将 BaseException 换为 RuntimeException
    // 因为 RuntimeException 是 BaseException 的父类
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<?> handleAppException(BaseException ex, HttpServletRequest request) {
        ErrorReponse representation = new ErrorReponse(ex, request.getRequestURI());
        returnnew ResponseEntity<>(representation, new HttpHeaders(), ex.getError().getStatus());
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity<ErrorReponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
        ErrorReponse errorReponse = new ErrorReponse(ex, request.getRequestURI());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorReponse);
    }
}

```

### 优质开源项目学习

https://javaguide.cn/open-source-project/practical-project.html

多手搓轮子！！！

### 面对HR提问

**面对** **HR** **或者其他** **Level** **比较低的面试官时**

1. 能不能谈谈你作为一个公司老员工对公司的感受? (这个问题比较容易回答，不会让面试官陷入无话

可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司

到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上

还可以拉进你与面试官的距离。)

2. 能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你?有

什么地方你觉得还不太好或者可以继续完善吗？ （类似第一个问题，都是问面试官个人对于公司的

看法，）

3. 我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？(这个是我常问的。我觉得说自己表

现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)

4. 接下来我会有一段空档期，有什么值得注意或者建议学习的吗？ （体现出你对工作比较上心，自助

学习意识比较强。）

5. 这个岗位为什么还在招人？ (岗位真实性和价值咨询)
6. 大概什么时候能给我回复呢？ (终面的时候，如果面试官没有说的话，可以问一下)

**面对部门领导**

1.  部门的主要人员分配以及对应的主要工作能简单介绍一下吗？

2. 未来如果我要加入这个团队，你对我的期望是什么？ （部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）

3. 公司对新入职的员工的培养机制是什么样的呢？ （正规的公司一般都有培养机制，提前问一下是对

   你自己的负责也会显的你比较上心）

4. 以您来看，这个岗位未来在公司内部的发展如何？ (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)

5. 团队现在面临的最大挑战是什么？ (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期。)

### 接口幂等性

**什么是幂等呢**? 在分布式系统中，幂等(idempotency)是对请求操作结果的一个描述，这个描述就是不论

执行多少次相同的请求，产生的效果和返回的结果都和发出单个请求是一样的。

🌰 举个例子：假如咱们的前后端没有保证接口幂等性，我作为用户在秒杀商品的时候，我同时点击了

多次秒杀商品按钮，后端处理了多次相同的订单请求，结果导致一个人秒杀了多个商品。这个肯定是不

能出现的，属于非常严重的 bug 了！

保证分布式接口的幂等性对于数据的一致性至关重要，特别是像支付这种涉及到钱的接口。保证幂等性

**这个操作并不是说前端做了就可以的，后端同样要做。**

前端保证幂等性的话比较简单，一般通过当用户提交请求后将按钮致灰来做到。后端保证幂等性就稍微

麻烦一点，方法也是有很多种，比如：

1. 同步锁；

2. 分布式锁；

3. 业务字段的唯一索性约束，防止重复数据产生。

4. ......

拿分布式锁来说，我们通过加锁的方式限制用户在第一次请求未结束之前，无法进行第二次请求。

分布式锁一般基于 Redis 来做比较多一些，这也是我比较推荐的一种方式。另外，如果使用 Redis 来实

现分布式锁的话，比较推荐基于 Redisson。相关阅读：分布式锁中的王者方案 - Redisson 

https://blog.csdn.net/2303_78263863/article/details/147480794

在分布式系统或微服务架构中，确保接口的**幂等性**是非常重要的，尤其是在处理如支付、订单创建等关键业务逻辑时。幂等性指的是同一个操作无论执行多少次，其结果都是相同的。对于 Spring Boot 应用来说，实现接口的幂等性可以通过多种方式来完成，下面介绍几种常见的策略：

#### 使用数据库唯一约束

如果请求涉及对数据库的操作，可以利用数据库的**唯一约束**来保证幂等性。例如，在处理订单创建时，可以为订单号设置唯一约束。当重复提交相同的订单号时，数据库会抛出异常，从而阻止重复记录的插入。

```sql
CREATE UNIQUE INDEX unique_order_number ON orders(order_number);
```

在服务端捕获此异常，并返回相应的错误信息给客户端。

#### 基于Token机制

这是一种常用的方法，特别适合于HTTP请求场景：

- **步骤1**：客户端发起请求前，先从服务器获取一个唯一的token。
- **步骤2**：客户端将此token与请求数据一同发送至服务器。
- **步骤3**：服务器接收到请求后，首先检查该token是否已经被使用过（通常通过数据库或缓存来存储已使用的token）。若未被使用，则执行业务逻辑并标记此token为已使用；否则直接返回之前的结果或错误提示。

Spring Boot 实现示例：

```java
@PostMapping("/process")
public ResponseEntity<?> processRequest(@RequestParam String token, @RequestBody RequestData data) {
    if (!tokenService.isValid(token)) {
        return new ResponseEntity<>("Duplicate request", HttpStatus.BAD_REQUEST);
    }
    // 执行业务逻辑
    tokenService.markAsUsed(token);
    return new ResponseEntity<>(result, HttpStatus.OK);
}
```

#### 利用Redis等缓存技术

Redis 提供了原子性的操作支持，非常适合用于幂等性控制。可以将每个请求的唯一标识符（如UUID）作为key存入Redis，并设置一个较短的有效期。每次请求到达时，检查Redis中是否存在对应的key。如果存在则说明是重复请求，反之则执行业务逻辑并将key存入Redis。

```java
if (Boolean.FALSE.equals(redisTemplate.hasKey(requestId))) {
    redisTemplate.opsForValue().set(requestId, "processed", Duration.ofMinutes(5));
    // 执行业务逻辑
} else {
    throw new RuntimeException("Duplicate request detected");
}
```

#### 幂等锁

在某些情况下，可以使用分布式锁来确保同一时间只有一个线程能够处理特定资源的相关请求。例如，使用 Redisson 或 Zookeeper 实现分布式锁。

#### @AutoIdempotent 幂等性实现



```java
/**
 * 需要保持幂等性的方法上加入此注解
 *
 */

@Target(value={ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoIdempotent {
}
```



```java


import cn.hutool.crypto.SecureUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;

import javax.servlet.ServletRequest;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.TimeUnit;


@Component
public class IdempotentInterceptor extends AutoIdempotentInterceptor {
    public static final String TOKEN_PREFIX = "TOKEN";
    public static final String APPID = "appid";
    @Autowired
    private RedisService redisService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();
            //被ApiIdempotment标记的扫描
            AutoIdempotent methodAnnotation = method.getAnnotation(AutoIdempotent.class);
            if (methodAnnotation != null) {
                String uri = request.getRequestURI();
                if (uri.contains("uploadImageServlet")) {
                    //图像上传的请求，不做处理
                    return false;
                } else {
                    String reqMethod = request.getMethod();
                    if ("POST".equals(reqMethod) || "PUT".equals(reqMethod)) {
                        String appId = request.getHeader(APPID);
                        if (isJson(request)) {
                            ServletRequest requestWrapper = new BodyReaderHttpServletRequestWrapper(request);
                            String body = HttpHelper.getBodyString(requestWrapper);
                            String bodyMD5 = SecureUtil.md5(body);
                            Object cacheObject = redisService.getCacheObject(bodyMD5);
                            if (cacheObject == null) {
                                redisService.setCacheObject(bodyMD5, bodyMD5, 3L, TimeUnit.SECONDS);
                            } else {
                                throw new CustomException("操作过快，请勿连续重复提交", 500);
                            }
                            if (StringUtils.isEmpty(appId)) {
                            } else {
                                //第三方调用的接口 不做过滤的原因是 ：第三方请求走sentinel限流
                                return true;
                            }
                        } else {
                            //如果是POST请求则需要获取 param 参数
                            Map<String, String[]> param = request.getParameterMap();
                            byte[] bp = objectToBytes(param);
                            String bodyMD5 = HashUtils.md5WithBase64(bp);
                            Object cacheObject = redisService.getCacheObject(bodyMD5);
                            if (cacheObject == null) {
                                redisService.setCacheObject(bodyMD5, param, 3L, TimeUnit.SECONDS);
                            } else {
                                throw new CustomException("操作过快，请勿连续重复提交", 500);
                            }
                            if (StringUtils.isEmpty(appId)) {
                            } else {
                                //第三方调用的接口 不做过滤的原因是 ：第三方请求走sentinel限流
                                return true;
                            }
                        }
                    } else {//get请求直接放行
                        return true;
                    }
                }
            }
        }
        return true;
    }

    /**
     * 判断本次请求的数据类型是否为json
     *
     * @param request request
     * @return boolean
     */
    private boolean isJson(HttpServletRequest request) {
        if (request.getContentType() != null) {
            return request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) ||
                    request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE);
        }
        return false;
    }

    /**
     * 对象转字节数组
     */
    public static byte[] objectToBytes(Object obj) throws IOException {
        try (
                ByteArrayOutputStream out = new ByteArrayOutputStream();
                ObjectOutputStream sOut = new ObjectOutputStream(out);
        ) {
            sOut.writeObject(obj);
            sOut.flush();
            byte[] bytes = out.toByteArray();
            return bytes;
        }
    }

    /**
     * 字节数组转对象
     */
    public static Object bytesToObject(byte[] bytes) throws IOException, ClassNotFoundException {
        try (
                ByteArrayInputStream in = new ByteArrayInputStream(bytes);
                ObjectInputStream sIn = new ObjectInputStream(in);
        ) {
            return sIn.readObject();
        }
    }
}

```



#### 总结

选择哪种方法取决于具体的业务需求和应用场景：

- 如果你的操作主要是基于数据库的CRUD，那么使用数据库唯一约束可能就足够了。
- 对于需要跨多个服务协调的情况，基于Token机制或者利用Redis等缓存技术可能是更好的选择。
- 分布式锁适用于更复杂的并发控制场景。

每种方法都有其适用范围和局限性，实际应用中可以根据项目的具体情况进行选择和组合使用。同时，也要注意处理好异常情况，确保系统的健壮性和用户体验。



### @DataScope部门权限控制

https://blog.csdn.net/m0_52134610/article/details/124122393

### 代理与反射

**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利

**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：[Java Reflection: Why is it so slow?](https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow)

#### JDK动态代理

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 1. 定义接口
interface GreetingService {
    void sayHello(String name);
}

// 2. 实现类
class GreetingServiceImpl implements GreetingService {
    @Override
    public void sayHello(String name) {
        System.out.println("Hello, " + name + "!");
    }
}

// 3. 创建 InvocationHandler
class LoggingInvocationHandler implements InvocationHandler {
    private final Object target; // 被代理的目标对象

    public LoggingInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在调用前添加日志
        System.out.println("Calling method: " + method.getName() + " with arguments: " + java.util.Arrays.toString(args));
        
        // 调用目标对象的实际方法
        Object result = method.invoke(target, args);
        
        // 在调用后添加日志
        System.out.println("Method " + method.getName() + " completed.");
        
        return result; // 返回结果
    }
}

// 4. 使用动态代理
public class DynamicProxyExample {
    public static void main(String[] args) {
        // 创建目标对象
        GreetingService realService = new GreetingServiceImpl();
        
        // 创建 InvocationHandler
        InvocationHandler handler = new LoggingInvocationHandler(realService);
        
        // 创建代理对象
        GreetingService proxyService = (GreetingService) Proxy.newProxyInstance(
            realService.getClass().getClassLoader(),
            realService.getClass().getInterfaces(),
            handler
        );
        
        // 通过代理对象调用方法
        proxyService.sayHello("Alice"); // 这会触发 LoggingInvocationHandler 的 invoke 方法
    }
}
```

#### CGLIB动态代理

好的，这是一个使用 CGLIB 实现动态代理的 Java 例子。

CGLIB (Code Generation Library) 是一个强大的、高性能的代码生成库。它可以在运行时扩展 Java 类和实现 Java 接口。与 JDK 动态代理（只能代理接口）不同，CGLIB 可以直接代理具体的类（通过生成子类）。

##### 添加依赖

首先，你需要在你的项目中添加 CGLIB 的依赖。如果你使用 Maven，可以在 `pom.xml` 中添加：

```xml
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version> <!-- 请检查是否有更新的版本 -->
</dependency>
```

如果你使用 Gradle，添加：

```groovy
implementation 'cglib:cglib:3.3.0'
```

##### 创建目标类 (被代理的类)

```java
// 这是一个具体的类，没有实现接口
public class UserService {
    public void saveUser(String name) {
        System.out.println("Saving user: " + name);
    }

    public String getUser(int id) {
        System.out.println("Fetching user with ID: " + id);
        return "User" + id;
    }

    // final 方法不能被 CGLIB 代理（因为子类无法重写）
    public final void finalMethod() {
        System.out.println("This is a final method, cannot be proxied.");
    }
}
```

##### 创建 MethodInterceptor (CGLIB 的拦截器)

CGLIB 使用 `MethodInterceptor` 接口来定义拦截逻辑，类似于 JDK 动态代理中的 `InvocationHandler`。

```java
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class LoggingMethodInterceptor implements MethodInterceptor {
    private final Object target; // 被代理的目标对象

    public LoggingMethodInterceptor(Object target) {
        this.target = target;
    }

    /**
     * 拦截对代理对象方法的调用
     * @param obj 生成的代理对象
     * @param method 被拦截的方法（来自父类）
     * @param args 方法参数
     * @param proxy 用于调用父类（即原始类）方法的 MethodProxy
     * @return 方法调用的返回值
     * @throws Throwable
     */
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 在方法调用前执行的逻辑 (前置通知)
        System.out.println("[CGLIB Proxy] Before calling method: " + method.getName() + 
                          " with arguments: " + java.util.Arrays.toString(args));

        // 执行原始方法
        // 注意：这里使用 proxy.invokeSuper(obj, args) 而不是 method.invoke(target, args)
        // 因为 obj 是代理对象，而 target 是原始对象。proxy.invokeSuper 会调用父类（即原始类）的方法。
        Object result = proxy.invokeSuper(obj, args);

        // 在方法调用后执行的逻辑 (后置通知)
        System.out.println("[CGLIB Proxy] After calling method: " + method.getName() + 
                          ", returned: " + result);

        return result;
    }
}
```

##### 创建代理工厂 (可选，但推荐用于封装)

```java
import net.sf.cglib.proxy.Enhancer;

public class CglibProxyFactory {
    /**
     * 创建目标对象的代理
     * @param target 要代理的目标对象
     * @param <T> 目标对象的类型
     * @return 代理对象
     */
    public static <T> T createProxy(T target) {
        // 创建 Enhancer 对象，它是 CGLIB 创建代理的核心类
        Enhancer enhancer = new Enhancer();
        
        // 设置要代理的类（父类）
        enhancer.setSuperclass(target.getClass());
        
        // 设置回调（即拦截器）
        enhancer.setCallback(new LoggingMethodInterceptor(target));
        
        // 创建并返回代理对象
        return (T) enhancer.create();
    }
}
```

##### 使用 CGLIB 代理

```java
public class CglibProxyExample {
    public static void main(String[] args) {
        // 1. 创建目标对象
        UserService userService = new UserService();

        // 2. 创建代理对象
        UserService proxyUserService = CglibProxyFactory.createProxy(userService);

        // 3. 通过代理对象调用方法
        System.out.println("=== Calling saveUser via proxy ===");
        proxyUserService.saveUser("Alice");

        System.out.println("\n=== Calling getUser via proxy ===");
        String user = proxyUserService.getUser(123);

        System.out.println("\n=== Result: " + user);

        // 尝试调用 final 方法（注意：final 方法不会被代理）
        System.out.println("\n=== Calling finalMethod (will NOT be proxied) ===");
        proxyUserService.finalMethod(); // 这个调用不会经过拦截器
    }
}
```

##### 运行结果

```
=== Calling saveUser via proxy ===
[CGLIB Proxy] Before calling method: saveUser with arguments: [Alice]
Saving user: Alice
[CGLIB Proxy] After calling method: saveUser, returned: null

=== Calling getUser via proxy ===
[CGLIB Proxy] Before calling method: getUser with arguments: [123]
Fetching user with ID: 123
[CGLIB Proxy] After calling method: getUser, returned: User123

=== Result: User123

=== Calling finalMethod (will NOT be proxied) ===
This is a final method, cannot be proxied.
```

##### 关键点说明

1.  **代理类**: CGLIB 通过继承目标类 (`UserService`) 创建一个子类（代理类）来实现代理。因此，被代理的类不能是 `final` 的，且要代理的方法也不能是 `final` 或 `private` 的（`private` 方法无法被继承重写）。
2.  **MethodInterceptor**: 这是 CGLIB 的核心接口，`intercept` 方法定义了拦截逻辑。
3.  **MethodProxy**: `proxy.invokeSuper(obj, args)` 是调用父类（即原始目标类）方法的推荐方式。避免在 `intercept` 方法中直接调用 `method.invoke(target, args)`，因为 `obj` 是代理对象，可能会导致无限递归或绕过代理逻辑。`invokeSuper` 会直接调用父类方法。
4.  **Enhancer**: CGLIB 的核心工具类，用于创建代理类和实例。
5.  **无接口限制**: 与 JDK 动态代理不同，CGLIB 可以代理没有实现任何接口的具体类。

这个例子展示了如何使用 CGLIB 为一个具体的类创建代理，并在方法调用前后添加日志记录功能。

#### 静态代理、JDK动态代理、CGLIB动态代理表格对比

| 特性/类型    | 静态代理                                       | JDK 动态代理                                                 | CGLIB 动态代理                                               |
| ------------ | ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **实现方式** | 手动创建代理类，需为每个服务接口编写一个代理类 | 使用 Java 反射机制，在运行时动态创建代理对象                 | 通过继承目标类生成子类实现代理                               |
| **性能**     | 编译期确定，运行时效率高                       | 每次调用都涉及反射，相对较低（但通常足够）                   | 相对较高，比JDK动态代理稍好一些                              |
| **适用场景** | 当代理逻辑不常变化时                           | **适合基于接口的代理**                                       | **适合于具体类，尤其是未实现接口的类**                       |
| **复杂度**   | 较低，易于理解和实现                           | 中等，涉及到反射机制                                         | 中等，需要额外库（CGLIB）                                    |
| **扩展性**   | 低，增加新功能需要修改或添加新的代理类         | **高，可以通过改变 InvocationHandler 实现来扩展，用Proxy来创建代理类** | **高，可以通过改变 MethodInterceptor 来扩展，用Enhancer创建代理类** |
| **使用限制** | 无特别限制                                     | 不能代理没有实现接口的类                                     | 不能代理 final 类或方法                                      |
| **主要用途** | 日志记录、访问控制等简单场景                   | AOP（面向切面编程）、事务管理等                              | AOP、延迟加载、模拟测试等                                    |

### BigDecimal

#### 使用注意事项

- 我们在使用 `BigDecimal` 时，为了防止精度丢失，推荐使用它的`BigDecimal(String val)`构造方法或者 `BigDecimal.valueOf(double val)` 静态方法来创建对象。禁止使用`BigDecimal(double val)`将double值转换为BigDecimal对象，因为会存在精度丢失风险。

- 我们使用 `divide` 方法的时候尽量使用 3 个参数版本，并且`RoundingMode` 不要选择 `UNNECESSARY`，否则很可能会遇到 `ArithmeticException`（无法除尽出现无限循环小数的时候），其中 `scale` 表示要保留几位小数，`roundingMode` 代表保留规则

  ```java
  public enum RoundingMode {
     // 2.4 -> 3 , 1.6 -> 2
     // -1.6 -> -2 , -2.4 -> -3
     UP(BigDecimal.ROUND_UP),
     // 2.4 -> 2 , 1.6 -> 1
     // -1.6 -> -1 , -2.4 -> -2
     DOWN(BigDecimal.ROUND_DOWN),
     // 2.4 -> 3 , 1.6 -> 2
     // -1.6 -> -1 , -2.4 -> -2
     CEILING(BigDecimal.ROUND_CEILING),
     // 2.5 -> 2 , 1.6 -> 1
     // -1.6 -> -2 , -2.5 -> -3
     FLOOR(BigDecimal.ROUND_FLOOR),
     // 2.4 -> 2 , 1.6 -> 2
     // -1.6 -> -2 , -2.4 -> -2
     HALF_UP(BigDecimal.ROUND_HALF_UP),
     //......
  }
  
  ```

- BigDecimal的等值比较应该使用compareTo()方法，不要使用equals()方法，因为equals()方法会比较值和精度（1.0与1.00返回结果为false），而compareTo()会忽略精度

#### BigDecimal工具类

```java
import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * 简化BigDecimal计算的小工具类
 */
public class BigDecimalUtil {

    /**
     * 默认除法运算精度
     */
    private static final int DEF_DIV_SCALE = 10;

    private BigDecimalUtil() {
    }

    /**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.add(b2).doubleValue();
    }

    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double subtract(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.subtract(b2).doubleValue();
    }

    /**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double multiply(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.multiply(b2).doubleValue();
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍六入五成双。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2) {
        return divide(v1, v2, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍六入五成双。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();
    }

    /**
     * 提供精确的小数位四舍六入五成双处理。
     *
     * @param v     需要四舍六入五成双的数字
     * @param scale 小数点后保留几位
     * @return 四舍六入五成双后的结果
     */
    public static double round(double v, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b = BigDecimal.valueOf(v);
        BigDecimal one = new BigDecimal("1");
        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
    }

    /**
     * 提供精确的类型转换(Float)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static float convertToFloat(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.floatValue();
    }

    /**
     * 提供精确的类型转换(Int)不进行四舍六入五成双
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static int convertsToInt(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.intValue();
    }

    /**
     * 提供精确的类型转换(Long)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static long convertsToLong(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.longValue();
    }

    /**
     * 返回两个数中大的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中大的一个值
     */
    public static double returnMax(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.max(b2).doubleValue();
    }

    /**
     * 返回两个数中小的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中小的一个值
     */
    public static double returnMin(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.min(b2).doubleValue();
    }

    /**
     * 精确对比两个数字
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
     */
    public static int compareTo(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.compareTo(b2);
    }

}
```

### Unsafe类

**为什么 `public static` 方法无法被直接调用呢？**

这是因为在`getUnsafe`方法中，会对调用者的`classLoader`进行检查，判断当前类是否由`Bootstrap classLoader`加载，如果不是的话那么就会抛出一个`SecurityException`异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用



**如若想使用 `Unsafe` 这个类的话，应该如何获取其实例呢？**

这里介绍两个可行的方案。

1. 利用反射获得 Unsafe 类中已经实例化完成的单例对象 `theUnsafe` 。

```
private static Unsafe reflectGetUnsafe() {
    try {
      Field field = Unsafe.class.getDeclaredField("theUnsafe");
      field.setAccessible(true);
      return (Unsafe) field.get(null);
    } catch (Exception e) {
      log.error(e.getMessage(), e);
      return null;
    }
}
```

2. 从`getUnsafe`方法的使用限制条件出发，通过 Java 命令行命令`-Xbootclasspath/a`把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过`Unsafe.getUnsafe`方法安全的获取 Unsafe 实例。



```
java -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径
```

您总结得非常准确！`sun.misc.Unsafe` 确实可以按功能划分为这 8 个核心类别。作为 Java 中最底层、最强大但也最危险的类，它直接操作内存和 JVM 底层机制，是许多高性能框架（如并发包、Netty、JDK 本身）的基石。

以下是对您分类的补充说明和关键点概括：

#### 🔧 `Unsafe` 功能分类详解

| 类别              | 核心功能                        | 典型方法                                                     | 说明与风险                                                   |
| ----------------- | ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 内存操作**   | 直接分配、读写、释放堆外内存    | `allocateMemory`, `reallocateMemory`, `freeMemory`, `putXxx`, `getXxx` | 绕过 JVM 垃圾回收，实现堆外内存管理（如 DirectByteBuffer）。**极易内存泄漏或越界访问**。 |
| **2. 内存屏障**   | 控制 CPU 指令重排序和内存可见性 | `loadFence`, `storeFence`, `fullFence`                       | 实现高性能无锁数据结构的内存顺序保证，替代 `volatile` 的部分语义。 |
| **3. 对象操作**   | 直接操作对象内存布局            | `objectFieldOffset`, `getObject`, `putObject`, `staticFieldOffset` | 获取字段偏移量，直接读写对象字段（即使 `private`），用于反射优化、序列化。 |
| **4. 数据操作**   | 批量内存复制/初始化             | `copyMemory`, `setMemory`                                    | 高效的内存拷贝（类似 C 的 `memcpy`），用于数组复制、缓冲区操作。 |
| **5. CAS 操作**   | 无锁原子更新                    | `compareAndSwapXxx`, `getAndAddXxx`, `getAndSetXxx`          | 实现 `AtomicInteger` 等原子类的核心，是 `java.util.concurrent` 包的基石。 |
| **6. 线程调度**   | 线程阻塞与唤醒                  | `park`, `unpark`                                             | 实现 `LockSupport`，是 `synchronized` 和 `ReentrantLock` 底层线程调度的基础。 |
| **7. Class 操作** | 动态类加载与初始化              | `defineClass`, `defineAnonymousClass`, `ensureClassInitialized` | 动态生成类（如动态代理）、延迟初始化类。                     |
| **8. 系统信息**   | 获取底层系统信息                | `addressSize`, `pageSize`                                    | 查询指针大小（32/64位）、内存页大小等 JVM/系统信息。         |

#### ⚠️ 重要注意事项

1.  **不安全 (Unsafe)**：正如其名，直接操作内存和底层机制，一旦使用不当会导致 JVM 崩溃、数据损坏、安全漏洞。
2.  **非标准 API**：`sun.misc.Unsafe` 属于 JDK 内部实现，**不保证跨版本兼容性**。从 Java 9 开始，模块化（JPMS）限制了对它的访问。
3.  **替代方案**：
    *   **Java 9+**：推荐使用 `VarHandle` (JEP 193) 替代大部分 CAS 和字段操作。
    *   **堆外内存**：使用 `ByteBuffer.allocateDirect()` 或 `Foreign Function & Memory API` (Java 17+)。
    *   **原子操作**：优先使用 `java.util.concurrent.atomic` 包下的类。
4.  **使用场景**：仅限于框架开发、性能极致优化、底层库开发。**普通业务代码严禁使用**。

#### ✅ 总结

您归纳的 8 个类别全面覆盖了 `Unsafe` 的核心能力。它本质上是 Java 提供给开发者的一把“双刃剑”：

*   **正面**：为高性能、低延迟的系统（如数据库、消息队列、JVM 本身）提供了必要的底层支持。
*   **反面**：破坏了 Java 的安全性、可移植性和封装性，应被严格限制使用。

现代 Java 正在通过 `VarHandle`、`MethodHandles`、`Foreign API` 等提供更安全、更标准的替代品，逐步取代 `Unsafe` 的角色。

### SPI机制详解

**SPI（Service Provider Interface）机制**是Java提供的一种服务发现机制，它允许第三方为某个接口提供实现而不改变原有的代码。通过SPI机制，开发者可以动态地发现和加载这些实现类，这在扩展功能或集成不同的服务提供商时非常有用。

#### SPI的基本概念

1. **服务接口**：这是你定义的一个接口或抽象类，其他开发者或你自己将为这个接口提供具体的实现。
2. **服务提供者**：指的是实现了上述接口的具体类。
3. **服务提供者配置文件**：位于 `META-INF/services/` 目录下，文件名为服务接口的全限定名，内容为该接口所有具体实现类的全限定名，每行一个实现类。

#### 使用步骤

1. **定义服务接口**

   首先需要定义一个接口或者抽象类，例如：

   ```java
   public interface HelloService {
       void sayHello();
   }
   ```

2. **实现服务接口**

   创建一个或多个实现了此接口的类。比如：

   ```java
   public class EnglishHelloService implements HelloService {
       @Override
       public void sayHello() {
           System.out.println("Hello!");
       }
   }

   public class ChineseHelloService implements HelloService {
       @Override
       public void sayHello() {
           System.out.println("你好！");
       }
   }
   ```

3. **创建服务提供者配置文件**

   在 `src/main/resources/META-INF/services/` 目录下创建一个以接口全限定名为名称的文件（如 `com.example.HelloService`），并在文件中列出所有实现类的全限定名，每个实现类占一行：

   ```
   com.example.EnglishHelloService
   com.example.ChineseHelloService
   ```

4. **使用ServiceLoader加载服务提供者**

   通过 `java.util.ServiceLoader` 来加载服务提供者并使用它们：

   ```java
   import java.util.ServiceLoader;
   
   public class SPIMain {
       public static void main(String[] args) {
           ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);
           for (HelloService service : loader) {
               service.sayHello();
           }
       }
   }
   ```

#### 注意事项

- **类路径**：确保所有的服务提供者及其配置文件都在同一个类路径下。
- **线程安全**：`ServiceLoader` 实例不是线程安全的，如果在多线程环境中使用，应该考虑同步访问。
- **延迟加载**：`ServiceLoader` 支持懒加载，即只有当调用迭代器的 `next()` 方法时才会加载下一个实现类。
- **默认实现**：如果你希望为某个服务提供一个默认实现，可以在配置文件中仅指定那个实现类。

#### 应用场景

- **数据库驱动程序**：JDBC API就是通过SPI机制来加载不同数据库厂商提供的驱动程序。
- **日志框架**：SLF4J等日志门面也利用了SPI机制来支持多种日志实现（如Logback、Log4j）。
- **模块化系统**：OSGi和Java 9+的模块系统也可以利用SPI来增强其模块化的灵活性。

SPI机制提供了一种灵活的方式来扩展应用程序的功能，并且不需要修改原有的代码结构，非常适合构建可插拔的应用程序架构。



当使用 `ServiceLoader` 在多线程环境中同时加载服务提供者时，确实可能会遇到并发问题。虽然 `ServiceLoader` 本身是线程安全的（因为它是不可变的，并且每次调用 `load` 方法都会返回一个新的实例），但是在迭代 `ServiceLoader` 实例的过程中，如果没有正确处理，仍然可能出现并发相关的问题。

#### 并发问题的具体情况

- **迭代器问题**：`ServiceLoader` 返回的迭代器并不是线程安全的。如果多个线程同时对同一个 `ServiceLoader` 实例进行迭代操作，可能会导致 `ConcurrentModificationException` 或其他不一致的状态。
- **初始化问题**：在某些情况下，`ServiceLoader` 的初始化可能涉及文件读取或其他 I/O 操作，这些操作在多线程环境下如果不加以控制，也可能引发问题。

#### 解决方案

为了确保在多线程环境中安全地使用 `ServiceLoader`，可以采取以下几种策略：

##### **同步访问**

如果你需要确保所有线程都以一种可控的方式访问 `ServiceLoader`，可以在访问 `ServiceLoader` 及其迭代器时使用同步块或方法。例如：

```java
import java.util.ServiceLoader;
import java.util.Iterator;

public class SafeSPIMain {
    private static final Object lock = new Object();
    private static ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);

    public static void main(String[] args) {
        Runnable task = () -> {
            synchronized (lock) {
                Iterator<HelloService> iterator = loader.iterator();
                while (iterator.hasNext()) {
                    HelloService service = iterator.next();
                    service.sayHello();
                }
            }
        };

        // 创建并启动多个线程来模拟并发访问
        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
    }
}
```

在这个例子中，我们通过一个共享锁对象 (`lock`) 来同步对 `ServiceLoader` 迭代器的访问，从而避免了并发修改的问题。

##### **提前加载和缓存结果**

另一种方法是在应用启动时预先加载所有的服务提供者并将它们存储在一个线程安全的数据结构中，比如 `CopyOnWriteArrayList`。这样，在后续的多线程操作中可以直接使用这个缓存列表而不需要再次加载 `ServiceLoader`。

```java
import java.util.ServiceLoader;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;

public class CachedSPIMain {
    private static List<HelloService> services;

    static {
        ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);
        services = new CopyOnWriteArrayList<>();
        loader.forEach(services::add);
    }

    public static void main(String[] args) {
        Runnable task = () -> {
            for (HelloService service : services) {
                service.sayHello();
            }
        };

        // 创建并启动多个线程来模拟并发访问
        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
    }
}
```

这里，我们在静态初始化块中一次性加载所有的服务提供者，并将它们添加到 `CopyOnWriteArrayList` 中。由于 `CopyOnWriteArrayList` 是线程安全的，所以可以放心地在多个线程之间共享和使用它。

##### 使用并发集合

如果需要动态地添加或移除服务提供者，可以考虑使用其他的线程安全集合，如 `ConcurrentHashMap` 来管理服务提供者的引用。

##### 为每个线程创建独立的 ServiceLoader 实例

考虑到 `ServiceLoader` 实例本身是不可变的，因此为每个线程创建独立的 `ServiceLoader` 实例也是一种可行的方法。这可以通过使用 `ThreadLocal` 来实现：

```java
import java.util.ServiceLoader;
import java.util.Iterator;

public class ThreadLocalSPIMain {
    private static ThreadLocal<ServiceLoader<HelloService>> loaderHolder = ThreadLocal.withInitial(() -> 
        ServiceLoader.load(HelloService.class)
    );

    public static void main(String[] args) {
        Runnable task = () -> {
            ServiceLoader<HelloService> loader = loaderHolder.get();
            Iterator<HelloService> iterator = loader.iterator();
            while (iterator.hasNext()) {
                HelloService service = iterator.next();
                service.sayHello();
            }
        };

        // 创建并启动多个线程来模拟并发访问
        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
    }
}
```

这种方法确保了每个线程都有自己的 `ServiceLoader` 实例，从而避免了并发访问的问题。

选择哪种方法取决于你的具体需求和应用场景。对于大多数情况，预加载和缓存服务提供者可能是最简单和最有效的解决方案。然而，在某些特定场景下，你可能需要更复杂的机制来管理服务提供者的生命周期和状态。



### 为什么HashMap扩容选择2的幂次方

1. **简化哈希计算**：使用2的幂次方作为容量大小，可以使得哈希值到桶索引的转换更加高效。具体来说，通过位运算 `hash & (capacity - 1)` 可以快速地找到对应的桶位置，这比取模运算 `%` 更加高效。因为当容量是2的幂次方时，`capacity - 1` 的二进制表示全是1（例如，容量为8时，`capacity - 1` 是7，即二进制的 `0111`），这样与操作可以直接保留哈希值的有效位数作为桶索引。
2. **均匀分布**：将容量设置为2的幂次方有助于减少哈希碰撞的概率，从而达到更好的分散效果。虽然理论上好的哈希函数应该独立于容量大小来保证均匀分布，但在实践中，使用2的幂次方可以帮助更有效地利用空间，尤其是在哈希函数不是特别理想的情况下。
3. **动态调整**：由于容量必须是2的幂次方，所以每次扩容都是成倍增长的（比如从16增加到32）。这种设计允许HashMap在不知道确切的最大容量需求的情况下，依然能够高效地管理内存和性能。它确保了即使在多次扩容后，仍然能够维持较高的性能水平。
4. **避免浪费空间**：如果容量不是2的幂次方，则可能无法充分利用所有桶。例如，如果容量是一个奇数，那么某些模式的哈希值可能会倾向于映射到特定的桶上，导致这些桶过早填满，而其他桶则几乎为空。通过使用2的幂次方作为容量，可以确保每个桶被均匀填充，最大化存储效率。

- JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过扰动函数处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

- JDK8的hash方法比JDK7的hash方法效率更高

### ConcurrentHashMap实现现成安全的方式

- 在 JDK1.7 的时候，`ConcurrentHashMap` 对整个桶数组进行了分割分段(`Segment`，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。

- 到了 JDK1.8 的时候，`ConcurrentHashMap` 已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

- **`Hashtable`(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

### 不要使用Collections.synchronizedXxx()方法

`Collections` 提供了多个`synchronizedXxx()`方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。

我们知道 `HashSet`，`TreeSet`，`ArrayList`,`LinkedList`,`HashMap`,`TreeMap` 都是线程不安全的。`Collections` 提供了多个静态方法可以把他们包装成线程同步的集合。

最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。

### 尽量不要使用Arrays.asList()

`Arrays.asList()` 是一个非常方便的工具方法，可以将数组快速转换为 `List`。然而，尽管它很常用，但在很多场景下确实**不推荐直接使用**，主要原因如下：

---

### ⚠️ 主要问题：返回的 `List` 是**固定大小**且**不支持所有 `List` 操作**

`Arrays.asList()` 返回的是 `java.util.Arrays` 类的一个私有静态内部类 `ArrayList`（注意：**不是** `java.util.ArrayList`！）。

这个内部类有以下几个关键限制：

#### 1. **不能添加元素 (`add`)**
   ```java
   String[] array = {"a", "b", "c"};
   List<String> list = Arrays.asList(array);
   list.add("d"); // 抛出 java.lang.UnsupportedOperationException
   ```

#### 2. **不能删除元素 (`remove`)**
   ```java
   list.remove("a"); // 抛出 java.lang.UnsupportedOperationException
   ```

#### 3. **不能清空 (`clear`)**
   ```java
   list.clear(); // 抛出 java.lang.UnsupportedOperationException
   ```

#### 4. **但可以修改元素 (`set`)**
   ```java
   list.set(0, "x"); // ✅ 这是允许的，会修改原始数组
   System.out.println(Arrays.toString(array)); // 输出: [x, b, c] (原始数组也被改了！)
   ```
   **注意**：因为返回的 `List` 直接“背靠”原始数组，所以 `set` 操作会**直接修改原始数组**。

---

### 📌 为什么会有这些限制？

*   这个内部 `ArrayList` 类没有重写 `add`, `remove`, `clear` 等方法，它们继承自 `AbstractList`，而 `AbstractList` 中这些方法默认抛出 `UnsupportedOperationException`。
*   它只实现了 `get`, `set`, `size` 等基于索引访问和修改的方法，因为它本质上是对**固定大小**的底层数组的一个视图（View）。

#### 🚫 使用 `Arrays.asList()` 的陷阱场景

1.  **误以为可以修改**：开发者可能误以为得到了一个标准的 `ArrayList`，尝试添加或删除元素，导致运行时异常。
2.  **与原始数组耦合**：对 `List` 的 `set` 操作会直接影响原始数组，反之亦然，这可能导致意外的副作用。
3.  **传递给需要可变 `List` 的方法**：如果将 `Arrays.asList()` 的结果传递给一个期望能 `add` 或 `remove` 元素的方法，该方法会崩溃。



### fail-fast与fail-safe

`fail-fast`（快速失败）和 `fail-safe`（安全失败）是描述在遍历集合（Collection）的同时对集合进行修改时，迭代器（Iterator）行为的两种策略。

它们主要用来处理**并发修改异常**（`ConcurrentModificationException`）的问题。

#### Fail-Fast (快速失败)

*   **定义**：`fail-fast` 迭代器在设计上假设在迭代过程中**不会**有其他线程或代码修改集合。如果检测到集合在迭代期间被结构性修改（如添加、删除、清空元素），它会立即抛出 `ConcurrentModificationException` 异常，而不是让迭代继续进行，从而“快速失败”。
*   **目的**：尽早发现问题，避免在数据不一致的状态下继续执行，可能导致更隐蔽、更难调试的错误。
*   **实现原理**：
    *   集合类（如 `ArrayList`, `HashMap`）内部维护一个 `modCount`（修改计数器）。
    *   每当集合发生结构性修改时，`modCount` 就会递增。
    *   当创建一个 `fail-fast` 迭代器时，它会记录下当前的 `modCount` 值（通常称为 `expectedModCount`）。
    *   在迭代器的 `next()`、`remove()` 等方法被调用时，会检查当前集合的 `modCount` 是否等于 `expectedModCount`。如果不相等，说明集合被修改了，立即抛出 `ConcurrentModificationException`。
*   **典型实现**：
    *   `java.util` 包下的大部分非线程安全集合的迭代器，如 `ArrayList.Itr`, `HashMap$HashIterator` 等。
*   **示例**：
    ```java
    List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
    for (String s : list) {
        if ("b".equals(s)) {
            list.remove(s); // 在迭代中直接修改集合！
        }
    }
    // 结果：抛出 ConcurrentModificationException
    ```
*   **注意**：`fail-fast` 不是绝对保证的。它依赖于 `modCount` 的检查，而某些操作（如 `ListIterator.set()`）可能不会改变 `modCount`，因此不会触发异常。它只提供**尽力的检测**，不能用于构建依赖此行为的程序。



#### Fail-Safe (安全失败)

*   **定义**：`fail-safe` 迭代器通过创建集合的一个**快照**（Snapshot）或在**副本**上进行迭代，从而确保迭代过程不会受到原始集合修改的影响。即使原始集合在迭代期间被修改，迭代器也不会抛出 `ConcurrentModificationException`，并且迭代器看到的是迭代开始时集合的状态。
*   **目的**：提供一种在多线程环境下安全遍历集合的方式，保证迭代过程的稳定性和一致性。
*   **实现原理**：
    *   迭代器在创建时，会复制一份当前集合的数据（或其引用）。
    *   后续的遍历操作都在这个副本上进行，与原始集合的修改完全隔离。
*   **典型实现**：
    *   `java.util.concurrent` 包下的某些集合，如 `CopyOnWriteArrayList` 和 `CopyOnWriteArraySet` 的迭代器。
    *   `ConcurrentHashMap` 的迭代器也提供弱一致性保证（Weakly Consistent），虽然它不完全是 `Copy-On-Write`，但其迭代器也不会抛出 `ConcurrentModificationException`，并且能看到迭代开始后某些更新（但不保证看到所有更新），行为上更接近 `fail-safe`。
*   **示例**：
    ```java
    List<String> list = new CopyOnWriteArrayList<>(Arrays.asList("a", "b", "c"));
    for (String s : list) {
        if ("b".equals(s)) {
            list.remove(s); // 在迭代中修改原始集合
        }
        System.out.println(s); // 仍然会打印 a, b, c
    }
    // 结果：不会抛出异常，但删除操作对当前迭代器不可见。
    // 注意：迭代器看到的是创建时的快照，所以还是会遍历所有原始元素。
    ```
*   **优缺点**：
    *   **优点**：迭代安全，不会因并发修改而失败。
    *   **缺点**：
        1.  **内存开销**：创建副本需要额外的内存空间，尤其是对于大集合。
        2.  **性能开销**：创建副本本身有性能成本。
        3.  **数据陈旧**：迭代器看到的是快照，无法反映迭代开始后对原始集合的修改（如新添加的元素）。

#### 对比总结

| 特性                                           | Fail-Fast (快速失败)                                         | Fail-Safe (安全失败)                                         |
| :--------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **行为**                                       | 检测到并发修改时立即抛出 `ConcurrentModificationException`   | 允许并发修改，迭代在副本上进行，不抛出异常                   |
| **迭代器基础**                                 | 直接引用原始集合                                             | 基于原始集合的快照或副本                                     |
| **是否抛出 `ConcurrentModificationException`** | 是                                                           | 否                                                           |
| **内存开销**                                   | 低                                                           | 高 (需要复制数据)                                            |
| **性能开销**                                   | 低                                                           | 高 (复制成本)                                                |
| **数据一致性**                                 | 迭代过程数据可能不一致（如果没检测到）                       | 迭代过程数据一致（基于快照）                                 |
| **反映最新修改**                               | 可能反映，也可能导致异常                                     | 通常不反映迭代开始后的修改                                   |
| **典型集合**                                   | `ArrayList`, `HashMap`, `HashSet`, `TreeSet` 等 (`java.util`) | `CopyOnWriteArrayList`, `CopyOnWriteArraySet` (`java.util.concurrent`) |
| **适用场景**                                   | 单线程环境，或能确保遍历时无修改的多线程环境                 | 需要安全遍历且能接受数据陈旧和开销的多线程环境               |

**简单记忆**：
*   **Fail-Fast**： “你敢改，我立马报错！” (快，但可能崩)
*   **Fail-Safe**： “你改你的，我按我的老地图走。” (稳，但可能过时)

### 异或的妙用

`^` 是**异或（XOR）**运算符，在编程和逻辑运算中是一个非常重要的位运算操作。下面我们来详细讲解它的含义、性质和常见用途。

#### 🔹 什么是异或（XOR）？

异或是一种**二进制逻辑运算**，规则如下：

| A    | B    | A ^ B |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 0    | 1    | 1     |
| 1    | 0    | 1     |
| 1    | 1    | 0     |

👉 **总结：相同为 0，不同为 1**

#### 🔹 异或的重要性质

1. **自反性（A ^ A = 0）**  
   任何数与自己异或结果为 0。  
   例如：`5 ^ 5 = 0`

2. **零元（A ^ 0 = A）**  
   任何数与 0 异或，结果还是它自己。  
   例如：`5 ^ 0 = 5`

3. **可交换性（A ^ B = B ^ A）**

4. **可结合性（A ^ B ^ C = (A ^ B) ^ C = A ^ (B ^ C)）**

5. **可逆性（用于加密、交换等）**  
   如果 `c = a ^ b`，那么 `a = c ^ b`，`b = c ^ a`

#### 🔹 常见应用场景

##### ✅ 1. **交换两个变量（不使用临时变量）**

```c
int a = 5, b = 3;
a ^= b;
b ^= a;
a ^= b;
// 此时 a = 3, b = 5
```
> ⚠️ 注意：当 `a` 和 `b` 是同一变量时（如 `a ^= a`），结果会变为 0，导致数据丢失！

##### ✅ 2. **找出数组中唯一出现一次的数**

> 题目：一个数组中，所有元素都出现两次，只有一个元素出现一次，找出它。

```c
int findSingle(int arr[], int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        result ^= arr[i];  // 成对的会抵消为0，剩下的就是唯一的数
    }
    return result;
}
```
> 利用了 `a ^ a = 0` 和 `a ^ 0 = a` 的性质。

##### ✅ 3. **数据加密与解密（简单异或加密）**

```c
char data = 'A';
char key = 0x0F;

// 加密
char encrypted = data ^ key;

// 解密（再次异或同一个密钥）
char decrypted = encrypted ^ key;  // 又得到 'A'
```
> 因为 `(A ^ K) ^ K = A`，所以异或常用于简单加密。

##### ✅ 4. **判断两个数是否同号**

```c
int a = -5, b = -3;
if ((a ^ b) >= 0) {
    printf("同号");
} else {
    printf("异号");
}
```
> 原理：符号位相同 → 异或后符号位为 0（正数）；符号位不同 → 异或后符号位为 1（负数）

##### ✅ 5. **位翻转（toggle 某一位）**

```c
int flags = 0b1010;
int mask = 0b0010;

flags ^= mask;  // 第2位被翻转（1→0）
flags ^= mask;  // 再次翻转（0→1），可逆！
```

#### 🔹 小结

| 特性                 | 说明                   |
| -------------------- | ---------------------- |
| `a ^ a = 0`          | 自己异或自己等于 0     |
| `a ^ 0 = a`          | 异或 0 不变            |
| `a ^ b ^ a = b`      | 可用于交换、查找唯一数 |
| 可逆、可交换、可结合 | 数学性质强大           |

---

✅ **建议**：异或是一个强大而优雅的工具，尤其在**位操作、算法题、加密**中非常常见。理解其原理有助于写出高效、巧妙的代码。

### PriorityQueue和TreeSet

`PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。

`TreeSet` 和 `PriorityQueue` 都是 Java 集合框架的一部分，它们都能对元素进行排序，但它们的设计目的、内部实现和使用场景有着显著的区别。

#### TreeSet

- **数据结构**：基于红黑树（一种自平衡的二叉查找树）实现。
- **排序方式**：根据元素的自然顺序或者在创建时提供的 `Comparator` 进行排序。它保证了集合中的元素是唯一且有序的。
- **线程安全性**：不是线程安全的。如果需要在多线程环境中使用，可以考虑使用 `Collections.synchronizedSortedSet` 方法来包装 `TreeSet` 实例。
- **操作特性**：支持高效的插入、删除和访问操作，时间复杂度为 O(log n)。此外，`TreeSet` 提供了诸如 `higher`, `lower`, `ceiling`, `floor` 等方法，方便范围查询。
- **不允许 null 元素**：对于大多数实现了 `Comparable` 接口的对象类型来说，`TreeSet` 不允许插入 `null` 值，因为无法比较 `null`。

#### PriorityQueue

- **数据结构**：基于优先级堆（通常是一个二叉堆）实现。
- **排序方式**：根据元素的自然顺序或者在创建时提供的 `Comparator` 来确定优先级。与 `TreeSet` 不同，`PriorityQueue` 可以包含重复的元素。
- **线程安全性**：不是线程安全的。对于多线程环境下的使用，需要额外的同步处理。
- **操作特性**：队列头部是最小（或最大，取决于构造函数）的元素。提供 `poll()` 方法用于移除并返回队列头部的元素，`peek()` 用于查看头部元素而不移除它。插入和移除操作的时间复杂度为 O(log n)，而获取最小/最大元素的操作时间复杂度为 O(1)。
- **允许 null 元素**：`PriorityQueue` 不允许插入 `null` 值，因为在没有指定 `Comparator` 的情况下，`null` 不能被比较。

#### 主要区别

- **元素唯一性**：`TreeSet` 中的元素必须是唯一的，而 `PriorityQueue` 可以包含重复的元素。
- **接口和功能**：`TreeSet` 实现了 `NavigableSet` 接口，提供了丰富的导航方法；`PriorityQueue` 则实现了 `Queue` 接口，专注于高效地访问最高优先级的元素。
- **性能特征**：虽然两者都提供对数时间复杂度的插入和删除操作，但 `TreeSet` 更适合需要频繁进行范围查询的场景，而 `PriorityQueue` 更适用于需要快速访问最小或最大元素的情况。 

因此，选择 `TreeSet` 还是 `PriorityQueue` 应该基于你的具体需求，包括是否需要元素唯一性、是否需要进行范围查询等。



### 阻塞队列

Java 中常用的阻塞队列实现类有以下几种：

1. `ArrayBlockingQueue`：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。
2. `LinkedBlockingQueue`：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为`Integer.MAX_VALUE`。和`ArrayBlockingQueue`不同的是， 它仅支持非公平的锁访问机制。
3. `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列。元素必须实现`Comparable`接口或者在构造函数中传入`Comparator`对象，并且不能插入 null 元素。
4. `SynchronousQueue`：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，`SynchronousQueue`通常用于线程之间的直接传递数据。
5. `DelayQueue`：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。

### HashMap

- JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过扰动函数处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

- `HashMap` 中的扰动函数（`hash` 方法）是用来优化哈希值的分布。通过对原始的 `hashCode()` 进行额外处理，扰动函数可以减小由于糟糕的 `hashCode()` 实现导致的碰撞，从而提高数据的分布均匀性。

### ConcurrentHashMap

- 在 JDK1.7 的时候，`ConcurrentHashMap` 对整个桶数组进行了分割分段(`Segment`，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。

- 到了 JDK1.8 的时候，`ConcurrentHashMap` 已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

- **`Hashtable`(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。
- jdk8的锁粒度相对最小

### null的支持情况表格对比

> 多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。
>
> 
>
> ```
> public static final Object NULL = new Object();
> ```
>
> 作者本人 (Doug Lea)对于这个问题的回答：大致意思还是单线程下可以容忍歧义，而多线程下无法容忍。

| 集合类型       | 实现类                | 支持null键 | 支持null值 | 备注                                                         |
| -------------- | --------------------- | ---------- | ---------- | ------------------------------------------------------------ |
| **Collection** | ArrayList             | N/A        | 是         | 作为列表，只涉及值（元素）的存储。                           |
|                | LinkedList            | N/A        | 是         | 同上。                                                       |
|                | HashSet               | N/A        | 是         | 不保证顺序，允许一个null元素。                               |
|                | **TreeSet**           | N/A        | 否         | 根据自然顺序或提供的Comparator排序，不允许null元素。         |
|                | LinkedHashSet         | N/A        | 是         | 维护插入顺序，允许一个null元素。                             |
| **Map**        | HashMap               | 是         | 是         | 允许一个null键和多个null值。                                 |
|                | **TreeMap**           | 否         | 是         | 根据自然顺序或提供的Comparator排序，不允许null键但允许null值。 |
|                | LinkedHashMap         | 是         | 是         | 维护插入顺序，允许一个null键和多个null值。                   |
|                | **Hashtable**         | 否         | 否         | 不允许null键和null值，线程安全。                             |
|                | **ConcurrentHashMap** | 否         | 否         | 不允许null键和null值，适用于高并发环境。                     |

### 常见Collections方法

#### 排序

```java
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面
```

#### 查找替换

- binarySearch可以秒了二分查找
- indexOfSubList可以秒了KMP查找串，但是底层不是用的KMP算法，有O(m*n)的复杂度

```java
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素
```

#### 同步控制(了解)

```java
synchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。
synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。
synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。
```

### Java集合使用注意事项总结

1. 判断所有集合内部的元素是否为空，使用 `isEmpty()` 方法，而不是 `size()==0` 的方式。

2. 在使用 `java.util.stream.Collectors` 类的 `toMap()` 方法转为 `Map` 集合时，一定要注意当 key/value 为 null 时会抛 NPE 异常。
3. 集合遍历的时候不要remove/add，否则会发生`ConcurrentModificationException` 来提示用户发生了并发修改异常。这就是单线程状态下产生的 **fail-fast 机制**
4. 集合转数组使用`toArray(T[] array)` 方法的参数是一个泛型数组，如果 `toArray` 方法中没有传递任何参数的话返回的是 `Object`类 型数组。
5. 数组转集合使用`List list = new ArrayList<>(Arrays.asList("a", "b", "c"))`

### `Arrays.copyOf()`方法和`System.arraycopy()` 方法



```java
 		/**
     * 在此列表中的指定位置插入指定的元素。
     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //arraycopy()方法实现数组自己复制自己
        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；
        System.arraycopy(elementData, index, elementData, index + 1, size - index);
        elementData[index] = element;
        size++;
    }  

		public static int[] copyOf(int[] original, int newLength) {
      	// 申请一个新的数组
        int[] copy = new int[newLength];
  			// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    }
```

### LinkedHashMap与LRU

#### LinkedHashMap

`LinkedHashMap` 定义了排序模式 `accessOrder`(boolean 类型，默认为 false)，访问顺序则为 true，插入顺序则为 false。

为了实现访问顺序遍历，我们可以使用传入 `accessOrder` 属性的 `LinkedHashMap` 构造方法，并将 `accessOrder` 设置为 true，表示其具备访问有序性。



```java
LinkedHashMap<Integer, String> map = new LinkedHashMap<>(16, 0.75f, true);
map.put(1, "one");
map.put(2, "two");
map.put(3, "three");
map.put(4, "four");
map.put(5, "five");
//访问元素2,该元素会被移动至链表末端
map.get(2);
//访问元素3,该元素会被移动至链表末端
map.get(3);
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " : " + entry.getValue());
}
```

#### LRU

具体实现思路如下：

- 继承 `LinkedHashMap`;
- 构造方法中指定 `accessOrder` 为 true ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；
- 重写`removeEldestEntry` 方法，该方法会返回一个 boolean 值，告知 `LinkedHashMap` 是否需要移除链表首元素（缓存容量有限）。



```java
class LRUCache extends LinkedHashMap<Integer,Integer>{
    int capacity;
    public LRUCache(int capacity) {
        super(capacity,0.75F,true);
        this.capacity=capacity;
    }
    
    public int get(int key) {
        return super.getOrDefault(key,-1);
    }
    
    public void put(int key, int value) {
        super.put(key,value);
    }
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity; 
    }

}
```

### CopyOnWriteList

这里再以 `CopyOnWriteArrayList`为例介绍：当需要修改（ `add`，`set`、`remove` 等操作） `CopyOnWriteArrayList` 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。

可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能。

不过，写时复制机制并不是银弹，其依然存在一些缺点，下面列举几点：

1. 内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。
2. 写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。
3. 数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。

好的，已将您提供的关于 `ArrayBlockingQueue` 和 `LinkedBlockingQueue` 的对比内容整理成清晰的表格：

### **`ArrayBlockingQueue` 与 `LinkedBlockingQueue` 对比**

| 对比维度     | `ArrayBlockingQueue`                                         | `LinkedBlockingQueue`                                        |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **底层实现** | 基于**数组**实现。                                           | 基于**链表**（单向或双向链表）实现。                         |
| **队列边界** | **有界队列**。创建时必须指定容量大小，且容量不可变。         | **可选有界**。创建时可以不指定容量，默认容量为 `Integer.MAX_VALUE`（**无界**）；也可以指定容量，成为**有界队列**。 |
| **锁机制**   | **锁未分离**。生产和消费操作共用**同一个锁** (`ReentrantLock`)。同一时间只能有一个线程（生产者或消费者）进行操作。 | **锁分离**。生产操作使用 `putLock`，消费操作使用 `takeLock`。生产者和消费者可以**并发**执行（一个生产者和一个消费者可以同时操作队列），减少了锁竞争。 |
| **内存占用** | **预先分配**。创建时即分配固定大小的数组内存。内存占用**固定**，但可能存在**空间浪费**（数组可能未填满）。 | **动态分配**。内存随元素的增加而动态分配（每个节点一个对象）。内存占用**更灵活**，按需增长，但每个节点有额外的对象开销（如指针、对象头）。 |
| **性能特点** | 数组操作效率高（缓存友好），但锁竞争可能成为瓶颈（尤其在高并发生产消费场景）。 | 链表操作开销略高，但锁分离机制在高并发下通常能提供**更好的吞吐量**。无界模式下需警惕内存溢出风险。 |
| **适用场景** | 适用于对**内存使用有严格限制**、且可以预估队列最大容量的场景。 | 适用于**高并发**生产消费场景，或队列大小难以预估的场景（使用其无界特性时需谨慎，防止 `OutOfMemoryError`）。 |

> **总结**：`ArrayBlockingQueue` 是一个简单、内存占用可控的有界阻塞队列，但锁竞争可能限制其并发性能。`LinkedBlockingQueue` 通过链表和锁分离机制提供了更高的并发吞吐量和灵活性（可选有界/无界），是更常用的高性能选择，但需注意其潜在的内存开销和无界队列的风险。

好的，已将您提供的关于 `ArrayBlockingQueue` 和 `ConcurrentLinkedQueue` 的对比内容整理成清晰的表格：

### **`ArrayBlockingQueue` 与 `ConcurrentLinkedQueue` 对比**

| 对比维度         | `ArrayBlockingQueue`                                         | `ConcurrentLinkedQueue`                                      |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **底层实现**     | 基于**数组**实现。                                           | 基于**链表**（无锁的单向链表）实现。                         |
| **队列边界**     | **有界队列**。创建时必须指定**固定容量**，队列满时无法再入队。 | **无界队列**。容量可以**动态增长**，理论上只受内存限制。     |
| **是否阻塞**     | **阻塞队列**。当队列满时，`put()` 操作会**阻塞**等待；当队列空时，`take()` 操作会**阻塞**等待。也提供非阻塞的 `offer()` 和 `poll()` 方法。 | **非阻塞队列**。所有操作（`add()`, `offer()`, `poll()`, `peek()`）都是**立即返回**的，不会阻塞线程。如果队列为空，`poll()` 返回 `null`。 |
| **线程安全机制** | 使用**显式锁** (`ReentrantLock`) 来保证线程安全。            | 使用**无锁算法**（基于 `CAS` - Compare-And-Swap）实现线程安全，通常在高并发下性能更好。 |
| **内存占用**     | 创建时即分配固定大小的数组内存，内存占用**固定**。           | 内存随元素增加**动态分配**，每个节点有额外的对象开销。       |
| **适用场景**     | 适用于需要**控制队列大小**、生产者和消费者速度差异较大、且需要**阻塞等待**的场景（如经典的生产者-消费者模型）。 | 适用于**高并发**、**读写频繁**、**不需要阻塞**、且队列大小难以预估的场景。对性能要求极高且能接受无界风险的场景。 |

> **总结**：`ArrayBlockingQueue` 是一个**有界阻塞**队列，通过锁机制保证安全，适用于需要流量控制和阻塞同步的场景。`ConcurrentLinkedQueue` 是一个**无界非阻塞**队列，采用无锁算法，适用于追求极致并发性能、不需要阻塞且能管理好内存风险的场景。两者的设计目标和适用场景有显著区别。

### DelayQueue

`DelayQueue` 是 JUC 包(`java.util.concurrent)`为我们提供的延迟队列，用于实现延时任务比如订单下单 15 分钟未支付直接取消。它是 `BlockingQueue` 的一种，底层是一个基于 `PriorityQueue` 实现的一个无界队列，是线程安全的

### 死锁

死锁的四个必要条件（背了一辈子没记住）：

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系。

使用`jmap`、`jstack`等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:`的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用`top`、`df`、`free`等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。

采用 VisualVM、JConsole 等工具进行排查。

### 手写线程安全的单例模式

**双重校验锁实现对象单例（线程安全）**：



```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

`uniqueInstance` 采用 `volatile` 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：

1. 为 `uniqueInstance` 分配内存空间
2. 初始化 `uniqueInstance`
3. 将 `uniqueInstance` 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 `getUniqueInstance`() 后发现 `uniqueInstance` 不为空，因此返回 `uniqueInstance`，但此时 `uniqueInstance` 还未被初始化。

### 读锁不能升级为写锁

在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。

在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。

写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。

另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。

### ReentrantLock

`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承 AQS（`AbstractQueuedSynchronizer`），添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。

#### 实现轮询

**使用 `tryLock()` 方法**：

- 这个方法会立即尝试获取锁，并立即返回结果（成功或失败）。如果锁已经被其他线程持有，则此方法将立即返回 `false`。
- 开发者可以通过循环调用 `tryLock()` 来模拟轮询机制，直到成功获取到锁为止。这种模式允许你自定义重试逻辑、添加延迟等，以避免过于频繁的尝试对系统性能造成影响。

```java
ReentrantLock lock = new ReentrantLock();

while (true) {
    if (lock.tryLock()) {
        try {
            // 获取到锁后执行的操作
            break;
        } finally {
            lock.unlock();
        }
    } else {
        // 没有获取到锁时的处理逻辑
        System.out.println("Lock not available, retrying...");
        // 可以在这里添加延迟来减少CPU占用
        try {
            Thread.sleep(100); // 延迟100毫秒
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // 恢复中断状态
            break;
        }
    }
}
```

**使用 `tryLock(long timeout, TimeUnit unit)` 方法**：

- 这个方法允许你在指定的时间内尝试获取锁。如果在规定时间内无法获取到锁，它将返回 `false`。
- 使用这种方法可以在一定程度上减少资源的竞争，并且可以根据超时情况采取不同的策略（如重试、记录日志或抛出异常）。

```java
ReentrantLock lock = new ReentrantLock();

boolean acquiredLock = false;
try {
    acquiredLock = lock.tryLock(500, TimeUnit.MILLISECONDS);
    if (acquiredLock) {
        // 成功获取锁后的操作
    } else {
        // 超时未获取到锁时的处理逻辑
        System.out.println("Failed to acquire lock within the specified time.");
    }
} catch (InterruptedException e) {
    // 处理中断请求
    Thread.currentThread().interrupt(); // 恢复中断状态
} finally {
    if (acquiredLock) {
        lock.unlock();
    }
}
```



## 算法

> ACM模式要熟悉，注意报错位置提示

### 数组

> 1. 要用栈或者队列的时候，`ArrayDeque<Character> deque=new ArrayDeque<>();`
>
>    - `offerLast()` `pollLast`就是栈
>
>    - `offerLast()` `pollFirst`就是队列
>
>    - 用`pop()`，因为栈顶为空时候会抛异常，用之前要判断stack不为空
>
> 2. 左右指针`left`和`right`,`mid=left+((right-left)>>1)`
>
> 3. 前后指针`pre`和`cur`，一般都从0开始

- [x] [704.二分查找](https://leetcode.cn/problems/binary-search/)
- [x] [35.搜索插入位置](https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html)
- [x] [34.在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html)
- [x] [69.x 的平方根](https://leetcode.cn/problems/sqrtx/)
- [x] [367.有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)
- [x] [27.移除元素](https://leetcode.cn/problems/remove-element/)
- [x] [26.删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
- [x] [283.移动零](https://leetcode.cn/problems/move-zeroes/)
- [x] [844.比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)
- [x] [977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)
- [x] [209.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
- [x] [904.水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)【滑动窗口，重点】
- [x] [76.最小覆盖子串(opens new window)](https://leetcode.cn/problems/minimum-window-substring/)【滑动窗口】
- [x] [59.螺旋矩阵二](https://leetcode.cn/problems/spiral-matrix-ii/)
- [x] [54.螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
- [x] [剑指Offer 29.顺时针打印矩阵(opens new window)](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)
- [x] [58.区间和](https://kamacoder.com/problempage.php?pid=1070)
- [x] [44.开发商购买土地](https://kamacoder.com/problempage.php?pid=1044)【前缀和】

### 链表

- [x] [203.移除链表](https://leetcode.cn/problems/remove-linked-list-elements/)
- [x] [707.设计链表](https://leetcode.cn/problems/design-linked-list/)【虚拟头结点，用length记录链表长度比较好判断是否越界】
- [x] [206.反转链表](https://leetcode.cn/problems/reverse-linked-list/)
- [x] [24.两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)
- [x] [19.删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)【提前移动n+1个位置】
- [x] [160.链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)【拼接列表】
- [x] [142.环形列表二](https://leetcode.cn/problems/linked-list-cycle-ii/)【快慢指针】

### 哈希表

- [x] [242.有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)
- [x] [349.两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)
- [x] [202.快乐数](https://leetcode.cn/problems/happy-number/)
- [x] [1.两数之和](https://leetcode.cn/problems/two-sum/)
- [x] [454.四数相加二](https://leetcode.cn/problems/4sum-ii/)
- [x] [383.赎金信](https://leetcode.cn/problems/ransom-note/)
- [x] [15.三数之和](https://leetcode.cn/problems/3sum/)
- [x] [18.四数之和](https://leetcode.cn/problems/4sum/)

### 字符串

- [x] [344.反转字符串](https://leetcode.cn/problems/reverse-string/)
- [x] [541.反转字符串二](https://leetcode.cn/problems/reverse-string-ii/)
- [x] [替换数字](https://kamacoder.com/problempage.php?pid=1064)
- [x] [151.翻转字符串里的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)
- [x] [右转字符串](https://kamacoder.com/problempage.php?pid=1065)
- [x] [**28.实现strStr()**](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)【KMP前缀表需要背下来】
- [x] [**459.重复的子字符串**](https://leetcode.cn/problems/repeated-substring-pattern/)【KMP前缀表需要背下来】

#### 28.实现strStr()另外解法

```java
class Solution {
    public int strStr(String haystack, String needle) {
        List<Character> parentList=new ArrayList<>();
        for(Character c:haystack.toCharArray()){
            parentList.add(c);
        }
        List<Character> subList=new ArrayList<>();
        for(Character c:needle.toCharArray()){
            subList.add(c);
        }
        return Collections.indexOfSubList(parentList,subList);
    }
   
}
```





### 双指针

前面都做过了

### 栈与队列

> ArrayDeque是常见的队列和栈的好帮手
>
> - 队列：offer()、poll()、add()、remove()、peek() 
> - 栈：pop()、push()
> - 搞不清楚的话用offerFirst()等API也行，算法AC出来就行

- [x] [232.用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
- [x] [225.用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)
- [x] [20.有效的括号](https://leetcode.cn/problems/valid-parentheses/)
- [x] [1047.删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)
- [x] [150.逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)
- [x] [239.滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)【LinkedList<Integer>单调栈】
- [x] [347.前K个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)【HashMap+PriorityQueue<int[]>小顶堆】
