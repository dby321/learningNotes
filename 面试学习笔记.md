# 面试学习笔记

```markmap
---
markmap:
zoom:false
pan:false
height:300px
backgroundColor:"#f8f8f8"
---

#面试学习笔记
##Java基础
###字节码的好处？
###IR是什么？
####**Java字节码作为中间表示（IR）**
####**其他工具中的自定义中间表示（IR）**
###什么是程序分析、优化、混淆、静态检查？
###什么是热点代码？
###静态编译与动态编译
####**JIT与AOT编译对比表**
###移位运算符
###J2EE和Spring技术对比
###不要在finaly语句块中使用return
###注解的本质
###注解的解析方法有哪几种
###java中没有引用传递
###序列化
####OpenFeign
####Dubbo
####总结
###HttpMessageConverter
####为什么需要它？
####核心功能
####常见的`HttpMessageConverter`实现类
####工作流程
####总结
###软件设计准则
###Enum的本质
###SpringBoot异常处理
###优质开源项目学习
###面对HR提问
###接口幂等性
####使用数据库唯一约束
####基于Token机制
####利用Redis等缓存技术
####幂等锁
####总结
```

## 用户风格

https://itaoo.github.io/blogs/toolbox%20folder/TyporaEmoji.html

| 含义        | 推荐图标 | 输入关键词   |
| ----------- | -------- | ------------ |
| 正确 / 成功 | ✅ ✔️ 🟢    | check, yes   |
| 错误 / 失败 | ❌ ✖️ 🔴    | cross, no    |
| 警告        | ⚠️ 🔶      | warning      |
| 信息        | ℹ️ 💡      | info, bulb   |
| 提示        | 💡 📌      | tip, pin     |
| 目标        | 🎯        | target       |
| 启动 / 加速 | 🚀        | rocket       |
| 搜索        | 🔍        | search       |
| 刷新        | 🔄        | repeat, sync |

## 参考资料 

- [通义千问](https://tongyi.aliyun.com/qianwen/)
- [JavaGuide](https://javaguide.cn/)

## Java基础

### 字节码的好处？

**第一阶段：前端编译（源码到字节码）** Java 源代码（`.java` 文件）首先通过 `javac` 编译器进行编译。这个过程属于编译原理中的**前端编译**，主要包括词法分析、语法分析和语义分析等步骤。其输出结果是 **Java 字节码**（`.class` 文件）。字节码是一种与平台无关的**中间表示**（Intermediate Representation, IR），它使得 Java 程序具备了“一次编写，到处运行”的可移植性。

**第二阶段：运行时执行（字节码到机器码）** JVM 加载字节码文件后，进入执行阶段。这个阶段并非纯粹的解释或编译，而是两者的结合：

1. **解释执行**：JVM 的解释器会逐行读取字节码并解释执行。这种方式启动快，但持续执行的效率相对较低。
2. **即时编译（JIT）**：为了提升性能，JVM 在运行时会收集程序的执行信息（如方法调用次数、循环次数等）。当检测到某些代码（称为“热点代码”）被频繁执行时，JVM 内置的 **JIT（Just-In-Time）编译器**（属于**后端编译**）就会介入，将这些热点代码的字节码直接编译成本地机器码。编译后的机器码会被缓存起来，后续执行时便可以直接调用，从而获得接近原生代码的执行效率。

### IR是什么？

当然可以，以下是您提供内容的规整与清晰表述：

#### **Java 字节码作为中间表示（IR）**

当使用 `javac` 编译 Java 源代码（`.java` 文件）时，编译器会将其转换为一种平台无关的低级指令形式——**Java 字节码**（存储在 `.class` 文件中）。这种字节码是 Java 平台的核心 **中间表示**（Intermediate Representation, IR）。

- **平台无关性**：字节码不依赖于特定的硬件架构或操作系统，而是一种抽象的、标准化的指令集。
- **JVM 执行机制**：Java 虚拟机（JVM）负责加载并执行这些字节码。执行方式主要有两种：
  - **解释执行**：由解释器逐条读取并执行字节码指令。
  - **即时编译（JIT）**：将频繁执行的“热点代码”动态编译为本地机器码，以提升运行性能。
- **关键作用**：Java 字节码作为从源代码到最终执行之间的桥梁，既保留了程序的可移植性，又为运行时优化提供了基础。因此，**Java 字节码是 Java 语言在编译与执行流程中的关键中间表示（IR）**。

#### **其他工具中的自定义中间表示（IR）**

除了 JVM 直接使用的字节码外，一些高级的 Java 开发工具和分析框架为了实现更复杂的程序分析、优化或转换，往往会将 Java 字节码进一步转换为**自定义的中间表示（IR）**。

这些自定义 IR 通常具备更丰富的结构信息，便于进行深度分析和操作，例如：

- **控制流图**（Control Flow Graph, CFG）
- **数据流分析**（Data Flow Analysis）
- **调用图**（Call Graph）
- **表达式树或三地址码**等抽象形式

**典型应用示例**：

- **ASM**、**Javassist**：字节码操作库，在内存中解析 `.class` 文件后，可能构建内部结构化表示，用于动态生成或修改类。
- **Soot**：一个广泛使用的 Java 程序分析框架，它将 Java 字节码转换为多种 IR 形式（如 Baf、Jimple、Shimple），其中 Jimple 是一种简化后的三地址码表示，极大简化了静态分析的复杂度。
- **ProGuard / R8**：代码混淆与优化工具，利用自定义 IR 进行无用代码检测、内联、常量传播等优化。
- **IDE 静态分析插件**（如 IntelliJ、Eclipse）：在后台构建程序模型以支持代码检查、重构和智能提示。

### 什么是程序分析、优化、混淆、静态检查？

1. **程序分析 (Program Analysis)**
   - **定义**：程序分析是指系统地检查和理解程序的结构、行为、属性和潜在问题的过程。其目的是获取关于程序的深层信息，而不一定执行它（静态分析）或在执行时观察它（动态分析）。
   - 在 Java 中的应用：
     - **控制流分析 (Control Flow Analysis)**：构建程序的控制流图 (CFG)，展示代码块如何通过分支（if/else）、循环（for/while）和函数调用相互连接。这对于理解程序执行路径至关重要。
     - **数据流分析 (Data Flow Analysis)**：追踪程序中数据（变量）的定义、使用和传播。例如，分析一个变量在哪些地方被赋值，在哪些地方被读取，或者判断一个变量是否可能为 `null`。
     - **指针分析 / 别名分析 (Pointer/Alias Analysis)**：确定程序中的引用（指针）可能指向哪些对象，以及哪些不同的引用可能指向同一个对象（别名）。这在理解对象生命周期和并发问题时非常重要。
     - **调用图分析 (Call Graph Analysis)**：构建一个图，显示程序中哪些方法调用了哪些其他方法。这对于理解程序的整体结构、进行优化和检测死代码很有用。
     - **依赖分析**：分析类、方法、包之间的依赖关系。
   - **为什么需要 IR**：直接分析字节码指令序列比较复杂。自定义的 IR（如更高级的三地址码、SSA 形式）可以更清晰地表示控制流和数据流，使得分析算法（如数据流分析中的定值-引用链计算）更容易实现和优化。
2. **优化 (Optimization)**
   - **定义**：优化是指在不改变程序外部行为（语义）的前提下，修改程序以提高其性能（如运行速度、内存占用）或减小其体积（如代码大小）的过程。
   - 在 Java 中的应用：
     - **JIT 编译器优化**：JVM 的即时编译器（如 HotSpot 的 C1/C2）会将频繁执行的字节码编译成本地机器码，并在此过程中应用大量优化，如方法内联（Inlining）、循环展开（Loop Unrolling）、公共子表达式消除（CSE）、死代码消除（Dead Code Elimination）、逃逸分析（Escape Analysis）等。
     - **AOT 编译器优化**：像 GraalVM Native Image 这样的工具将 Java 程序提前编译（Ahead-of-Time）为本地可执行文件，会进行更激进的优化和链接。
     - **字节码优化工具**：一些工具专门用于优化 `.class` 文件，例如 ProGuard（也包含混淆功能）可以进行类/字段/方法名的缩短、无用代码/资源的移除、代码结构的简化等。
   - **为什么需要 IR**：优化通常需要复杂的分析（如上面提到的数据流、控制流分析）。一个设计良好的 IR 能够清晰地暴露程序的结构和数据依赖关系，使得优化算法（如识别可内联的方法、判断循环不变量）能够更有效地应用。优化后的 IR 再被转换回目标格式（字节码或机器码）。
3. **混淆 (Obfuscation)**
   - **定义**：混淆是指有意地修改程序的代码或结构，使其对人类（尤其是逆向工程师）来说变得难以阅读、理解和分析，但同时保持其原有的功能和行为。主要目的是保护知识产权和防止恶意篡改。
   - 在 Java 中的应用：
     - **名称混淆 (Name Obfuscation)**：将具有描述性意义的类名、方法名、字段名替换为无意义的短字符串（如 `a`, `b`, `c`）或 Unicode 难以阅读的字符。这是最常见和最基础的混淆。
     - **流混淆 (Flow Obfuscation)**：修改程序的控制流，例如插入无用的条件分支、循环或 try-catch 块，或者打乱代码执行顺序（在不改变逻辑的前提下），使控制流图变得复杂难懂。
     - **字符串加密 (String Encryption)**：将代码中的字符串常量加密存储，在运行时才解密使用，防止通过字符串搜索轻易找到关键逻辑。
     - **类/包结构混淆**：改变类的继承关系或包结构（在不破坏功能的情况下），增加理解难度。
   - **为什么需要 IR**：要进行有效的混淆（尤其是流混淆和高级混淆），工具需要深入理解程序的逻辑结构和数据依赖。自定义 IR 提供了一个抽象层，允许混淆器安全地插入无用代码、重排指令或修改控制流，同时利用分析确保不会破坏程序的正确性。直接在字节码层面操作风险更高。
4. **静态检查 (Static Checking)**
   - **定义**：静态检查是一种在程序**不实际运行**的情况下，通过分析其源代码或字节码来发现潜在错误、代码缺陷、安全漏洞、风格问题或违反编码规范的软件质量保证技术。
   - 在 Java 中的应用：
     - **编译器警告**：`javac` 本身会进行基本的静态检查，如未使用的变量、不可达代码、类型不匹配等。
     - **Lint 工具**：如 **Checkstyle** (检查代码风格和规范), **PMD** (检测常见编程缺陷、未使用代码、复杂度过高等), **SpotBugs** (前身是 FindBugs，利用字节码分析检测空指针解引用、资源泄漏、并发问题等潜在 bug)。
     - **安全扫描工具**：如 **SonarQube/SonarLint** (集成多种检查，包括安全漏洞、代码异味、重复代码等), **Fortify**, **Checkmarx** (专门用于发现安全漏洞，如 SQL 注入、XSS、不安全的反序列化等)。
     - **Null 安全分析**：一些工具或语言特性（如 Kotlin 的非空类型，或 Java 的 `@Nullable`/`@NonNull` 注解配合分析工具）可以静态地推断变量是否可能为 null，从而预防 `NullPointerException`。

### 什么是热点代码？

Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。

当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。

### 静态编译与动态编译

您对 JVM、JIT、AOT 以及 GraalVM 的理解非常准确和深入。确实，JIT 和 AOT 代表了两种不同的编译策略，各有其适用场景和权衡。下面我将您提到的关键点，用表格的形式进行清晰的总结和对比：

#### **JIT 与 AOT 编译对比表**

| 对比维度              | **JIT (Just-In-Time Compilation)**                           | **AOT (Ahead-Of-Time Compilation)**                          | **详细说明**                                                 |
| :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **编译时机**          | **运行时编译**在程序执行过程中，由 JVM 的 JIT 编译器动态编译。 | **提前编译**在程序运行**之前**，将 Java 字节码直接编译成本地机器码。 | JIT 是 Java “一次编写，到处运行” 的核心，字节码在运行时被优化；AOT 则在构建时就完成编译，生成独立的可执行文件。 |
| **代表技术/工具**     | HotSpot JVM (Oracle JDK, OpenJDK 默认)                       | **GraalVM Native Image** (基于 GraalVM)                      | GraalVM 是一个高性能的 JDK 发行版，它既包含强大的 JIT 编译器（作为 HotSpot 的替代或增强），也提供 `native-image` 工具来实现 AOT 编译。 |
| **启动时间**          | ❌ **较慢**需要加载 JVM、解释执行字节码、等待 JIT 预热。      | ✅ **极快**直接运行本地可执行文件，无需 JVM 启动和 JIT 预热。 | AOT 的最大优势之一，尤其适合 Serverless、微服务等需要快速冷启动的场景。 |
| **内存占用**          | ❌ **较高**JVM 本身占用内存，加上 JIT 编译、GC 等开销。       | ✅ **显著降低**没有 JVM 开销，本地镜像内存占用更小。          | AOT 生成的原生镜像内存 Footprint 更小，可以更高效地利用资源。 |
| **打包体积**          | ❌ **较大**包含整个 JVM 和所有依赖的 JAR 包。                 | ✅ **更小**（相对）只包含应用和其**实际使用到**的代码和库。   | GraalVM Native Image 会进行**静态代码分析**（Tree Shaking），移除未使用的代码，从而减小体积。但生成的可执行文件可能仍比单个 JAR 大，因为它包含了必要的运行时组件。 |
| **运行时性能 (峰值)** | ✅ **更高**JIT 可以进行**深度运行时优化**（如基于热点代码、类型推断）。 | ❌ **相对较低**优化在编译时完成，无法根据运行时数据进行动态调整。 | JIT 的优势在于“越用越快”。它能根据程序的实际执行路径（Profile-Guided Optimization）生成高度优化的机器码，理论上能达到接近 C/C++ 的性能。AOT 的优化是静态的，缺乏这种动态适应能力。 |
| **运行时性能 (延迟)** | ❌ **存在波动**请求延迟可能因 JIT 预热、GC 而出现“毛刺”（Jitter）。 | ✅ **更稳定**启动后性能立即稳定，延迟可预测。                 | AOT 避免了 JIT 预热期的性能不稳定，对于需要低且稳定延迟的场景（如高频交易）有优势。 |
| **支持的动态特性**    | ✅ **完全支持**反射、动态代理、动态类加载、JNI 等。           | ❌ **受限或不支持**必须在编译时确定，需要**显式配置**或**框架适配**。 | **这是 AOT 的核心挑战！** - **反射**：必须在 `reflect-config.json` 中预先声明。 - **动态代理 (CGLIB, JDK Proxy)**：框架（如 Spring AOT）需在构建时生成代理类。 - **JNI**：需要特殊处理。 - **资源加载**：必须在 `resource-config.json` 中声明。 |
| **对框架的影响**      | ✅ **兼容性好**Spring, Hibernate 等主流框架开箱即用。         | ⚠️ **需要适配**框架必须提供 AOT 支持（如 Spring Boot 3+ 的 AOT 模式）。 | 如您所言，CGLIB 使用 ASM 在运行时生成字节码，这在 AOT 中无法进行。因此，Spring Framework 6 / Spring Boot 3 引入了 **AOT Engine**，在构建时通过 **源码生成 (Source Generation)** 或 **提前处理** 的方式，模拟或替代这些运行时动态行为。 |
| **适用场景**          | - 传统单体应用- 长时间运行、追求极致吞吐量的服务- 使用大量动态特性的应用 | - **云原生应用** (Serverless, FaaS)- **微服务** (快速启动、低内存)- CLI 工具- 嵌入式场景 | **云原生趋势下，AOT 优势凸显**。虽然 JIT 在峰值性能上有理论优势，但 AOT 在启动、内存、稳定性方面的优势更符合现代弹性、按需伸缩的架构需求。GraalVM Native Image 正是为这些场景而生。 |
| **总结**              | **“运行时优化，性能潜力大”**                                 | **“启动快，资源省，适合云”**                                 | 两者并非完全替代关系。**GraalVM 的强大之处在于它同时提供了顶尖的 JIT 和 AOT 能力**。开发者可以根据应用的具体需求（是追求极限性能还是极致启动速度）来选择合适的编译模式。 |

1.  **GraalVM 是桥梁**：它让 Java 应用既能享受 JIT 的高性能潜力，又能通过 Native Image 获得 AOT 的云原生优势。
2.  **AOT 的代价是动态性**：放弃或限制 Java 的动态特性是使用 AOT 必须付出的代价。这推动了框架（如 Spring）向**构建时优化**和**源码生成**的方向演进。
3.  **场景驱动选择**：没有绝对的好坏。对于需要快速冷启动和低内存的微服务，**AOT (GraalVM Native Image) 是优选**；对于长时间运行、计算密集型且依赖复杂动态特性的应用，**JIT (HotSpot 或 GraalVM JIT) 仍是主力**。

### 移位运算符

| 应用领域                    | 具体用途与示例                                               | 使用的移位运算符       | 核心原理与优势                                               |
| :-------------------------- | :----------------------------------------------------------- | :--------------------- | :----------------------------------------------------------- |
| **算术优化**                | **快速乘以/除以 2 的幂次方**例如：`x << 3` 等价于 `x * 8` (2³)`x >> 2` 等价于 `x / 4` (2²，对正数) （算术右移） | `<<` (左移)`>>` (右移) | **性能极高**：CPU 的移位指令通常比乘除法指令快得多。是底层性能优化的经典技巧。 |
| **位字段 (Bit Field) 管理** | **高效存储多个布尔标志或小范围整数**例如：用一个 `int` (32位) 存储 32 个开关状态。```java// 设置第 5 位 (bit 5)flags |= (1 << 5);// 清除第 3 位 (bit 3)flags &= ~(1 << 3);// 检查第 7 位是否设置boolean isSet = (flags & (1 << 7)) != 0;// 从 flags 中提取 4-7 位表示的值int value = (flags >> 4) & 0xF; // 0xF = 1111₂``` | `<<` `>>` `&` `\|` `~` | **空间效率极高**：将多个独立的小数据打包到一个整数中，节省内存。常用于协议解析、状态寄存器、权限控制等。 |
| **哈希算法与加密**          | **数据混淆、扩散和生成哈希值**例如：在简单的哈希函数或加密轮函数中：```javaint hash = seed;hash ^= (key & 0xFF);hash = (hash << 5) + (hash >> 27); // 混合高低位```MD5, SHA 等算法内部大量使用移位和循环移位。 | `<<` `>>`              | **混淆与扩散**：移位能快速打乱数据的位模式，使得输入的微小变化导致输出的巨大差异（雪崩效应），这是密码学和哈希函数安全性的基础。 |
| **数据压缩**                | **高效处理二进制码流**例如：在实现霍夫曼编码、LZW 等算法时：- 将变长的霍夫曼码**拼接**到一个 `int` 或 `long` 的缓冲区中：`buffer |= (huffmanCode << bitPosition)`。- 从缓冲区中**提取**固定位数的数据：`(buffer >> (totalBits - neededBits)) & mask`。 | `<<` `>>` `&`          | **位级操作**：压缩算法通常处理的是位流而非字节流。移位运算符是操作和重组这些位流的最基本、最高效的工具，避免了繁琐的字节处理。 |
| **数据校验 (CRC)**          | **生成和校验循环冗余码**CRC 算法的核心是**模拟多项式除法**，其步骤包括：1.  将数据视为一个长二进制数。2.  与一个预定义的生成多项式进行异或和**移位**操作。移位是实现“除法”步骤的关键。 | `<<` `>>` `^` (异或)   | **硬件友好**：CRC 的移位-异或操作非常适合作为硬件电路实现，也易于用软件高效模拟。移位用于推进计算过程，异或用于执行模 2 减法。是网络通信、存储系统中保证数据完整性的标准方法。 |
| **内存对齐**                | **计算对齐的地址或大小**例如：将大小 `size` 向上对齐到 8 字节边界（假设 8=2³）：```javaint alignedSize = (size + 7) & ~7; // 经典方法// 或者使用移位 (当对齐边界是 2 的幂时)int alignment = 8; // 必须是 2 的幂int shift = 3; // log₂(8)int alignedSize = ((size - 1) >> shift << shift) + alignment; // 较少见，但可行``` | `>>` `<<` `&` `~`      | **高效计算**：当对齐边界是 2 的幂时，利用移位和位掩码 (`& ~mask`) 可以非常快速地完成对齐计算，比使用模运算 (`%`) 更高效。第一个 `& ~7` 的方法更常用。 |

*   **核心优势**：移位运算符操作的是**二进制位**，直接对应 CPU 的底层指令，因此具有**极高的执行效率**。
*   **主要类型**：
    *   `<<` (左移)：高位丢弃，低位补 0。等效于 * 2^n。
    *   `>>` (算术右移)：符号位不变，高位补符号位（正数补0，负数补1）。等效于 / 2^n (向下取整)。
    *   `>>>` (逻辑右移)：高位补 0，忽略符号。常用于处理无符号数或提取位。
*   **适用场景**：主要在**性能敏感**、**内存敏感**或需要**直接操作二进制数据**的领域（如底层系统编程、算法实现、网络协议、密码学、嵌入式开发）中发挥重要作用。
*   **注意事项**：使用时需注意数据类型（int vs long）、符号位的影响（`>>` vs `>>>`）以及移位位数的范围（通常对 32 或 64 取模）。

### J2EE和Spring技术对比

| 技术/功能              | Java EE (Jakarta EE) 方式                                    | Spring (Spring Boot) 方式                                    | 对比说明                                                     |
| :--------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Web 层 (MVC)**       | **Servlet & JSP**：- Servlet 处理请求/响应。- JSP 生成动态视图。- 通常结合 JSTL、自定义标签使用。 | **Spring MVC**：- 基于注解（`@Controller`, `@RequestMapping`）的控制器。- 支持 Thymeleaf、Freemarker、JSP 等多种视图技术。- 更强的类型安全和灵活性。 | ✅ **Spring 更灵活现代**：Spring MVC 提供了更简洁的注解驱动开发，解耦更好，测试更容易。JSP 在 Spring 中虽可用，但官方推荐 Thymeleaf 等模板引擎。 |
| **业务逻辑层**         | **EJB (Enterprise JavaBean)**：- 有状态/无状态 Session Bean。- MDB（消息驱动 Bean）。- 容器提供事务、安全、并发等服务。 | **Spring Bean + Service**：- 使用 `@Service`, `@Component` 等注解定义业务组件。- 通过 Spring 容器管理生命周期和依赖。 | ✅ **Spring 更轻量灵活**：EJB 配置复杂，依赖容器；Spring Bean 更简单，无需特定容器，POJO 编程，更易测试和迁移。EJB 功能在 Spring 中都能更好实现。 |
| **数据库连接**         | **JDBC**：- 原生 `java.sql` API，需手动管理连接、异常、资源释放。 | **Spring JDBC (JdbcTemplate)**：- 封装了 JDBC 模板，简化了 CRUD 操作。- 自动处理资源关闭和异常转换（转为 Spring 的 `DataAccessException`）。 | ✅ **Spring 极大简化 JDBC**：Spring 的 `JdbcTemplate` 减少了大量样板代码，提高了开发效率和安全性。 |
| **对象关系映射 (ORM)** | **JPA (Java Persistence API)**：- 标准 ORM 规范（如 Hibernate、EclipseLink 实现）。- 使用 `EntityManager`。 | **Spring Data JPA**：- 基于 JPA，提供更高级的抽象（如 `JpaRepository`）。- 方法名自动推导查询（`findByUsername`）。- 分页、排序内置支持。 | ✅ **Spring Data JPA 更高效**：两者底层都用 JPA，但 Spring Data JPA 极大减少了 DAO 层代码量，开发速度更快，是目前主流选择。 |
| **事务管理**           | **JTA (Java Transaction API)**：- 分布式事务标准。- EJB 和 JPA 可集成 JTA。- 需要支持 JTA 的应用服务器（如 WildFly, WebLogic）。 | **Spring Transaction**：- 支持本地事务（JDBC）和 JTA。- `@Transactional` 注解驱动。- 可集成 Atomikos、Bitronix 实现分布式事务。 | ✅ **Spring 更灵活通用**：Spring 事务管理不依赖完整 Java EE 服务器，可在 Tomcat 等轻量容器中使用，配置更简单，支持更广。 |
| **邮件发送**           | **JavaMail (Java EE API)**：- 标准 API，需配置 `MailSession` 等。 | **Spring Mail**：- 封装 JavaMail，提供 `JavaMailSender` 接口和 `SimpleMailMessage`。- 配置更简单（`spring.mail.*`）。- 易于测试。 | ✅ **Spring 更易用**：Spring 对 JavaMail 进行了优秀封装，配置和使用都更简洁，是实际项目中的首选。 |
| **消息队列**           | **JMS (Java Message Service)**：- 标准 API，支持点对点和发布/订阅。- 需 JMS 提供者（如 ActiveMQ）。 | **Spring JMS / Spring Messaging / Spring AMQP**：- 封装 JMS，提供 `JmsTemplate` 和 `@JmsListener`。- 支持 RabbitMQ (AMQP)、Kafka 等更多消息中间件。 | ✅ **Spring 生态更广**：Spring 不仅支持 JMS，还扩展支持 AMQP、Kafka 等现代消息系统，抽象层次更高，集成更方便。 |
| **整体架构**           | **Java EE 容器驱动**：- 需要完整的应用服务器（如 WildFly, GlassFish, WebLogic）。- 遵循规范，标准化强。 | **Spring Boot + 内嵌容器**：- 使用 Tomcat/Jetty/Undertow 内嵌服务器。- “约定优于配置”，自动装配。- 微服务友好（Spring Cloud）。 | ✅ **Spring Boot 更现代高效**：开发、部署、运维更简单，启动快，适合云原生和微服务架构。Java EE 更适合传统大型企业系统。 |
| **依赖管理**           | 依赖 Java EE 容器提供 API 实现。                             | 使用 Maven/Gradle 精确管理依赖版本，可自由选择组件组合（如只用 Spring MVC + MyBatis）。 | ✅ **Spring 更自由可控**：Spring 不强制依赖完整平台，可按需引入，避免“重量级”问题。 |

| 维度         | Java EE (Jakarta EE)                   | Spring (Spring Boot)                                       |
| :----------- | :------------------------------------- | :--------------------------------------------------------- |
| **定位**     | **标准化平台规范**                     | **全面的应用框架**                                         |
| **开发效率** | 相对较低（配置多，样板代码多）         | **极高**（自动配置，注解驱动，模板封装）                   |
| **学习曲线** | 较陡（EJB、JTA 等概念复杂）            | 相对平缓（尤其是 Spring Boot）                             |
| **部署**     | 需完整应用服务器（较重）               | 可独立运行（JAR + 内嵌容器），轻量快速                     |
| **生态**     | 标准化，厂商兼容性好                   | **极其丰富**，社区活跃，第三方集成多（如 Cloud, Security） |
| **适用场景** | 传统大型企业系统，需严格遵循标准的项目 | **现代 Web 应用、微服务、云原生应用**（主流选择）          |

> 💡 **结论**：虽然 Java EE 定义了重要的企业级标准（如 JPA, JTA, JMS），但 **Spring 框架（尤其是 Spring Boot）** 通过提供更简洁、灵活、高效的实现方式，已经成为当前企业 Java 开发的**绝对主流**。Spring 并非取代这些技术，而是更好地**集成、封装和简化**了它们的使用。

### 不要在finaly语句块中使用return

**不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。

### 注解的本质

`Annotation` （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。

注解本质是一个继承了`Annotation` 的特殊接口

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {

}

public interface Override extends Annotation{

}
```

### 注解的解析方法有哪几种

注解只有被解析之后才会生效，常见的解析方法有两种：

- **编译期直接扫描**：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过反射来进行处理的

 ### java中没有引用传递

c++中的引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？

**注意：以下为个人观点看法，并非来自于 Java 官方：**

1. 出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。
2. Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。

### 序列化

序列化是分布式系统中不同服务间数据交换的重要环节。在讨论OpenFeign和Dubbo这两种不同的远程调用框架时，它们各自支持的序列化方法有所不同。

#### OpenFeign

OpenFeign 是一个声明式的Web服务客户端，使得编写Web服务客户端变得更加简单。它本身主要关注于HTTP层面的服务调用，并不直接提供序列化机制，而是依赖于所使用的HTTP消息转换器（如Spring中的`HttpMessageConverter`）来实现请求和响应体的序列化与反序列化工作。默认情况下，如果是在Spring环境中使用OpenFeign，它通常会支持以下几种序列化方式：

- **JSON**：通过Jackson或Gson等库进行序列化/反序列化。
- **XML**：如果有相应的消息转换器配置的话，也可以支持XML格式的数据交换。

因此，在OpenFeign中，序列化的选择很大程度上取决于你使用的具体框架以及如何配置消息转换器。



#### Dubbo

Dubbo 是阿里巴巴开源的一个高性能服务框架，致力于提供高效、可靠的RPC（远程过程调用）服务。Dubbo 对序列化提供了更直接的支持，允许用户配置不同的序列化方式。Dubbo 默认支持多种序列化方式，包括但不限于：

- **Hessian2**：这是Dubbo默认的序列化方式，具有较好的性能和跨语言支持。
- **Java序列化**：使用Java自带的序列化机制，适用于纯Java环境下的应用。
- **Kryo**：一种高效的Java序列化库，相较于Java原生序列化有显著的性能提升。
- **FST**：Fast-serialization (FST) 是另一个快速且功能强大的Java序列化库。
- **Protobuf**：Google提供的语言中立、平台中立、可扩展的序列化结构数据格式，非常适合用于数据交换。
- **Avro**：Apache Avro是一种数据序列化系统，设计用于支持超大数据集的长期存储和服务间的通信。

Dubbo允许用户根据自己的需求灵活地选择合适的序列化策略，并在配置文件中指定。

#### 总结

- 在**OpenFeign**中，序列化更多地依赖于底层的HTTP消息转换器，常见的选择为JSON和XML，但主要是由集成的框架（如Spring）决定的。
- **Dubbo**则提供了对多种序列化方式的内置支持，允许用户根据性能、兼容性等要求选择最适合项目的序列化方案，比如Hessian2、Kryo、Protobuf等。这意味着在Dubbo项目中调整序列化策略可能会更加直观和方便。

### HttpMessageConverter

`HttpMessageConverter` 是 Spring 框架（特别是 Spring Web MVC 和 Spring WebFlux）中的一个核心接口，它在处理 HTTP 请求和响应时扮演着至关重要的角色。

简单来说，**`HttpMessageConverter` 的作用是在 HTTP 请求/响应的原始字节流（通常是字符串或字节数组）和 Java 对象之间进行相互转换**。

#### 为什么需要它？

1.  **客户端发送请求**：当你通过 HTTP POST 或 PUT 请求发送数据（例如，一个 JSON 字符串 `{"name": "Alice", "age": 30}`）到服务器时，Spring 需要一种机制将这个原始的 JSON 文本解析（反序列化）成一个对应的 Java 对象（如 `User user`）。
2.  **服务器返回响应**：当你的控制器方法返回一个 Java 对象（如 `return new User("Bob", 25);`）时，Spring 需要一种机制将这个 Java 对象转换（序列化）成客户端可以理解的格式（如 JSON 字符串 `{"name": "Bob", "age": 25}`），并将其写入 HTTP 响应体中。

`HttpMessageConverter` 就是完成这些转换工作的“翻译官”。

#### 核心功能

`HttpMessageConverter` 接口定义了四个主要方法：

1.  **`boolean canRead(Class<?> clazz, MediaType mediaType)`**:
    *   **作用**：判断这个转换器是否能将指定的 HTTP 内容类型（`MediaType`，如 `application/json`）的请求体读取并转换为指定的 Java 类型（`clazz`）。
    *   **场景**：用于处理 `@RequestBody` 注解。

2.  **`boolean canWrite(Class<?> clazz, MediaType mediaType)`**:
    *   **作用**：判断这个转换器是否能将指定的 Java 对象（`clazz` 的实例）写入 HTTP 响应体，并转换为指定的内容类型（`MediaType`）。
    *   **场景**：用于处理 `@ResponseBody` 注解或 `@RestController`。

3.  **`T read(Class<? extends T> clazz, HttpInputMessage inputMessage)`**:
    *   **作用**：从 `HttpInputMessage`（包含请求头和请求体输入流）中读取数据，并将其反序列化为指定类型的 Java 对象 `T`。
    *   **场景**：实现 `@RequestBody` 的功能。

4.  **`void write(T t, MediaType contentType, HttpOutputMessage outputMessage)`**:
    *   **作用**：将 Java 对象 `T` 序列化，并将其写入 `HttpOutputMessage`（包含响应头和响应体输出流），同时设置响应的内容类型。
    *   **场景**：实现 `@ResponseBody` 的功能。

#### 常见的 `HttpMessageConverter` 实现类

Spring MVC 默认注册了多个 `HttpMessageConverter` 的实现，以支持不同的数据格式：

*   **`MappingJackson2HttpMessageConverter`**:
    *   **功能**：使用 Jackson 库将 Java 对象与 **JSON** 格式相互转换。这是最常用的转换器。
    *   **处理的 MediaType**: `application/json`, `text/json` 等。

*   **`Jaxb2RootElementHttpMessageConverter`**:
    *   **功能**：使用 JAXB (Java Architecture for XML Binding) 将 Java 对象与 **XML** 格式相互转换。
    *   **处理的 MediaType**: `application/xml`, `text/xml` 等。

*   **`StringHttpMessageConverter`**:
    *   **功能**：处理 `String` 类型。能将请求体直接转换为 `String`，或将 `String` 写入响应体。
    *   **处理的 MediaType**: `text/plain` 等。

*   **`ByteArrayHttpMessageConverter`**:
    *   **功能**：处理 `byte[]` 类型。能将请求体转换为字节数组，或将字节数组写入响应体。
    *   **处理的 MediaType**: `application/octet-stream` 等。

*   **`FormHttpMessageConverter` / `SourceHttpMessageConverter`**:
    *   **功能**：分别处理表单数据和 XML Source 对象。

*   **`BufferedImageHttpMessageConverter`**:
    *   **功能**：处理图片（`BufferedImage`）的读写。

#### 工作流程

1.  当一个 HTTP 请求到达时，Spring MVC 的 `DispatcherServlet` 会根据请求的 `Content-Type` 头（对于请求体）和 `Accept` 头（对于期望的响应类型）来查找合适的 `HttpMessageConverter`。
2.  它会遍历所有注册的 `HttpMessageConverter`，调用它们的 `canRead()` 或 `canWrite()` 方法，找到第一个能够处理当前请求/响应类型和目标 Java 类型的转换器。
3.  找到后，调用该转换器的 `read()` 或 `write()` 方法完成实际的转换工作。

#### 总结

`HttpMessageConverter` 是 Spring Web 框架中实现**内容协商 (Content Negotiation)** 的关键组件。它使得开发者可以轻松地在控制器中使用 Java 对象，而无需关心底层的 HTTP 消息是如何将这些对象序列化为 JSON/XML 字符串或从字符串反序列化回来的。开发者通常只需要确保项目中包含了正确的依赖（如 Jackson 用于 JSON），Spring Boot 会自动配置好相应的转换器。

### 软件设计准则

面向对象编程来说，下面这些原则都是我们应该非常熟练的。

1. 面向对象编程的思想（继承、封装、多态、抽象）

2. 面向对象的七大设计原则：单一职责原则（Single Responsibility Principle, SRP）

- 开闭原则（Open Closed Principle，OCP）

  - ✅ **好例子**：`UserRepository` 只负责用户数据的存取，`UserService` 负责业务逻辑。
  - ❌ **坏例子**：一个类既处理数据库操作，又发邮件，又做日志记录。

  > **意义**：降低类的复杂度，提高可维护性和可测试性。

- 里氏代换原则（Liskov Substitution Principle，LSP）

  - ✅ **实现方式**：通过抽象（接口/抽象类） + 多态实现扩展。
  - ❌ 修改已有代码来增加功能是违背 OCP 的。

  > **例子**：支付系统支持新支付方式（如支付宝），应通过新增类实现，而不是修改原有 `PayService`。

- 接口隔离原则（Interface Segregation Principle，ISP）

  - 不要让客户端依赖它不需要的方法。
  - 提倡“细粒度接口”，避免“胖接口”。

  > **例子**：不要让一个 `Printer` 接口包含 `print()`, `scan()`, `fax()`，而应拆分为 `Printable`, `Scannable`, `Faxable`。

- 依赖反转原则（Dependency Inversion Principle，DIP）

  - 高层模块不依赖低层模块，两者都依赖抽象。
  - 抽象不依赖细节，细节依赖抽象。

  > **实现方式**：依赖注入（DI）、控制反转（IoC）容器（如 Spring）。

  **不遵循 DIP 的代码：**

  ```java
  // 低层模块 (具体实现)
  class MySQLDatabase {
      public void saveOrder(Order order) {
          // 保存到 MySQL 的具体逻辑
      }
  }
  
  // 高层模块 (直接依赖低层模块)
  class OrderService {
      private MySQLDatabase database = new MySQLDatabase(); // 直接 new 一个具体实现
  
      public void processOrder(Order order) {
          // ... 业务逻辑 ...
          database.saveOrder(order); // 直接调用具体实现
      }
  }
  ```

  **遵循 DIP 的代码：**

  ```java
  // 1. 定义抽象
  interface Database {
      void saveOrder(Order order);
  }
  
  // 2. 低层模块实现抽象
  class MySQLDatabase implements Database {
      @Override
      public void saveOrder(Order order) {
          // 保存到 MySQL 的具体逻辑
      }
  }
  
  class PostgreSQLDatabase implements Database {
      @Override
      public void saveOrder(Order order) {
          // 保存到 PostgreSQL 的具体逻辑
      }
  }
  
  // 3. 高层模块依赖抽象
  class OrderService {
      private Database database; // 依赖的是抽象接口
  
      // 通过构造函数注入具体的实现
      public OrderService(Database database) {
          this.database = database;
      }
  
      public void processOrder(Order order) {
          // ... 业务逻辑 ...
          database.saveOrder(order); // 调用抽象接口
      }
  }
  
  // 4. 使用 (依赖注入)
  public class Main {
      public static void main(String[] args) {
          // 可以轻松切换不同的数据库实现
          Database db = new MySQLDatabase(); // 或 new PostgreSQLDatabase();
          OrderService service = new OrderService(db); // 注入依赖
          service.processOrder(new Order());
      }
  }
  ```

- 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）

  - 当要复用功能时，优先使用组合（has-a）而不是继承（is-a）。
  - 继承破坏封装，组合更灵活。

  > **例子**：`Car` 包含 `Engine` 对象，而不是继承 `Engine`。

- 迪米特法则（Principle of Least Knowledge，PLK，也叫最小知识原则）

  - 一个对象应对其他对象保持最少了解。
  - 只与直接“朋友”通信（如：自己、参数、成员、创建的对象）。

  > **例子**：避免 `a.getB().getC().doSomething()`，应通过 `a.doSomething()` 封装。

3. 软件设计的三大原则

- DRY（Don’t Repeat Yourself）原则：不要重复你自己

- KISS（ Keep It Simple/Stupid）原则：保持简单易懂

- YAGNI （ You Ain’t Gonna Need It）原则 ：不要进行过度设计

### Enum的本质

| 特性                          | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| ✅ **是一个类**                | 编译后生成 `.class` 文件，是一个完整的类。                   |
| ✅ **继承自 `java.lang.Enum`** | 所有枚举都隐式继承 `Enum` 类，不能显式继承其他类（Java 不支持多继承）。 |
| ✅ **实例是有限且固定的**      | 实例在类加载时创建，且是 `public static final` 的，不可变。  |
| ✅ **构造器是私有的**          | 防止外部通过 `new` 创建新实例。                              |
| ✅ **天然线程安全**            | 实例在类加载时初始化，JVM 保证其唯一性和线程安全。           |
| ✅ **可实现接口**              | 枚举类可以实现接口（如 `Comparable`, `Serializable`）。      |
| ✅ **可定义方法和字段**        | 枚举可以有自己的属性、方法、甚至抽象方法。                   |

💡 **核心思想**：
 枚举不是“数据”，而是一种**有限状态机（Finite State Machine）** 或 **领域常量类型** 的优雅表达。

### SpringBoot异常处理

`@ControllerAdice`和`@ExceptionHandler`处理Controller级别的异常

```java
import com.twuc.webApp.web.ExceptionController;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import javax.servlet.http.HttpServletRequest;

@ControllerAdvice(assignableTypes = {ExceptionController.class})
@ResponseBody
public class GlobalExceptionHandler {

    // 也可以将 BaseException 换为 RuntimeException
    // 因为 RuntimeException 是 BaseException 的父类
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<?> handleAppException(BaseException ex, HttpServletRequest request) {
        ErrorReponse representation = new ErrorReponse(ex, request.getRequestURI());
        returnnew ResponseEntity<>(representation, new HttpHeaders(), ex.getError().getStatus());
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity<ErrorReponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
        ErrorReponse errorReponse = new ErrorReponse(ex, request.getRequestURI());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorReponse);
    }
}

```

### 优质开源项目学习

https://javaguide.cn/open-source-project/practical-project.html

多手搓轮子！！！

### 接口幂等性

**什么是幂等呢**? 在分布式系统中，幂等(idempotency)是对请求操作结果的一个描述，这个描述就是不论

执行多少次相同的请求，产生的效果和返回的结果都和发出单个请求是一样的。

🌰 举个例子：假如咱们的前后端没有保证接口幂等性，我作为用户在秒杀商品的时候，我同时点击了

多次秒杀商品按钮，后端处理了多次相同的订单请求，结果导致一个人秒杀了多个商品。这个肯定是不

能出现的，属于非常严重的 bug 了！

保证分布式接口的幂等性对于数据的一致性至关重要，特别是像支付这种涉及到钱的接口。保证幂等性

**这个操作并不是说前端做了就可以的，后端同样要做。**

前端保证幂等性的话比较简单，一般通过当用户提交请求后将按钮致灰来做到。后端保证幂等性就稍微

麻烦一点，方法也是有很多种，比如：

1. 同步锁；

2. 分布式锁；

3. 业务字段的唯一索性约束，防止重复数据产生。

4. ......

拿分布式锁来说，我们通过加锁的方式限制用户在第一次请求未结束之前，无法进行第二次请求。

分布式锁一般基于 Redis 来做比较多一些，这也是我比较推荐的一种方式。另外，如果使用 Redis 来实

现分布式锁的话，比较推荐基于 Redisson。相关阅读：分布式锁中的王者方案 - Redisson 

https://blog.csdn.net/2303_78263863/article/details/147480794

在分布式系统或微服务架构中，确保接口的**幂等性**是非常重要的，尤其是在处理如支付、订单创建等关键业务逻辑时。幂等性指的是同一个操作无论执行多少次，其结果都是相同的。对于 Spring Boot 应用来说，实现接口的幂等性可以通过多种方式来完成，下面介绍几种常见的策略：

#### 使用数据库唯一约束

如果请求涉及对数据库的操作，可以利用数据库的**唯一约束**来保证幂等性。例如，在处理订单创建时，可以为订单号设置唯一约束。当重复提交相同的订单号时，数据库会抛出异常，从而阻止重复记录的插入。

```sql
CREATE UNIQUE INDEX unique_order_number ON orders(order_number);
```

在服务端捕获此异常，并返回相应的错误信息给客户端。

#### 基于Token机制

这是一种常用的方法，特别适合于HTTP请求场景：

- **步骤1**：客户端发起请求前，先从服务器获取一个唯一的token。
- **步骤2**：客户端将此token与请求数据一同发送至服务器。
- **步骤3**：服务器接收到请求后，首先检查该token是否已经被使用过（通常通过数据库或缓存来存储已使用的token）。若未被使用，则执行业务逻辑并标记此token为已使用；否则直接返回之前的结果或错误提示。

Spring Boot 实现示例：

```java
@PostMapping("/process")
public ResponseEntity<?> processRequest(@RequestParam String token, @RequestBody RequestData data) {
    if (!tokenService.isValid(token)) {
        return new ResponseEntity<>("Duplicate request", HttpStatus.BAD_REQUEST);
    }
    // 执行业务逻辑
    tokenService.markAsUsed(token);
    return new ResponseEntity<>(result, HttpStatus.OK);
}
```

#### 利用Redis等缓存技术

Redis 提供了原子性的操作支持，非常适合用于幂等性控制。可以将每个请求的唯一标识符（如UUID）作为key存入Redis，并设置一个较短的有效期。每次请求到达时，检查Redis中是否存在对应的key。如果存在则说明是重复请求，反之则执行业务逻辑并将key存入Redis。

```java
if (Boolean.FALSE.equals(redisTemplate.hasKey(requestId))) {
    redisTemplate.opsForValue().set(requestId, "processed", Duration.ofMinutes(5));
    // 执行业务逻辑
} else {
    throw new RuntimeException("Duplicate request detected");
}
```

#### 幂等锁

在某些情况下，可以使用分布式锁来确保同一时间只有一个线程能够处理特定资源的相关请求。例如，使用 Redisson 或 Zookeeper 实现分布式锁。

#### @AutoIdempotent 幂等性实现



```java
/**
 * 需要保持幂等性的方法上加入此注解
 *
 */

@Target(value={ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoIdempotent {
}
```



```java


import cn.hutool.crypto.SecureUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;

import javax.servlet.ServletRequest;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.TimeUnit;


@Component
public class IdempotentInterceptor extends AutoIdempotentInterceptor {
    public static final String TOKEN_PREFIX = "TOKEN";
    public static final String APPID = "appid";
    @Autowired
    private RedisService redisService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();
            //被ApiIdempotment标记的扫描
            AutoIdempotent methodAnnotation = method.getAnnotation(AutoIdempotent.class);
            if (methodAnnotation != null) {
                String uri = request.getRequestURI();
                if (uri.contains("uploadImageServlet")) {
                    //图像上传的请求，不做处理
                    return false;
                } else {
                    String reqMethod = request.getMethod();
                    if ("POST".equals(reqMethod) || "PUT".equals(reqMethod)) {
                        String appId = request.getHeader(APPID);
                        if (isJson(request)) {
                            ServletRequest requestWrapper = new BodyReaderHttpServletRequestWrapper(request);
                            String body = HttpHelper.getBodyString(requestWrapper);
                            String bodyMD5 = SecureUtil.md5(body);
                            Object cacheObject = redisService.getCacheObject(bodyMD5);
                            if (cacheObject == null) {
                                redisService.setCacheObject(bodyMD5, bodyMD5, 3L, TimeUnit.SECONDS);
                            } else {
                                throw new CustomException("操作过快，请勿连续重复提交", 500);
                            }
                            if (StringUtils.isEmpty(appId)) {
                            } else {
                                //第三方调用的接口 不做过滤的原因是 ：第三方请求走sentinel限流
                                return true;
                            }
                        } else {
                            //如果是POST请求则需要获取 param 参数
                            Map<String, String[]> param = request.getParameterMap();
                            byte[] bp = objectToBytes(param);
                            String bodyMD5 = HashUtils.md5WithBase64(bp);
                            Object cacheObject = redisService.getCacheObject(bodyMD5);
                            if (cacheObject == null) {
                                redisService.setCacheObject(bodyMD5, param, 3L, TimeUnit.SECONDS);
                            } else {
                                throw new CustomException("操作过快，请勿连续重复提交", 500);
                            }
                            if (StringUtils.isEmpty(appId)) {
                            } else {
                                //第三方调用的接口 不做过滤的原因是 ：第三方请求走sentinel限流
                                return true;
                            }
                        }
                    } else {//get请求直接放行
                        return true;
                    }
                }
            }
        }
        return true;
    }

    /**
     * 判断本次请求的数据类型是否为json
     *
     * @param request request
     * @return boolean
     */
    private boolean isJson(HttpServletRequest request) {
        if (request.getContentType() != null) {
            return request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) ||
                    request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE);
        }
        return false;
    }

    /**
     * 对象转字节数组
     */
    public static byte[] objectToBytes(Object obj) throws IOException {
        try (
                ByteArrayOutputStream out = new ByteArrayOutputStream();
                ObjectOutputStream sOut = new ObjectOutputStream(out);
        ) {
            sOut.writeObject(obj);
            sOut.flush();
            byte[] bytes = out.toByteArray();
            return bytes;
        }
    }

    /**
     * 字节数组转对象
     */
    public static Object bytesToObject(byte[] bytes) throws IOException, ClassNotFoundException {
        try (
                ByteArrayInputStream in = new ByteArrayInputStream(bytes);
                ObjectInputStream sIn = new ObjectInputStream(in);
        ) {
            return sIn.readObject();
        }
    }
}

```



#### 总结

选择哪种方法取决于具体的业务需求和应用场景：

- 如果你的操作主要是基于数据库的CRUD，那么使用数据库唯一约束可能就足够了。
- 对于需要跨多个服务协调的情况，基于Token机制或者利用Redis等缓存技术可能是更好的选择。
- 分布式锁适用于更复杂的并发控制场景。

每种方法都有其适用范围和局限性，实际应用中可以根据项目的具体情况进行选择和组合使用。同时，也要注意处理好异常情况，确保系统的健壮性和用户体验。



### @DataScope部门权限控制

https://blog.csdn.net/m0_52134610/article/details/124122393

### 代理与反射

**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利

**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：[Java Reflection: Why is it so slow?](https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow)

#### JDK动态代理

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 1. 定义接口
interface GreetingService {
    void sayHello(String name);
}

// 2. 实现类
class GreetingServiceImpl implements GreetingService {
    @Override
    public void sayHello(String name) {
        System.out.println("Hello, " + name + "!");
    }
}

// 3. 创建 InvocationHandler
class LoggingInvocationHandler implements InvocationHandler {
    private final Object target; // 被代理的目标对象

    public LoggingInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在调用前添加日志
        System.out.println("Calling method: " + method.getName() + " with arguments: " + java.util.Arrays.toString(args));
        
        // 调用目标对象的实际方法
        Object result = method.invoke(target, args);
        
        // 在调用后添加日志
        System.out.println("Method " + method.getName() + " completed.");
        
        return result; // 返回结果
    }
}

// 4. 使用动态代理
public class DynamicProxyExample {
    public static void main(String[] args) {
        // 创建目标对象
        GreetingService realService = new GreetingServiceImpl();
        
        // 创建 InvocationHandler
        InvocationHandler handler = new LoggingInvocationHandler(realService);
        
        // 创建代理对象
        GreetingService proxyService = (GreetingService) Proxy.newProxyInstance(
            realService.getClass().getClassLoader(),
            realService.getClass().getInterfaces(),
            handler
        );
        
        // 通过代理对象调用方法
        proxyService.sayHello("Alice"); // 这会触发 LoggingInvocationHandler 的 invoke 方法
    }
}
```

#### CGLIB动态代理

好的，这是一个使用 CGLIB 实现动态代理的 Java 例子。

CGLIB (Code Generation Library) 是一个强大的、高性能的代码生成库。它可以在运行时扩展 Java 类和实现 Java 接口。与 JDK 动态代理（只能代理接口）不同，CGLIB 可以直接代理具体的类（通过生成子类）。

##### 添加依赖

首先，你需要在你的项目中添加 CGLIB 的依赖。如果你使用 Maven，可以在 `pom.xml` 中添加：

```xml
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version> <!-- 请检查是否有更新的版本 -->
</dependency>
```

如果你使用 Gradle，添加：

```groovy
implementation 'cglib:cglib:3.3.0'
```

##### 创建目标类 (被代理的类)

```java
// 这是一个具体的类，没有实现接口
public class UserService {
    public void saveUser(String name) {
        System.out.println("Saving user: " + name);
    }

    public String getUser(int id) {
        System.out.println("Fetching user with ID: " + id);
        return "User" + id;
    }

    // final 方法不能被 CGLIB 代理（因为子类无法重写）
    public final void finalMethod() {
        System.out.println("This is a final method, cannot be proxied.");
    }
}
```

##### 创建 MethodInterceptor (CGLIB 的拦截器)

CGLIB 使用 `MethodInterceptor` 接口来定义拦截逻辑，类似于 JDK 动态代理中的 `InvocationHandler`。

```java
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class LoggingMethodInterceptor implements MethodInterceptor {
    private final Object target; // 被代理的目标对象

    public LoggingMethodInterceptor(Object target) {
        this.target = target;
    }

    /**
     * 拦截对代理对象方法的调用
     * @param obj 生成的代理对象
     * @param method 被拦截的方法（来自父类）
     * @param args 方法参数
     * @param proxy 用于调用父类（即原始类）方法的 MethodProxy
     * @return 方法调用的返回值
     * @throws Throwable
     */
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 在方法调用前执行的逻辑 (前置通知)
        System.out.println("[CGLIB Proxy] Before calling method: " + method.getName() + 
                          " with arguments: " + java.util.Arrays.toString(args));

        // 执行原始方法
        // 注意：这里使用 proxy.invokeSuper(obj, args) 而不是 method.invoke(target, args)
        // 因为 obj 是代理对象，而 target 是原始对象。proxy.invokeSuper 会调用父类（即原始类）的方法。
        Object result = proxy.invokeSuper(obj, args);

        // 在方法调用后执行的逻辑 (后置通知)
        System.out.println("[CGLIB Proxy] After calling method: " + method.getName() + 
                          ", returned: " + result);

        return result;
    }
}
```

##### 创建代理工厂 (可选，但推荐用于封装)

```java
import net.sf.cglib.proxy.Enhancer;

public class CglibProxyFactory {
    /**
     * 创建目标对象的代理
     * @param target 要代理的目标对象
     * @param <T> 目标对象的类型
     * @return 代理对象
     */
    public static <T> T createProxy(T target) {
        // 创建 Enhancer 对象，它是 CGLIB 创建代理的核心类
        Enhancer enhancer = new Enhancer();
        
        // 设置要代理的类（父类）
        enhancer.setSuperclass(target.getClass());
        
        // 设置回调（即拦截器）
        enhancer.setCallback(new LoggingMethodInterceptor(target));
        
        // 创建并返回代理对象
        return (T) enhancer.create();
    }
}
```

##### 使用 CGLIB 代理

```java
public class CglibProxyExample {
    public static void main(String[] args) {
        // 1. 创建目标对象
        UserService userService = new UserService();

        // 2. 创建代理对象
        UserService proxyUserService = CglibProxyFactory.createProxy(userService);

        // 3. 通过代理对象调用方法
        System.out.println("=== Calling saveUser via proxy ===");
        proxyUserService.saveUser("Alice");

        System.out.println("\n=== Calling getUser via proxy ===");
        String user = proxyUserService.getUser(123);

        System.out.println("\n=== Result: " + user);

        // 尝试调用 final 方法（注意：final 方法不会被代理）
        System.out.println("\n=== Calling finalMethod (will NOT be proxied) ===");
        proxyUserService.finalMethod(); // 这个调用不会经过拦截器
    }
}
```

##### 运行结果

```
=== Calling saveUser via proxy ===
[CGLIB Proxy] Before calling method: saveUser with arguments: [Alice]
Saving user: Alice
[CGLIB Proxy] After calling method: saveUser, returned: null

=== Calling getUser via proxy ===
[CGLIB Proxy] Before calling method: getUser with arguments: [123]
Fetching user with ID: 123
[CGLIB Proxy] After calling method: getUser, returned: User123

=== Result: User123

=== Calling finalMethod (will NOT be proxied) ===
This is a final method, cannot be proxied.
```

##### 关键点说明

1.  **代理类**: CGLIB 通过继承目标类 (`UserService`) 创建一个子类（代理类）来实现代理。因此，被代理的类不能是 `final` 的，且要代理的方法也不能是 `final` 或 `private` 的（`private` 方法无法被继承重写）。
2.  **MethodInterceptor**: 这是 CGLIB 的核心接口，`intercept` 方法定义了拦截逻辑。
3.  **MethodProxy**: `proxy.invokeSuper(obj, args)` 是调用父类（即原始目标类）方法的推荐方式。避免在 `intercept` 方法中直接调用 `method.invoke(target, args)`，因为 `obj` 是代理对象，可能会导致无限递归或绕过代理逻辑。`invokeSuper` 会直接调用父类方法。
4.  **Enhancer**: CGLIB 的核心工具类，用于创建代理类和实例。
5.  **无接口限制**: 与 JDK 动态代理不同，CGLIB 可以代理没有实现任何接口的具体类。

这个例子展示了如何使用 CGLIB 为一个具体的类创建代理，并在方法调用前后添加日志记录功能。

#### 静态代理、JDK动态代理、CGLIB动态代理表格对比

| 特性/类型    | 静态代理                                       | JDK 动态代理                                                 | CGLIB 动态代理                                               |
| ------------ | ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **实现方式** | 手动创建代理类，需为每个服务接口编写一个代理类 | 使用 Java 反射机制，在运行时动态创建代理对象                 | 通过继承目标类生成子类实现代理                               |
| **性能**     | 编译期确定，运行时效率高                       | 每次调用都涉及反射，相对较低（但通常足够）                   | 相对较高，比JDK动态代理稍好一些                              |
| **适用场景** | 当代理逻辑不常变化时                           | **适合基于接口的代理**                                       | **适合于具体类，尤其是未实现接口的类**                       |
| **复杂度**   | 较低，易于理解和实现                           | 中等，涉及到反射机制                                         | 中等，需要额外库（CGLIB）                                    |
| **扩展性**   | 低，增加新功能需要修改或添加新的代理类         | **高，可以通过改变 InvocationHandler 实现来扩展，用Proxy来创建代理类** | **高，可以通过改变 MethodInterceptor 来扩展，用Enhancer创建代理类** |
| **使用限制** | 无特别限制                                     | 不能代理没有实现接口的类                                     | 不能代理 final 类或方法                                      |
| **主要用途** | 日志记录、访问控制等简单场景                   | AOP（面向切面编程）、事务管理等                              | AOP、延迟加载、模拟测试等                                    |

### BigDecimal

#### 使用注意事项

- 我们在使用 `BigDecimal` 时，为了防止精度丢失，推荐使用它的`BigDecimal(String val)`构造方法或者 `BigDecimal.valueOf(double val)` 静态方法来创建对象。禁止使用`BigDecimal(double val)`将double值转换为BigDecimal对象，因为会存在精度丢失风险。

- 我们使用 `divide` 方法的时候尽量使用 3 个参数版本，并且`RoundingMode` 不要选择 `UNNECESSARY`，否则很可能会遇到 `ArithmeticException`（无法除尽出现无限循环小数的时候），其中 `scale` 表示要保留几位小数，`roundingMode` 代表保留规则

  ```java
  public enum RoundingMode {
     // 2.4 -> 3 , 1.6 -> 2
     // -1.6 -> -2 , -2.4 -> -3
     UP(BigDecimal.ROUND_UP),
     // 2.4 -> 2 , 1.6 -> 1
     // -1.6 -> -1 , -2.4 -> -2
     DOWN(BigDecimal.ROUND_DOWN),
     // 2.4 -> 3 , 1.6 -> 2
     // -1.6 -> -1 , -2.4 -> -2
     CEILING(BigDecimal.ROUND_CEILING),
     // 2.5 -> 2 , 1.6 -> 1
     // -1.6 -> -2 , -2.5 -> -3
     FLOOR(BigDecimal.ROUND_FLOOR),
     // 2.4 -> 2 , 1.6 -> 2
     // -1.6 -> -2 , -2.4 -> -2
     HALF_UP(BigDecimal.ROUND_HALF_UP),
     //......
  }
  
  ```

- BigDecimal的等值比较应该使用compareTo()方法，不要使用equals()方法，因为equals()方法会比较值和精度（1.0与1.00返回结果为false），而compareTo()会忽略精度

#### BigDecimal工具类

```java
import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * 简化BigDecimal计算的小工具类
 */
public class BigDecimalUtil {

    /**
     * 默认除法运算精度
     */
    private static final int DEF_DIV_SCALE = 10;

    private BigDecimalUtil() {
    }

    /**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.add(b2).doubleValue();
    }

    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double subtract(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.subtract(b2).doubleValue();
    }

    /**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double multiply(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.multiply(b2).doubleValue();
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍六入五成双。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2) {
        return divide(v1, v2, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍六入五成双。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();
    }

    /**
     * 提供精确的小数位四舍六入五成双处理。
     *
     * @param v     需要四舍六入五成双的数字
     * @param scale 小数点后保留几位
     * @return 四舍六入五成双后的结果
     */
    public static double round(double v, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b = BigDecimal.valueOf(v);
        BigDecimal one = new BigDecimal("1");
        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
    }

    /**
     * 提供精确的类型转换(Float)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static float convertToFloat(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.floatValue();
    }

    /**
     * 提供精确的类型转换(Int)不进行四舍六入五成双
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static int convertsToInt(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.intValue();
    }

    /**
     * 提供精确的类型转换(Long)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static long convertsToLong(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.longValue();
    }

    /**
     * 返回两个数中大的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中大的一个值
     */
    public static double returnMax(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.max(b2).doubleValue();
    }

    /**
     * 返回两个数中小的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中小的一个值
     */
    public static double returnMin(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.min(b2).doubleValue();
    }

    /**
     * 精确对比两个数字
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
     */
    public static int compareTo(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.compareTo(b2);
    }

}
```

### Unsafe类

**为什么 `public static` 方法无法被直接调用呢？**

这是因为在`getUnsafe`方法中，会对调用者的`classLoader`进行检查，判断当前类是否由`Bootstrap classLoader`加载，如果不是的话那么就会抛出一个`SecurityException`异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用



**如若想使用 `Unsafe` 这个类的话，应该如何获取其实例呢？**

这里介绍两个可行的方案。

1. 利用反射获得 Unsafe 类中已经实例化完成的单例对象 `theUnsafe` 。

```
private static Unsafe reflectGetUnsafe() {
    try {
      Field field = Unsafe.class.getDeclaredField("theUnsafe");
      field.setAccessible(true);
      return (Unsafe) field.get(null);
    } catch (Exception e) {
      log.error(e.getMessage(), e);
      return null;
    }
}
```

2. 从`getUnsafe`方法的使用限制条件出发，通过 Java 命令行命令`-Xbootclasspath/a`把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过`Unsafe.getUnsafe`方法安全的获取 Unsafe 实例。



```
java -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径
```

您总结得非常准确！`sun.misc.Unsafe` 确实可以按功能划分为这 8 个核心类别。作为 Java 中最底层、最强大但也最危险的类，它直接操作内存和 JVM 底层机制，是许多高性能框架（如并发包、Netty、JDK 本身）的基石。

以下是对您分类的补充说明和关键点概括：

#### 🔧 `Unsafe` 功能分类详解

| 类别              | 核心功能                        | 典型方法                                                     | 说明与风险                                                   |
| ----------------- | ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 内存操作**   | 直接分配、读写、释放堆外内存    | `allocateMemory`, `reallocateMemory`, `freeMemory`, `putXxx`, `getXxx` | 绕过 JVM 垃圾回收，实现堆外内存管理（如 DirectByteBuffer）。**极易内存泄漏或越界访问**。 |
| **2. 内存屏障**   | 控制 CPU 指令重排序和内存可见性 | `loadFence`, `storeFence`, `fullFence`                       | 实现高性能无锁数据结构的内存顺序保证，替代 `volatile` 的部分语义。 |
| **3. 对象操作**   | 直接操作对象内存布局            | `objectFieldOffset`, `getObject`, `putObject`, `staticFieldOffset` | 获取字段偏移量，直接读写对象字段（即使 `private`），用于反射优化、序列化。 |
| **4. 数据操作**   | 批量内存复制/初始化             | `copyMemory`, `setMemory`                                    | 高效的内存拷贝（类似 C 的 `memcpy`），用于数组复制、缓冲区操作。 |
| **5. CAS 操作**   | 无锁原子更新                    | `compareAndSwapXxx`, `getAndAddXxx`, `getAndSetXxx`          | 实现 `AtomicInteger` 等原子类的核心，是 `java.util.concurrent` 包的基石。 |
| **6. 线程调度**   | 线程阻塞与唤醒                  | `park`, `unpark`                                             | 实现 `LockSupport`，是 `synchronized` 和 `ReentrantLock` 底层线程调度的基础。 |
| **7. Class 操作** | 动态类加载与初始化              | `defineClass`, `defineAnonymousClass`, `ensureClassInitialized` | 动态生成类（如动态代理）、延迟初始化类。                     |
| **8. 系统信息**   | 获取底层系统信息                | `addressSize`, `pageSize`                                    | 查询指针大小（32/64位）、内存页大小等 JVM/系统信息。         |

#### ⚠️ 重要注意事项

1.  **不安全 (Unsafe)**：正如其名，直接操作内存和底层机制，一旦使用不当会导致 JVM 崩溃、数据损坏、安全漏洞。
2.  **非标准 API**：`sun.misc.Unsafe` 属于 JDK 内部实现，**不保证跨版本兼容性**。从 Java 9 开始，模块化（JPMS）限制了对它的访问。
3.  **替代方案**：
    *   **Java 9+**：推荐使用 `VarHandle` (JEP 193) 替代大部分 CAS 和字段操作。
    *   **堆外内存**：使用 `ByteBuffer.allocateDirect()` 或 `Foreign Function & Memory API` (Java 17+)。
    *   **原子操作**：优先使用 `java.util.concurrent.atomic` 包下的类。
4.  **使用场景**：仅限于框架开发、性能极致优化、底层库开发。**普通业务代码严禁使用**。

#### ✅ 总结

您归纳的 8 个类别全面覆盖了 `Unsafe` 的核心能力。它本质上是 Java 提供给开发者的一把“双刃剑”：

*   **正面**：为高性能、低延迟的系统（如数据库、消息队列、JVM 本身）提供了必要的底层支持。
*   **反面**：破坏了 Java 的安全性、可移植性和封装性，应被严格限制使用。

现代 Java 正在通过 `VarHandle`、`MethodHandles`、`Foreign API` 等提供更安全、更标准的替代品，逐步取代 `Unsafe` 的角色。

### SPI机制详解

**SPI（Service Provider Interface）机制**是Java提供的一种服务发现机制，它允许第三方为某个接口提供实现而不改变原有的代码。通过SPI机制，开发者可以动态地发现和加载这些实现类，这在扩展功能或集成不同的服务提供商时非常有用。

#### SPI的基本概念

1. **服务接口**：这是你定义的一个接口或抽象类，其他开发者或你自己将为这个接口提供具体的实现。
2. **服务提供者**：指的是实现了上述接口的具体类。
3. **服务提供者配置文件**：位于 `META-INF/services/` 目录下，文件名为服务接口的全限定名，内容为该接口所有具体实现类的全限定名，每行一个实现类。

#### 使用步骤

1. **定义服务接口**

   首先需要定义一个接口或者抽象类，例如：

   ```java
   public interface HelloService {
       void sayHello();
   }
   ```

2. **实现服务接口**

   创建一个或多个实现了此接口的类。比如：

   ```java
   public class EnglishHelloService implements HelloService {
       @Override
       public void sayHello() {
           System.out.println("Hello!");
       }
   }

   public class ChineseHelloService implements HelloService {
       @Override
       public void sayHello() {
           System.out.println("你好！");
       }
   }
   ```

3. **创建服务提供者配置文件**

   在 `src/main/resources/META-INF/services/` 目录下创建一个以接口全限定名为名称的文件（如 `com.example.HelloService`），并在文件中列出所有实现类的全限定名，每个实现类占一行：

   ```
   com.example.EnglishHelloService
   com.example.ChineseHelloService
   ```

4. **使用ServiceLoader加载服务提供者**

   通过 `java.util.ServiceLoader` 来加载服务提供者并使用它们：

   ```java
   import java.util.ServiceLoader;
   
   public class SPIMain {
       public static void main(String[] args) {
           ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);
           for (HelloService service : loader) {
               service.sayHello();
           }
       }
   }
   ```

#### 注意事项

- **类路径**：确保所有的服务提供者及其配置文件都在同一个类路径下。
- **线程安全**：`ServiceLoader` 实例不是线程安全的，如果在多线程环境中使用，应该考虑同步访问。
- **延迟加载**：`ServiceLoader` 支持懒加载，即只有当调用迭代器的 `next()` 方法时才会加载下一个实现类。
- **默认实现**：如果你希望为某个服务提供一个默认实现，可以在配置文件中仅指定那个实现类。

#### 应用场景

- **数据库驱动程序**：JDBC API就是通过SPI机制来加载不同数据库厂商提供的驱动程序。
- **日志框架**：SLF4J等日志门面也利用了SPI机制来支持多种日志实现（如Logback、Log4j）。
- **模块化系统**：OSGi和Java 9+的模块系统也可以利用SPI来增强其模块化的灵活性。

SPI机制提供了一种灵活的方式来扩展应用程序的功能，并且不需要修改原有的代码结构，非常适合构建可插拔的应用程序架构。



当使用 `ServiceLoader` 在多线程环境中同时加载服务提供者时，确实可能会遇到并发问题。虽然 `ServiceLoader` 本身是线程安全的（因为它是不可变的，并且每次调用 `load` 方法都会返回一个新的实例），但是在迭代 `ServiceLoader` 实例的过程中，如果没有正确处理，仍然可能出现并发相关的问题。

#### 并发问题的具体情况

- **迭代器问题**：`ServiceLoader` 返回的迭代器并不是线程安全的。如果多个线程同时对同一个 `ServiceLoader` 实例进行迭代操作，可能会导致 `ConcurrentModificationException` 或其他不一致的状态。
- **初始化问题**：在某些情况下，`ServiceLoader` 的初始化可能涉及文件读取或其他 I/O 操作，这些操作在多线程环境下如果不加以控制，也可能引发问题。

#### 解决方案

为了确保在多线程环境中安全地使用 `ServiceLoader`，可以采取以下几种策略：

##### **同步访问**

如果你需要确保所有线程都以一种可控的方式访问 `ServiceLoader`，可以在访问 `ServiceLoader` 及其迭代器时使用同步块或方法。例如：

```java
import java.util.ServiceLoader;
import java.util.Iterator;

public class SafeSPIMain {
    private static final Object lock = new Object();
    private static ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);

    public static void main(String[] args) {
        Runnable task = () -> {
            synchronized (lock) {
                Iterator<HelloService> iterator = loader.iterator();
                while (iterator.hasNext()) {
                    HelloService service = iterator.next();
                    service.sayHello();
                }
            }
        };

        // 创建并启动多个线程来模拟并发访问
        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
    }
}
```

在这个例子中，我们通过一个共享锁对象 (`lock`) 来同步对 `ServiceLoader` 迭代器的访问，从而避免了并发修改的问题。

##### **提前加载和缓存结果**

另一种方法是在应用启动时预先加载所有的服务提供者并将它们存储在一个线程安全的数据结构中，比如 `CopyOnWriteArrayList`。这样，在后续的多线程操作中可以直接使用这个缓存列表而不需要再次加载 `ServiceLoader`。

```java
import java.util.ServiceLoader;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;

public class CachedSPIMain {
    private static List<HelloService> services;

    static {
        ServiceLoader<HelloService> loader = ServiceLoader.load(HelloService.class);
        services = new CopyOnWriteArrayList<>();
        loader.forEach(services::add);
    }

    public static void main(String[] args) {
        Runnable task = () -> {
            for (HelloService service : services) {
                service.sayHello();
            }
        };

        // 创建并启动多个线程来模拟并发访问
        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
    }
}
```

这里，我们在静态初始化块中一次性加载所有的服务提供者，并将它们添加到 `CopyOnWriteArrayList` 中。由于 `CopyOnWriteArrayList` 是线程安全的，所以可以放心地在多个线程之间共享和使用它。

##### 使用并发集合

如果需要动态地添加或移除服务提供者，可以考虑使用其他的线程安全集合，如 `ConcurrentHashMap` 来管理服务提供者的引用。

##### 为每个线程创建独立的 ServiceLoader 实例

考虑到 `ServiceLoader` 实例本身是不可变的，因此为每个线程创建独立的 `ServiceLoader` 实例也是一种可行的方法。这可以通过使用 `ThreadLocal` 来实现：

```java
import java.util.ServiceLoader;
import java.util.Iterator;

public class ThreadLocalSPIMain {
    private static ThreadLocal<ServiceLoader<HelloService>> loaderHolder = ThreadLocal.withInitial(() -> 
        ServiceLoader.load(HelloService.class)
    );

    public static void main(String[] args) {
        Runnable task = () -> {
            ServiceLoader<HelloService> loader = loaderHolder.get();
            Iterator<HelloService> iterator = loader.iterator();
            while (iterator.hasNext()) {
                HelloService service = iterator.next();
                service.sayHello();
            }
        };

        // 创建并启动多个线程来模拟并发访问
        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
    }
}
```

这种方法确保了每个线程都有自己的 `ServiceLoader` 实例，从而避免了并发访问的问题。

选择哪种方法取决于你的具体需求和应用场景。对于大多数情况，预加载和缓存服务提供者可能是最简单和最有效的解决方案。然而，在某些特定场景下，你可能需要更复杂的机制来管理服务提供者的生命周期和状态。



### 为什么HashMap扩容选择2的幂次方

1. **简化哈希计算**：使用2的幂次方作为容量大小，可以使得哈希值到桶索引的转换更加高效。具体来说，通过位运算 `hash & (capacity - 1)` 可以快速地找到对应的桶位置，这比取模运算 `%` 更加高效。因为当容量是2的幂次方时，`capacity - 1` 的二进制表示全是1（例如，容量为8时，`capacity - 1` 是7，即二进制的 `0111`），这样与操作可以直接保留哈希值的有效位数作为桶索引。
2. **均匀分布**：将容量设置为2的幂次方有助于减少哈希碰撞的概率，从而达到更好的分散效果。虽然理论上好的哈希函数应该独立于容量大小来保证均匀分布，但在实践中，使用2的幂次方可以帮助更有效地利用空间，尤其是在哈希函数不是特别理想的情况下。
3. **动态调整**：由于容量必须是2的幂次方，所以每次扩容都是成倍增长的（比如从16增加到32）。这种设计允许HashMap在不知道确切的最大容量需求的情况下，依然能够高效地管理内存和性能。它确保了即使在多次扩容后，仍然能够维持较高的性能水平。
4. **避免浪费空间**：如果容量不是2的幂次方，则可能无法充分利用所有桶。例如，如果容量是一个奇数，那么某些模式的哈希值可能会倾向于映射到特定的桶上，导致这些桶过早填满，而其他桶则几乎为空。通过使用2的幂次方作为容量，可以确保每个桶被均匀填充，最大化存储效率。

- JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过扰动函数处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

- JDK8的hash方法比JDK7的hash方法效率更高

### ConcurrentHashMap实现现成安全的方式

- 在 JDK1.7 的时候，`ConcurrentHashMap` 对整个桶数组进行了分割分段(`Segment`，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。

- 到了 JDK1.8 的时候，`ConcurrentHashMap` 已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

- **`Hashtable`(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

### 不要使用Collections.synchronizedXxx()方法

`Collections` 提供了多个`synchronizedXxx()`方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。

我们知道 `HashSet`，`TreeSet`，`ArrayList`,`LinkedList`,`HashMap`,`TreeMap` 都是线程不安全的。`Collections` 提供了多个静态方法可以把他们包装成线程同步的集合。

最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。

### 尽量不要使用Arrays.asList()

`Arrays.asList()` 是一个非常方便的工具方法，可以将数组快速转换为 `List`。然而，尽管它很常用，但在很多场景下确实**不推荐直接使用**，主要原因如下：

---

### ⚠️ 主要问题：返回的 `List` 是**固定大小**且**不支持所有 `List` 操作**

`Arrays.asList()` 返回的是 `java.util.Arrays` 类的一个私有静态内部类 `ArrayList`（注意：**不是** `java.util.ArrayList`！）。

这个内部类有以下几个关键限制：

#### 1. **不能添加元素 (`add`)**
   ```java
   String[] array = {"a", "b", "c"};
   List<String> list = Arrays.asList(array);
   list.add("d"); // 抛出 java.lang.UnsupportedOperationException
   ```

#### 2. **不能删除元素 (`remove`)**
   ```java
   list.remove("a"); // 抛出 java.lang.UnsupportedOperationException
   ```

#### 3. **不能清空 (`clear`)**
   ```java
   list.clear(); // 抛出 java.lang.UnsupportedOperationException
   ```

#### 4. **但可以修改元素 (`set`)**
   ```java
   list.set(0, "x"); // ✅ 这是允许的，会修改原始数组
   System.out.println(Arrays.toString(array)); // 输出: [x, b, c] (原始数组也被改了！)
   ```
   **注意**：因为返回的 `List` 直接“背靠”原始数组，所以 `set` 操作会**直接修改原始数组**。

---

### 📌 为什么会有这些限制？

*   这个内部 `ArrayList` 类没有重写 `add`, `remove`, `clear` 等方法，它们继承自 `AbstractList`，而 `AbstractList` 中这些方法默认抛出 `UnsupportedOperationException`。
*   它只实现了 `get`, `set`, `size` 等基于索引访问和修改的方法，因为它本质上是对**固定大小**的底层数组的一个视图（View）。

#### 🚫 使用 `Arrays.asList()` 的陷阱场景

1.  **误以为可以修改**：开发者可能误以为得到了一个标准的 `ArrayList`，尝试添加或删除元素，导致运行时异常。
2.  **与原始数组耦合**：对 `List` 的 `set` 操作会直接影响原始数组，反之亦然，这可能导致意外的副作用。
3.  **传递给需要可变 `List` 的方法**：如果将 `Arrays.asList()` 的结果传递给一个期望能 `add` 或 `remove` 元素的方法，该方法会崩溃。



### fail-fast与fail-safe

`fail-fast`（快速失败）和 `fail-safe`（安全失败）是描述在遍历集合（Collection）的同时对集合进行修改时，迭代器（Iterator）行为的两种策略。

它们主要用来处理**并发修改异常**（`ConcurrentModificationException`）的问题。

#### Fail-Fast (快速失败)

*   **定义**：`fail-fast` 迭代器在设计上假设在迭代过程中**不会**有其他线程或代码修改集合。如果检测到集合在迭代期间被结构性修改（如添加、删除、清空元素），它会立即抛出 `ConcurrentModificationException` 异常，而不是让迭代继续进行，从而“快速失败”。
*   **目的**：尽早发现问题，避免在数据不一致的状态下继续执行，可能导致更隐蔽、更难调试的错误。
*   **实现原理**：
    *   集合类（如 `ArrayList`, `HashMap`）内部维护一个 `modCount`（修改计数器）。
    *   每当集合发生结构性修改时，`modCount` 就会递增。
    *   当创建一个 `fail-fast` 迭代器时，它会记录下当前的 `modCount` 值（通常称为 `expectedModCount`）。
    *   在迭代器的 `next()`、`remove()` 等方法被调用时，会检查当前集合的 `modCount` 是否等于 `expectedModCount`。如果不相等，说明集合被修改了，立即抛出 `ConcurrentModificationException`。
*   **典型实现**：
    *   `java.util` 包下的大部分非线程安全集合的迭代器，如 `ArrayList.Itr`, `HashMap$HashIterator` 等。
*   **示例**：
    ```java
    List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
    for (String s : list) {
        if ("b".equals(s)) {
            list.remove(s); // 在迭代中直接修改集合！
        }
    }
    // 结果：抛出 ConcurrentModificationException
    ```
*   **注意**：`fail-fast` 不是绝对保证的。它依赖于 `modCount` 的检查，而某些操作（如 `ListIterator.set()`）可能不会改变 `modCount`，因此不会触发异常。它只提供**尽力的检测**，不能用于构建依赖此行为的程序。



#### Fail-Safe (安全失败)

*   **定义**：`fail-safe` 迭代器通过创建集合的一个**快照**（Snapshot）或在**副本**上进行迭代，从而确保迭代过程不会受到原始集合修改的影响。即使原始集合在迭代期间被修改，迭代器也不会抛出 `ConcurrentModificationException`，并且迭代器看到的是迭代开始时集合的状态。
*   **目的**：提供一种在多线程环境下安全遍历集合的方式，保证迭代过程的稳定性和一致性。
*   **实现原理**：
    *   迭代器在创建时，会复制一份当前集合的数据（或其引用）。
    *   后续的遍历操作都在这个副本上进行，与原始集合的修改完全隔离。
*   **典型实现**：
    *   `java.util.concurrent` 包下的某些集合，如 `CopyOnWriteArrayList` 和 `CopyOnWriteArraySet` 的迭代器。
    *   `ConcurrentHashMap` 的迭代器也提供弱一致性保证（Weakly Consistent），虽然它不完全是 `Copy-On-Write`，但其迭代器也不会抛出 `ConcurrentModificationException`，并且能看到迭代开始后某些更新（但不保证看到所有更新），行为上更接近 `fail-safe`。
*   **示例**：
    ```java
    List<String> list = new CopyOnWriteArrayList<>(Arrays.asList("a", "b", "c"));
    for (String s : list) {
        if ("b".equals(s)) {
            list.remove(s); // 在迭代中修改原始集合
        }
        System.out.println(s); // 仍然会打印 a, b, c
    }
    // 结果：不会抛出异常，但删除操作对当前迭代器不可见。
    // 注意：迭代器看到的是创建时的快照，所以还是会遍历所有原始元素。
    ```
*   **优缺点**：
    *   **优点**：迭代安全，不会因并发修改而失败。
    *   **缺点**：
        1.  **内存开销**：创建副本需要额外的内存空间，尤其是对于大集合。
        2.  **性能开销**：创建副本本身有性能成本。
        3.  **数据陈旧**：迭代器看到的是快照，无法反映迭代开始后对原始集合的修改（如新添加的元素）。

#### 对比总结

| 特性                                           | Fail-Fast (快速失败)                                         | Fail-Safe (安全失败)                                         |
| :--------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **行为**                                       | 检测到并发修改时立即抛出 `ConcurrentModificationException`   | 允许并发修改，迭代在副本上进行，不抛出异常                   |
| **迭代器基础**                                 | 直接引用原始集合                                             | 基于原始集合的快照或副本                                     |
| **是否抛出 `ConcurrentModificationException`** | 是                                                           | 否                                                           |
| **内存开销**                                   | 低                                                           | 高 (需要复制数据)                                            |
| **性能开销**                                   | 低                                                           | 高 (复制成本)                                                |
| **数据一致性**                                 | 迭代过程数据可能不一致（如果没检测到）                       | 迭代过程数据一致（基于快照）                                 |
| **反映最新修改**                               | 可能反映，也可能导致异常                                     | 通常不反映迭代开始后的修改                                   |
| **典型集合**                                   | `ArrayList`, `HashMap`, `HashSet`, `TreeSet` 等 (`java.util`) | `CopyOnWriteArrayList`, `CopyOnWriteArraySet` (`java.util.concurrent`) |
| **适用场景**                                   | 单线程环境，或能确保遍历时无修改的多线程环境                 | 需要安全遍历且能接受数据陈旧和开销的多线程环境               |

**简单记忆**：
*   **Fail-Fast**： “你敢改，我立马报错！” (快，但可能崩)
*   **Fail-Safe**： “你改你的，我按我的老地图走。” (稳，但可能过时)

### 异或的妙用

`^` 是**异或（XOR）**运算符，在编程和逻辑运算中是一个非常重要的位运算操作。下面我们来详细讲解它的含义、性质和常见用途。

#### 🔹 什么是异或（XOR）？

异或是一种**二进制逻辑运算**，规则如下：

| A    | B    | A ^ B |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 0    | 1    | 1     |
| 1    | 0    | 1     |
| 1    | 1    | 0     |

👉 **总结：相同为 0，不同为 1**

#### 🔹 异或的重要性质

1. **自反性（A ^ A = 0）**  
   任何数与自己异或结果为 0。  
   例如：`5 ^ 5 = 0`

2. **零元（A ^ 0 = A）**  
   任何数与 0 异或，结果还是它自己。  
   例如：`5 ^ 0 = 5`

3. **可交换性（A ^ B = B ^ A）**

4. **可结合性（A ^ B ^ C = (A ^ B) ^ C = A ^ (B ^ C)）**

5. **可逆性（用于加密、交换等）**  
   如果 `c = a ^ b`，那么 `a = c ^ b`，`b = c ^ a`

#### 🔹 常见应用场景

##### ✅ 1. **交换两个变量（不使用临时变量）**

```c
int a = 5, b = 3;
a ^= b;
b ^= a;
a ^= b;
// 此时 a = 3, b = 5
```
> ⚠️ 注意：当 `a` 和 `b` 是同一变量时（如 `a ^= a`），结果会变为 0，导致数据丢失！

##### ✅ 2. **找出数组中唯一出现一次的数**

> 题目：一个数组中，所有元素都出现两次，只有一个元素出现一次，找出它。

```c
int findSingle(int arr[], int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        result ^= arr[i];  // 成对的会抵消为0，剩下的就是唯一的数
    }
    return result;
}
```
> 利用了 `a ^ a = 0` 和 `a ^ 0 = a` 的性质。

##### ✅ 3. **数据加密与解密（简单异或加密）**

```c
char data = 'A';
char key = 0x0F;

// 加密
char encrypted = data ^ key;

// 解密（再次异或同一个密钥）
char decrypted = encrypted ^ key;  // 又得到 'A'
```
> 因为 `(A ^ K) ^ K = A`，所以异或常用于简单加密。

##### ✅ 4. **判断两个数是否同号**

```c
int a = -5, b = -3;
if ((a ^ b) >= 0) {
    printf("同号");
} else {
    printf("异号");
}
```
> 原理：符号位相同 → 异或后符号位为 0（正数）；符号位不同 → 异或后符号位为 1（负数）

##### ✅ 5. **位翻转（toggle 某一位）**

```c
int flags = 0b1010;
int mask = 0b0010;

flags ^= mask;  // 第2位被翻转（1→0）
flags ^= mask;  // 再次翻转（0→1），可逆！
```

#### 🔹 小结

| 特性                 | 说明                   |
| -------------------- | ---------------------- |
| `a ^ a = 0`          | 自己异或自己等于 0     |
| `a ^ 0 = a`          | 异或 0 不变            |
| `a ^ b ^ a = b`      | 可用于交换、查找唯一数 |
| 可逆、可交换、可结合 | 数学性质强大           |

---

✅ **建议**：异或是一个强大而优雅的工具，尤其在**位操作、算法题、加密**中非常常见。理解其原理有助于写出高效、巧妙的代码。

### PriorityQueue和TreeSet

`PriorityQueue` 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。

`TreeSet` 和 `PriorityQueue` 都是 Java 集合框架的一部分，它们都能对元素进行排序，但它们的设计目的、内部实现和使用场景有着显著的区别。

#### TreeSet

- **数据结构**：基于红黑树（一种自平衡的二叉查找树）实现。
- **排序方式**：根据元素的自然顺序或者在创建时提供的 `Comparator` 进行排序。它保证了集合中的元素是唯一且有序的。
- **线程安全性**：不是线程安全的。如果需要在多线程环境中使用，可以考虑使用 `Collections.synchronizedSortedSet` 方法来包装 `TreeSet` 实例。
- **操作特性**：支持高效的插入、删除和访问操作，时间复杂度为 O(log n)。此外，`TreeSet` 提供了诸如 `higher`, `lower`, `ceiling`, `floor` 等方法，方便范围查询。
- **不允许 null 元素**：对于大多数实现了 `Comparable` 接口的对象类型来说，`TreeSet` 不允许插入 `null` 值，因为无法比较 `null`。

#### PriorityQueue

- **数据结构**：基于优先级堆（通常是一个二叉堆）实现。
- **排序方式**：根据元素的自然顺序或者在创建时提供的 `Comparator` 来确定优先级。与 `TreeSet` 不同，`PriorityQueue` 可以包含重复的元素。
- **线程安全性**：不是线程安全的。对于多线程环境下的使用，需要额外的同步处理。
- **操作特性**：队列头部是最小（或最大，取决于构造函数）的元素。提供 `poll()` 方法用于移除并返回队列头部的元素，`peek()` 用于查看头部元素而不移除它。插入和移除操作的时间复杂度为 O(log n)，而获取最小/最大元素的操作时间复杂度为 O(1)。
- **允许 null 元素**：`PriorityQueue` 不允许插入 `null` 值，因为在没有指定 `Comparator` 的情况下，`null` 不能被比较。

#### 主要区别

- **元素唯一性**：`TreeSet` 中的元素必须是唯一的，而 `PriorityQueue` 可以包含重复的元素。
- **接口和功能**：`TreeSet` 实现了 `NavigableSet` 接口，提供了丰富的导航方法；`PriorityQueue` 则实现了 `Queue` 接口，专注于高效地访问最高优先级的元素。
- **性能特征**：虽然两者都提供对数时间复杂度的插入和删除操作，但 `TreeSet` 更适合需要频繁进行范围查询的场景，而 `PriorityQueue` 更适用于需要快速访问最小或最大元素的情况。 

因此，选择 `TreeSet` 还是 `PriorityQueue` 应该基于你的具体需求，包括是否需要元素唯一性、是否需要进行范围查询等。



### 阻塞队列

Java 中常用的阻塞队列实现类有以下几种：

1. `ArrayBlockingQueue`：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。
2. `LinkedBlockingQueue`：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为`Integer.MAX_VALUE`。和`ArrayBlockingQueue`不同的是， 它仅支持非公平的锁访问机制。
3. `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列。元素必须实现`Comparable`接口或者在构造函数中传入`Comparator`对象，并且不能插入 null 元素。
4. `SynchronousQueue`：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，`SynchronousQueue`通常用于线程之间的直接传递数据。
5. `DelayQueue`：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。

### HashMap

- JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过扰动函数处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

- `HashMap` 中的扰动函数（`hash` 方法）是用来优化哈希值的分布。通过对原始的 `hashCode()` 进行额外处理，扰动函数可以减小由于糟糕的 `hashCode()` 实现导致的碰撞，从而提高数据的分布均匀性。

### ConcurrentHashMap

- 在 JDK1.7 的时候，`ConcurrentHashMap` 对整个桶数组进行了分割分段(`Segment`，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。

- 到了 JDK1.8 的时候，`ConcurrentHashMap` 已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

- **`Hashtable`(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。
- jdk8的锁粒度相对最小

### null的支持情况表格对比

> 多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。
>
> 
>
> ```
> public static final Object NULL = new Object();
> ```
>
> 作者本人 (Doug Lea)对于这个问题的回答：大致意思还是单线程下可以容忍歧义，而多线程下无法容忍。

| 集合类型       | 实现类                | 支持null键 | 支持null值 | 备注                                                         |
| -------------- | --------------------- | ---------- | ---------- | ------------------------------------------------------------ |
| **Collection** | ArrayList             | N/A        | 是         | 作为列表，只涉及值（元素）的存储。                           |
|                | LinkedList            | N/A        | 是         | 同上。                                                       |
|                | HashSet               | N/A        | 是         | 不保证顺序，允许一个null元素。                               |
|                | **TreeSet**           | N/A        | 否         | 根据自然顺序或提供的Comparator排序，不允许null元素。         |
|                | LinkedHashSet         | N/A        | 是         | 维护插入顺序，允许一个null元素。                             |
| **Map**        | HashMap               | 是         | 是         | 允许一个null键和多个null值。                                 |
|                | **TreeMap**           | 否         | 是         | 根据自然顺序或提供的Comparator排序，不允许null键但允许null值。 |
|                | LinkedHashMap         | 是         | 是         | 维护插入顺序，允许一个null键和多个null值。                   |
|                | **Hashtable**         | 否         | 否         | 不允许null键和null值，线程安全。                             |
|                | **ConcurrentHashMap** | 否         | 否         | 不允许null键和null值，适用于高并发环境。                     |

### 常见Collections方法

#### 排序

```java
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面
```

#### 查找替换

- binarySearch可以秒了二分查找
- indexOfSubList可以秒了KMP查找串，但是底层不是用的KMP算法，有O(m*n)的复杂度

```java
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素
```

#### 同步控制(了解)

```java
synchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。
synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。
synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。
```

### Java集合使用注意事项总结

1. 判断所有集合内部的元素是否为空，使用 `isEmpty()` 方法，而不是 `size()==0` 的方式。

2. 在使用 `java.util.stream.Collectors` 类的 `toMap()` 方法转为 `Map` 集合时，一定要注意当 key/value 为 null 时会抛 NPE 异常。
3. 集合遍历的时候不要remove/add，否则会发生`ConcurrentModificationException` 来提示用户发生了并发修改异常。这就是单线程状态下产生的 **fail-fast 机制**
4. 集合转数组使用`toArray(T[] array)` 方法的参数是一个泛型数组，如果 `toArray` 方法中没有传递任何参数的话返回的是 `Object`类 型数组。
5. 数组转集合使用`List list = new ArrayList<>(Arrays.asList("a", "b", "c"))`

### `Arrays.copyOf()`方法和`System.arraycopy()` 方法



```java
 		/**
     * 在此列表中的指定位置插入指定的元素。
     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     */
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //arraycopy()方法实现数组自己复制自己
        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；
        System.arraycopy(elementData, index, elementData, index + 1, size - index);
        elementData[index] = element;
        size++;
    }  

		public static int[] copyOf(int[] original, int newLength) {
      	// 申请一个新的数组
        int[] copy = new int[newLength];
  			// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    }
```

### LinkedHashMap与LRU

#### LinkedHashMap

`LinkedHashMap` 定义了排序模式 `accessOrder`(boolean 类型，默认为 false)，访问顺序则为 true，插入顺序则为 false。

为了实现访问顺序遍历，我们可以使用传入 `accessOrder` 属性的 `LinkedHashMap` 构造方法，并将 `accessOrder` 设置为 true，表示其具备访问有序性。



```java
LinkedHashMap<Integer, String> map = new LinkedHashMap<>(16, 0.75f, true);
map.put(1, "one");
map.put(2, "two");
map.put(3, "three");
map.put(4, "four");
map.put(5, "five");
//访问元素2,该元素会被移动至链表末端
map.get(2);
//访问元素3,该元素会被移动至链表末端
map.get(3);
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " : " + entry.getValue());
}
```

#### LRU

具体实现思路如下：

- 继承 `LinkedHashMap`;
- 构造方法中指定 `accessOrder` 为 true ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；
- 重写`removeEldestEntry` 方法，该方法会返回一个 boolean 值，告知 `LinkedHashMap` 是否需要移除链表首元素（缓存容量有限）。



```java
class LRUCache extends LinkedHashMap<Integer,Integer>{
    int capacity;
    public LRUCache(int capacity) {
        super(capacity,0.75F,true);
        this.capacity=capacity;
    }
    
    public int get(int key) {
        return super.getOrDefault(key,-1);
    }
    
    public void put(int key, int value) {
        super.put(key,value);
    }
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity; 
    }

}
```

### CopyOnWriteList

这里再以 `CopyOnWriteArrayList`为例介绍：当需要修改（ `add`，`set`、`remove` 等操作） `CopyOnWriteArrayList` 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。

可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能。

不过，写时复制机制并不是银弹，其依然存在一些缺点，下面列举几点：

1. 内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。
2. 写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。
3. 数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。

### BlockingQueue

#### **`ArrayBlockingQueue` 与 `LinkedBlockingQueue` 对比**

| 对比维度     | `ArrayBlockingQueue`                                         | `LinkedBlockingQueue`                                        |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **底层实现** | 基于**数组**实现。                                           | 基于**链表**（单向或双向链表）实现。                         |
| **队列边界** | **有界队列**。创建时必须指定容量大小，且容量不可变。         | **可选有界**。创建时可以不指定容量，默认容量为 `Integer.MAX_VALUE`（**无界**）；也可以指定容量，成为**有界队列**。 |
| **锁机制**   | **锁未分离**。生产和消费操作共用**同一个锁** (`ReentrantLock`)。同一时间只能有一个线程（生产者或消费者）进行操作。 | **锁分离**。生产操作使用 `putLock`，消费操作使用 `takeLock`。生产者和消费者可以**并发**执行（一个生产者和一个消费者可以同时操作队列），减少了锁竞争。 |
| **内存占用** | **预先分配**。创建时即分配固定大小的数组内存。内存占用**固定**，但可能存在**空间浪费**（数组可能未填满）。 | **动态分配**。内存随元素的增加而动态分配（每个节点一个对象）。内存占用**更灵活**，按需增长，但每个节点有额外的对象开销（如指针、对象头）。 |
| **性能特点** | 数组操作效率高（缓存友好），但锁竞争可能成为瓶颈（尤其在高并发生产消费场景）。 | 链表操作开销略高，但锁分离机制在高并发下通常能提供**更好的吞吐量**。无界模式下需警惕内存溢出风险。 |
| **适用场景** | 适用于对**内存使用有严格限制**、且可以预估队列最大容量的场景。 | 适用于**高并发**生产消费场景，或队列大小难以预估的场景（使用其无界特性时需谨慎，防止 `OutOfMemoryError`）。 |

> **总结**：`ArrayBlockingQueue` 是一个简单、内存占用可控的有界阻塞队列，但锁竞争可能限制其并发性能。`LinkedBlockingQueue` 通过链表和锁分离机制提供了更高的并发吞吐量和灵活性（可选有界/无界），是更常用的高性能选择，但需注意其潜在的内存开销和无界队列的风险。

好的，已将您提供的关于 `ArrayBlockingQueue` 和 `ConcurrentLinkedQueue` 的对比内容整理成清晰的表格：

#### **`ArrayBlockingQueue` 与 `ConcurrentLinkedQueue` 对比**

| 对比维度         | `ArrayBlockingQueue`                                         | `ConcurrentLinkedQueue`                                      |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **底层实现**     | 基于**数组**实现。                                           | 基于**链表**（无锁的单向链表）实现。                         |
| **队列边界**     | **有界队列**。创建时必须指定**固定容量**，队列满时无法再入队。 | **无界队列**。容量可以**动态增长**，理论上只受内存限制。     |
| **是否阻塞**     | **阻塞队列**。当队列满时，`put()` 操作会**阻塞**等待；当队列空时，`take()` 操作会**阻塞**等待。也提供非阻塞的 `offer()` 和 `poll()` 方法。 | **非阻塞队列**。所有操作（`add()`, `offer()`, `poll()`, `peek()`）都是**立即返回**的，不会阻塞线程。如果队列为空，`poll()` 返回 `null`。 |
| **线程安全机制** | 使用**显式锁** (`ReentrantLock`) 来保证线程安全。            | 使用**无锁算法**（基于 `CAS` - Compare-And-Swap）实现线程安全，通常在高并发下性能更好。 |
| **内存占用**     | 创建时即分配固定大小的数组内存，内存占用**固定**。           | 内存随元素增加**动态分配**，每个节点有额外的对象开销。       |
| **适用场景**     | 适用于需要**控制队列大小**、生产者和消费者速度差异较大、且需要**阻塞等待**的场景（如经典的生产者-消费者模型）。 | 适用于**高并发**、**读写频繁**、**不需要阻塞**、且队列大小难以预估的场景。对性能要求极高且能接受无界风险的场景。 |

> **总结**：`ArrayBlockingQueue` 是一个**有界阻塞**队列，通过锁机制保证安全，适用于需要流量控制和阻塞同步的场景。`ConcurrentLinkedQueue` 是一个**无界非阻塞**队列，采用无锁算法，适用于追求极致并发性能、不需要阻塞且能管理好内存风险的场景。两者的设计目标和适用场景有显著区别。

#### DelayQueue

`DelayQueue` 是 JUC 包(`java.util.concurrent)`为我们提供的延迟队列，用于实现延时任务比如订单下单 15 分钟未支付直接取消。它是 `BlockingQueue` 的一种，底层是一个基于 `PriorityQueue` 实现的一个无界队列，是线程安全的

### 死锁

死锁的四个必要条件：

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系。

使用`jmap`、`jstack`等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:`的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用`top`、`df`、`free`等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高。

采用 VisualVM、JConsole 等工具进行排查。

:white_check_mark: 下面是手写死锁：

```java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```




### ReentrantReadWriteLock 读锁不能升级为写锁

在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。

在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。

写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。

另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。

### ReentrantLock

`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承 AQS（`AbstractQueuedSynchronizer`），添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。

#### 实现轮询

**使用 `tryLock()` 方法**：

- 这个方法会立即尝试获取锁，并立即返回结果（成功或失败）。如果锁已经被其他线程持有，则此方法将立即返回 `false`。
- 开发者可以通过循环调用 `tryLock()` 来模拟轮询机制，直到成功获取到锁为止。这种模式允许你自定义重试逻辑、添加延迟等，以避免过于频繁的尝试对系统性能造成影响。

```java
ReentrantLock lock = new ReentrantLock();

while (true) {
    if (lock.tryLock()) {
        try {
            // 获取到锁后执行的操作
            break;
        } finally {
            lock.unlock();
        }
    } else {
        // 没有获取到锁时的处理逻辑
        System.out.println("Lock not available, retrying...");
        // 可以在这里添加延迟来减少CPU占用
        try {
            Thread.sleep(100); // 延迟100毫秒
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // 恢复中断状态
            break;
        }
    }
}
```

**使用 `tryLock(long timeout, TimeUnit unit)` 方法**：

- 这个方法允许你在指定的时间内尝试获取锁。如果在规定时间内无法获取到锁，它将返回 `false`。
- 使用这种方法可以在一定程度上减少资源的竞争，并且可以根据超时情况采取不同的策略（如重试、记录日志或抛出异常）。

```java
ReentrantLock lock = new ReentrantLock();

boolean acquiredLock = false;
try {
    acquiredLock = lock.tryLock(500, TimeUnit.MILLISECONDS);
    if (acquiredLock) {
        // 成功获取锁后的操作
    } else {
        // 超时未获取到锁时的处理逻辑
        System.out.println("Failed to acquire lock within the specified time.");
    }
} catch (InterruptedException e) {
    // 处理中断请求
    Thread.currentThread().interrupt(); // 恢复中断状态
} finally {
    if (acquiredLock) {
        lock.unlock();
    }
}
```

### JMX Java可观测性

JMX（Java Management Extensions，Java管理扩展）是 Java 平台提供的一套用于监控和管理 Java 应用程序、系统对象、设备（如打印机）以及服务的框架和 API。

简单来说，JMX 提供了一种标准的方式来：

1.  **暴露管理信息**：让 Java 应用程序可以将自己的运行状态（如内存使用、线程数、自定义指标等）暴露出来。
2.  **执行管理操作**：允许外部管理工具调用应用程序中的特定方法（如重新加载配置、清理缓存等）。
3.  **接收事件通知**：应用程序可以在特定事件发生时（如错误、状态变更）向外发送通知。

#### JMX 的核心组件

JMX 架构主要由三个层级组成：

1.  **探针层 (Instrumentation Level)**：
    *   这是被管理的资源，通常是 Java 对象。
    *   这些对象被称为 **MBean (Managed Bean)**。MBean 是一个符合特定设计模式的 Java 类，它定义了可以被外部访问的属性、操作和通知。
    *   常见的 MBean 类型有：标准 MBean、动态 MBean、开放 MBean、模型 MBean 等。

2.  **MBean 服务器层 (MBean Server Level)**：
    *   这是一个核心的运行时平台，可以看作是一个“容器”或“注册中心”。
    *   所有被管理的 MBean 都需要向 MBean 服务器注册。
    *   MBean 服务器提供了访问和管理这些 MBean 的统一接口。

3.  **代理层 (Agent Level)**：
    *   这是 JMX 代理，它包含了 MBean 服务器以及一系列用于管理服务的组件（如用于发现的 `JMX Agent`、用于安全的 `JMX Access Controller` 等）。
    *   一个 JVM 实例通常包含一个默认的 MBean 服务器。

4.  **分布式服务层 (Distributed Layer) / 远程管理层**：
    *   允许远程管理应用程序。
    *   通过 **JMX Connector**（如 RMI Connector）或 **JMXMP Connector**，远程的管理客户端（如 JConsole, VisualVM, JMC, 或自定义客户端）可以连接到 JMX Agent，从而读取 MBean 的信息、调用操作或接收通知。

#### JMX 的常见用途

*   **监控 JVM 状态**：这是最普遍的应用。通过 JMX，可以监控：
    *   堆内存和非堆内存使用情况
    *   垃圾回收（GC）次数和时间
    *   线程数量、状态（死锁检测）
    *   类加载数量
    *   JVM 编译情况
*   **监控应用性能**：应用可以自定义 MBean 来暴露业务指标，如请求处理时间、缓存命中率、队列长度等。
*   **动态配置**：通过 MBean 的属性或操作，可以在运行时修改应用配置，而无需重启。
*   **故障诊断**：获取线程转储（Thread Dump）、堆转储（Heap Dump）进行分析。
*   **集成监控工具**：许多监控系统（如 Prometheus 配合 JMX Exporter, Zabbix, Nagios 等）通过 JMX 收集 Java 应用的指标。

#### 常用的 JMX 客户端工具

*   **JConsole**：JDK 自带的图形化监控工具，可以连接本地或远程的 JVM。
*   **VisualVM**：功能更强大的 JDK 自带分析工具，集成了监控、分析、故障诊断等功能。
*   **Mission Control (JMC)**：更高级的性能分析和监控工具。
*   **Java Mission Control (JMC)**：现代的、功能丰富的分析工具。
*   **第三方监控平台**：通过 JMX Exporter 等组件，将 JMX 数据暴露为 Prometheus 可抓取的格式。

**总结**：JMX 是 Java 平台内置的、强大的管理和监控标准。它使得 Java 应用的可观测性（Observability）成为可能，是运维、开发和性能调优不可或缺的工具。



#### JMX示例

```java
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;

/**
 * 一个简单的程序，演示如何使用 JMX ThreadMXBean 来获取并打印当前 JVM 中所有线程的 ID 和名称。
 */
public class MultiThread {

    public static void main(String[] args) {
        // 获取 Java 线程管理 MXBean
        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();

        // 获取所有线程的快照信息
        // 参数说明：
        //   false: 不获取线程的锁定监控信息（如 monitor 等）
        //   false: 不获取同步器（如锁）的使用情况
        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);

        // 遍历并打印每个线程的 ID 和名称
        System.out.println("当前 JVM 中的所有线程：");
        System.out.println("------------------------");
        for (ThreadInfo threadInfo : threadInfos) {
            if (threadInfo != null) { // 安全性检查（虽然一般不会为 null）
                System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName());
            }
        }
    }
}
```



```cmd
当前 JVM 中的所有线程：
------------------------
[6] Monitor Ctrl-Break
[5] Signal Dispatcher
[4] Attach Listener
[3] Script Compiler
[2] GC Task Thread#0 (ParallelGC)
[1] main
[13] Common-Cleaner
```

🔍 补充说明

- `ManagementFactory.getThreadMXBean()` 是 JMX 提供的标准方式，无需额外依赖。
- `dumpAllThreads(false, false)` 轻量级获取线程信息，避免性能开销。
- 这个程序本身也会创建一些线程（如 `main` 线程），所以你会看到包括 `main` 在内的多个线程。

你的描述非常准确和清晰！下面是对这段内容的**精炼总结**，便于理解和记忆：

### Java 线程模型

> **现代 Java 线程本质上就是操作系统原生线程的直接封装，JVM 通过线程库（如 pthread）将 Java 线程一对一映射到内核线程，从而实现高效、并发、可调度的多线程执行。**

这个模型使得 Java 应用能够充分发挥现代硬件的多核性能，是 **Java 成为高性能服务器端语言**的重要基础之一。

#### 历史演进

- **JDK 1.2 之前**：Java 使用 **绿色线程（Green Threads）**，即 **用户级线程**。
  - 由 JVM 自己在用户空间模拟多线程。
  - 所有线程运行在**单个操作系统线程**上，无法真正并行执行。
  - 无法利用多核 CPU，且不支持操作系统级别的异步 I/O 等特性。

- **JDK 1.2 及以后**：Java 改为使用 **原生线程（Native Threads）**，即 **内核级线程**。
  - 每个 Java 线程直接映射到一个操作系统原生线程。
  - 由操作系统内核负责线程的**调度与管理**。
  - 可充分利用多核 CPU 实现真正的并行计算。

#### 用户线程 vs 内核线程

| 特性          | 用户线程（User Thread） | 内核线程（Kernel Thread）    |
| ------------- | ----------------------- | ---------------------------- |
| 调度者        | 用户程序（如 JVM）      | 操作系统内核                 |
| 运行空间      | 用户空间                | 内核空间                     |
| 创建/切换开销 | 低                      | 较高                         |
| 并行能力      | ❌ 无法利用多核          | ✅ 可并行运行在多核上         |
| 阻塞影响      | 一个阻塞，整个进程阻塞  | 仅该线程阻塞，其他线程可继续 |
| 示例          | JDK 1.1 的绿色线程      | 现代 Java 线程（JDK 1.2+）   |

#### 什么是线程模型？

线程模型定义了**用户级线程**（User Thread）与**内核级线程**（Kernel Thread）之间的映射关系。常见的三种模型包括：

| 模型              | 说明                                               |
| ----------------- | -------------------------------------------------- |
| **一对一**（1:1） | 一个用户线程对应一个内核线程。                     |
| **多对一**（M:1） | 多个用户线程映射到同一个内核线程。                 |
| **多对多**（M:N） | 多个用户线程映射到少量或多个内核线程，可动态调度。 |

#### Java 在主流操作系统中的线程模型

- **Windows 和 Linux**：
  - Java 采用 **一对一（1:1）模型**。
  - **每个 Java 线程直接对应一个操作系统内核线程**（通过 pthread 等系统调用创建）。
  - 优点：可充分利用多核 CPU，支持真正的并行执行。
  - 缺点：线程创建和切换开销较大（由操作系统承担）。

> ✅ 这是目前最广泛使用的模式，也是现代 JVM 的标准实现。

- **Solaris** 操作系统原生支持 **多对多（M:N）线程模型**。
  - 因此，**HotSpot VM 在 Solaris 平台**上提供了更灵活的支持：
    - 支持 **一对一（1:1）模型**
    - 也支持 **多对多（M:N）模型**


> 🔍 这使得在 Solaris 上可以更高效地管理大量线程，减少内核资源消耗，提升调度灵活性。

#### 核心结论

> **在绝大多数现代系统（如 Linux、Windows）中，Java 使用一对一的线程模型，即“一个 Java 线程 = 一个操作系统内核线程”。**
>
> 这种设计牺牲了一定的轻量性，但获得了**更好的并发性能和系统集成能力**，是 Java 高性能服务器应用的基础。

### ThreadLocal

如果想让每个线程都有自己的专属本地变量，该如何实现呢？`ThreadLocal` 类允许每个线程绑定自己的值

每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对。

#### ThreadLocal的原理

##### 🔍 核心变量定义（来自 `Thread` 类源码）

```java
/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;

/*
 * InheritableThreadLocal values pertaining to this thread. This map is
 * maintained by the InheritableThreadLocal class.
 */
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
```

- 每个 `Thread` 实例内部都维护了两个 `ThreadLocalMap` 类型的变量：
  - `threadLocals`：用于存储普通 `ThreadLocal` 的变量副本。
  - `inheritableThreadLocals`：用于支持 `InheritableThreadLocal`，可将父线程的变量**继承**到子线程中。

> ⚠️ 默认值都是 `null`，只有在首次调用 `set()` 或 `get()` 时才会被**延迟初始化**。

##### 🧱 ThreadLocalMap：定制化的“哈希表”

- `ThreadLocalMap` 是 `ThreadLocal` 的一个**静态内部类**，可以理解为一个**简化版的自定义哈希表**（非基于 `HashMap` 实现）。
- 它不是 `java.util.Map` 的实现，而是专门为 `ThreadLocal` 设计的键值存储结构。
- 存储结构：
  - **Key**：`ThreadLocal<?>` 实例（弱引用）
  - **Value**：用户设置的值（强引用）
  - 内部通过 `Entry[] table` 数组实现哈希桶，使用**线性探测法**解决哈希冲突。

> ✅ 所以说它是“定制化的 HashMap”是**形象的比喻**，但**不是基于 HashMap 实现的**。

##### 🔄 set()/get() 的实际调用流程

当你调用：

```java
myThreadLocal.set(value);
myThreadLocal.get();
```

实际上的执行路径是：

1. `ThreadLocal.set(T value)` 被调用；
2. 方法内部获取当前线程：`Thread t = Thread.currentThread();`
3. 从线程中获取 `t.threadLocals`；
4. 如果 `threadLocals == null`，则**创建一个新的 `ThreadLocalMap`**；
5. 调用 `threadLocals.set(this, value)` —— 即 `ThreadLocalMap` 的 `set()` 方法；
6. `get()` 同理，最终调用的是 `ThreadLocalMap.getEntry(this)`。

> ✅ 所以：**`ThreadLocal` 类的 `get/set` 方法，本质上是委托给当前线程的 `ThreadLocalMap` 实例来完成的。**

##### 🌱 inheritableThreadLocals：线程继承机制

- `InheritableThreadLocal` 是 `ThreadLocal` 的子类。
- 当**创建子线程时**，如果父线程的 `inheritableThreadLocals` 不为 null，JVM 会将其内容**拷贝到子线程的 `inheritableThreadLocals` 中**。
- 这实现了线程局部变量的“继承”能力。

```java
public class InheritableExample {
    static InheritableThreadLocal<String> tl = new InheritableThreadLocal<>();

    public static void main(String[] args) {
        tl.set("main-thread-value");
        new Thread(() -> {
            System.out.println(tl.get()); // 输出: main-thread-value
        }).start();
    }
}
```

> ⚠️ 注意：只在**线程创建时**拷贝一次，后续父线程修改不影响子线程。

##### 📌 总结要点

| 项目                      | 说明                                                   |
| ------------------------- | ------------------------------------------------------ |
| `threadLocals`            | 普通 `ThreadLocal` 的存储容器，初始为 `null`           |
| `inheritableThreadLocals` | 支持父子线程间变量继承                                 |
| `ThreadLocalMap`          | 自定义哈希表结构，非 `HashMap` 实现                    |
| 延迟初始化                | 只有调用 `set()` 或 `get()` 时才创建                   |
| 数据隔离                  | 每个线程有独立的 `ThreadLocalMap`，实现线程局部变量    |
| 调用委托                  | `ThreadLocal.get/set` 实际调用 `ThreadLocalMap` 的方法 |
| 内存泄漏风险              | key 弱引用，value 强引用 → 需手动 `remove()`           |

#### ThreadLocal内存泄漏的导致原因

你提供的内容关于 `ThreadLocalMap` 的引用机制基本正确，但我们可以更深入、准确地总结和补充这一机制，帮助理解其设计原理以及潜在的内存泄漏问题。

##### 🔑 key 是弱引用（WeakReference）

- `ThreadLocalMap` 的 `Entry` 类继承自 `WeakReference<ThreadLocal<?>>`。
- 每个 `Entry` 的 **key 是对 `ThreadLocal` 实例的弱引用**。
- 当外部不再有强引用指向某个 `ThreadLocal` 实例时，该实例在下一次 GC 时就会被回收。
- 回收后，`ThreadLocalMap` 中对应的 `key` 变成 `null`（即 `entry.get() == null`），但 `Entry` 对象本身仍然存在。

> ✅ 目的：弱引用 key 的设计是为了**尽可能及时地清理不再使用的 `ThreadLocal` 实例**，避免内存泄漏。

##### 💡 value 是强引用

- 尽管 key 被回收了（变为 `null`），但 `Entry` 对象本身仍然持有对 `value` 的**强引用**。
- 如果没有手动清理，这个 `value` 将**无法被垃圾回收**，即使它已经“无主可用”。

> ⚠️ 风险：这会导致 **内存泄漏（Memory Leak）** —— `value` 占用的内存无法释放，尤其在使用线程池时，线程长期存活，`ThreadLocalMap` 也会长期存在。

##### 🧩 错误清理示例

```java
ThreadLocal<String> tl = new ThreadLocal<>();
tl.set("some large object");

tl = null; // 只有弱引用指向 ThreadLocal，key 将变为 null

// 此时：ThreadLocalMap 中存在一个 Entry，key == null，value == "some large object"
// value 仍被强引用，无法回收！
```

##### 🛠️ 正确处理内存泄漏

```java
try {
    threadLocal.set(someValue);
    // ... 业务逻辑
} finally {
    threadLocal.remove(); // 关键：清理 Entry
}
```

- `remove()` 方法会：
  - 删除对应的 `Entry`
  - 解除对 `value` 的强引用
  - 防止内存泄漏

##### 🔍 ThreadLocalMap 的“被动清理”机制

`ThreadLocalMap` 内部有一些**被动清理机制**来缓解泄漏问题：

- `get()`、`set()`、`remove()` 方法在执行时，会**顺带清理一部分 key 为 null 的 Entry**（称为“启发式清理”）。
- 但这只是**辅助机制**，不能依赖它完全避免内存泄漏。

> ❗ 所以：**主动调用 `remove()` 是最佳实践！**

#### ThreadLocal实战中的应用



##### ✅ 压测流量标记（Pressure Testing Traffic Tagging）

###### 🎯 目的

在进行系统**压力测试（压测）**时，需要将“压测产生的请求”和“真实用户请求”区分开来，避免压测数据污染数据库、影响真实业务逻辑或触发错误的告警。

###### 🔍 为什么用 ThreadLocal？

- 一个请求从进入系统到处理完成，可能涉及多个方法、组件甚至微服务。
- 我们希望在整个调用链路中，**始终知道当前请求是否是压测请求**。
- 使用 `ThreadLocal` 可以在请求入口（如过滤器、拦截器）设置一个“压测标记”，之后在该线程的任何地方都可以通过 `ThreadLocal.get()` 判断是否为压测流量。

###### 💡 示例代码

```java
public class PressureTestContext {
    private static final ThreadLocal<Boolean> isPressureTest = new ThreadLocal<>();

    public static void set(boolean flag) {
        isPressureTest.set(flag);
    }

    public static boolean isPressureTest() {
        Boolean flag = isPressureTest.get();
        return flag != null && flag;
    }

    public static void clear() {
        isPressureTest.remove(); // 防止内存泄漏
    }
}
```

在请求入口设置标记（如 Spring 拦截器）：

```java
public class PressureTestInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String ptHeader = request.getHeader("X-Pressure-Test");
        if ("true".equalsIgnoreCase(ptHeader)) {
            PressureTestContext.set(true);
        }
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        PressureTestContext.clear(); // 清理，避免线程复用导致污染
    }
}
```

在业务代码中判断：

```java
if (PressureTestContext.isPressureTest()) {
    // 跳过写数据库、不发短信、不触发真实支付等
    log.info("This is pressure test traffic, skip business side effects.");
} else {
    // 正常处理真实用户请求
}
```

###### ⚠️ 注意事项
- 必须在请求结束时调用 `remove()`，防止**线程池中线程复用导致上下文污染**。
- 若使用异步调用（如线程池、CompletableFuture），需手动传递上下文。



##### ✅ 上下文传递：链路追踪（Trace ID）、用户上下文等

###### 🎯 目的
在分布式系统中，一个用户请求可能经过多个服务（A → B → C → D）。为了排查问题，我们需要：
- **跟踪整个调用链路**（分布式追踪）
- **获取当前用户身份信息**（如用户ID、权限）

这就需要在整个调用过程中**传递和访问上下文信息**。

###### 🔍 为什么用 ThreadLocal？

- 每个服务内部的处理可能是多线程的，但**单个请求的主线程处理流程是线性的**。
- 使用 `ThreadLocal` 可以让开发者在任意层级的方法中**无需显式传参**，就能访问到当前请求的上下文（如 `TraceId`、`UserId`）。

###### 💡 常见用途

(1) 链路追踪（Trace ID）

```java
public class TraceContext {
    private static final ThreadLocal<String> traceId = new ThreadLocal<>();

    public static void set(String id) {
        traceId.set(id);
    }

    public static String get() {
        return traceId.get();
    }

    public static void clear() {
        traceId.remove();
    }
}
```

在网关或入口生成 Trace ID：

```java
TraceContext.set(UUID.randomUUID().toString());
```

在日志中输出：

```java
log.info("[TraceId={}] Processing order...", TraceContext.get());
```

(2) 用户上下文（User Context）

```java
public class UserContext {
    private static final ThreadLocal<User> currentUser = new ThreadLocal<>();

    public static void setUser(User user) {
        currentUser.set(user);
    }

    public static User getCurrentUser() {
        return currentUser.get();
    }

    public static void clear() {
        currentUser.remove();
    }
}
```

在登录验证后设置：

```java
User user = userService.validate(token);
UserContext.setUser(user);
```

在业务层直接使用：

```java
User user = UserContext.getCurrentUser();
if (user.hasRole("ADMIN")) { ... }
```

###### ⚠️ 分布式场景下的挑战

在微服务架构中，**ThreadLocal 只能在当前 JVM 内有效**。如果服务 A 调用服务 B：
- A 中的 `ThreadLocal` 不会自动传递到 B。

✅ 解决方案：
- **通过网络请求头传递上下文**（如 HTTP Header）：
  - `X-Trace-ID: abc123`
  - `X-User-ID: 1001`
  - `X-Pressure-Test: true`
- 服务 B 接收到请求后，从 Header 中读取并设置到自己的 `ThreadLocal` 中。

这就是像 **SkyWalking、Zipkin、Sleuth** 等链路追踪工具的工作原理。

| 项目           | 英文发音        | 音似中文读法      | 备注            |
| -------------- | --------------- | ----------------- | --------------- |
| **SkyWalking** | /ˈskaɪ ˈwɔːkɪŋ/ | 赛·沃金           | Apache 开源项目 |
| **Zipkin**     | /ˈzɪp kɪn/      | 兹普·金           | Twitter 开源    |
| **Sleuth**     | /sleʊθ/         | 斯洛斯（th 吐气） | Spring 生态组件 |

###### ✅ 总结对比

| 场景                     | 用途                   | 使用方式                   | 注意事项                          |
| ------------------------ | ---------------------- | -------------------------- | --------------------------------- |
| **压测流量标记**         | 区分压测与真实流量     | 设置布尔标记，控制业务逻辑 | 避免污染真实业务，必须 `remove()` |
| **链路追踪（Trace ID）** | 调用链路跟踪、日志关联 | 生成唯一 ID，贯穿整个请求  | 需跨服务传递（通过 Header）       |
| **用户上下文**           | 权限判断、审计日志     | 存储用户身份信息           | 避免敏感信息泄露，及时清理        |

###### ✅ 最佳实践建议

1. **封装工具类**：不要直接使用 `ThreadLocal`，而是封装成带 `set/get/clear` 的上下文类。
2. **务必调用 `remove()`**：在请求结束时清理，防止内存泄漏和上下文污染。
3. **结合拦截器/过滤器**：在 Web 层统一设置和清理。
4. **跨线程传递需手动处理**：如使用线程池、异步任务时，需使用 `TransmittableThreadLocal`（阿里开源）等工具。
5. **跨服务传递靠 Header**：通过 HTTP 或 RPC 协议传递上下文信息。

###### ✅ 结论

> `ThreadLocal` 是实现**线程级上下文隔离与传递**的利器。  
> 在压测标记、链路追踪、用户上下文中，它让我们可以在不修改方法签名的前提下，**透明地访问请求上下文信息**，极大提升了代码的简洁性和可维护性。  
> 但也要警惕其副作用：**内存泄漏、上下文污染、跨线程/服务传递失效**，必须配合良好的设计和清理机制使用。

##### **探测式清理(expungeStaleEntry())**、**启发式清理(cleanSomeSlots())**

| 对比维度             | **启发式清理（Heuristic Cleanup）**                          | **探测式清理（Probing-based Cleanup）**                      |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **官方术语**         | ✅ 是，源码注释明确使用 `heuristically`                       | ❌ 非官方术语，是对探测过程的描述性说法                       |
| **对应方法**         | `cleanSomeSlots(int, int)`                                   | `getEntry()`, `set(ThreadLocal, Object)` 中的线性探测循环    |
| **触发时机**         | 在 `get()`、`set()`、`remove()` 操作后**顺带触发**           | 在 `get()` 或 `set()` 时，进行哈希探测的过程中自然发生       |
| **清理目的**         | 主动寻找并清理 `key == null` 的 stale entry，防止内存泄漏    | 在查找目标位置的过程中，**顺带发现** stale entry 并标记或清理 |
| **扫描方式**         | 从当前位置开始，**随机跳跃式扫描 `log2(n)` 个位置**          | 按照线性探测顺序（`nextIndex(i, len)`）**逐个探测**，直到找到空位或目标 |
| **扫描范围**         | 小范围（最多 `log2(table.length)` 次）                       | 大范围，直到找到目标或插入位置                               |
| **是否主动**         | ✅ 是，专门设计用于清理                                       | ❌ 否，是查找过程的副作用                                     |
| **性能影响**         | 极小，因为只扫描 `O(log n)` 次                               | 正常探测开销，最坏 `O(n)`                                    |
| **是否触发完整清理** | ✅ 是，一旦发现 stale entry，会调用 `expungeStaleEntry(i)` 进行完整清理 | ✅ 在 `getEntry()` 中，如果发现 stale entry，也会调用 `expungeStaleEntry(i)` |
| **是否改变哈希结构** | ✅ 是，`expungeStaleEntry` 会前移后续有效 entry，优化探测链   | ✅ 是，`expungeStaleEntry` 会整理数组                         |
| **是否依赖哈希冲突** | ❌ 否，即使无冲突也可能触发                                   | ✅ 是，只有在发生哈希冲突、需要探测时才会体现                 |
| **核心目标**         | **内存安全**：防止 `value` 内存泄漏                          | **功能正确性**：找到目标 entry 或插入位置，**顺便清理**      |

#### 父子线程中传递ThreadLocal

###### `InheritableThreadLocal` 的设计初衷

- 解决 **父子线程间** 的 `ThreadLocal` 数据传递问题。
- 原理：在 `new Thread()` 时，`Thread` 的 `init()` 方法会检查父线程的 `inheritableThreadLocals`，并将其复制给子线程。

```java
// 父线程设置
InheritableThreadLocal<String> itl = new InheritableThreadLocal<>();
itl.set("parent-value");

// 子线程可继承
new Thread(() -> {
    System.out.println(itl.get()); // 输出: parent-value
}).start();
```

###### ❌ 但在线程池场景下失效

- 线程池中的线程是**长期存活、被复用的**。
- `InheritableThreadLocal` 只在 **线程创建时（`init()`）复制一次上下文**。
- 后续提交的任务可能来自不同请求，但复用的线程仍保留上次任务的 `ThreadLocal` 数据，导致：
  - **上下文污染**（一个请求的数据被另一个请求读取）
  - **内存泄漏**（旧数据未清理）
  - **数据错乱**（`traceId` 混乱）

##### 🌰 举个例子说明问题

```java
InheritableThreadLocal<String> userIdThreadLocal = new InheritableThreadLocal<>();

ExecutorService executor = Executors.newFixedThreadPool(2);

// 请求1
userIdThreadLocal.set("user-1001");
executor.submit(() -> {
    log.info("Task1: " + userIdThreadLocal.get()); // 正确：user-1001
});

// 请求2（稍后）
userIdThreadLocal.set("user-1002");
executor.submit(() -> {
    log.info("Task2: " + userIdThreadLocal.get()); // ❌ 可能仍是 user-1001！
});
```

因为线程复用，`InheritableThreadLocal` 不会重新复制，导致 Task2 可能读到旧值。

##### ✅ 解决方案：[TransmittableThreadLocal（TTL）](https://github.com/alibaba/transmittable-thread-local)

阿里巴巴开源的 **TransmittableThreadLocal** 正是为了解决这个问题而诞生的。

###### 🔧 核心能力

- **支持线程池、异步任务（`Runnable`/`Callable`）中的 `ThreadLocal` 传递**
- **支持任意 `Executor`、`CompletableFuture`、`ForkJoinPool` 等**
- **自动清理，防止内存泄漏**
- **高性能，轻量级**

###### 📦 使用方式（简单示例）

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>transmittable-thread-local</artifactId>
    <version>2.12.2</version>
</dependency>
```

```java
// 使用 TtlThreadLocal 替代 InheritableThreadLocal
TtlThreadLocal<String> userIdContext = new TtlThreadLocal<>();
userIdContext.set("user-1001");

// 包装线程池
ExecutorService ttlExecutor = TtlExecutors.getTtlExecutorService(executorService);

ttlExecutor.submit(() -> {
    System.out.println("Task: " + userIdContext.get()); // ✅ 正确输出 user-1001
});
```

###### 🌟 内部原理（简化）

- `TtlRunnable` 和 `TtlCallable` 包装了原始任务，在执行前自动恢复上下文。
- 基于 `InheritableThreadLocal` 增强，通过 `beforeExecute` / `afterExecute` 模型实现传递。
- 支持 `TransmittableThreadLocal.replay()` / `restore()` 实现上下文快照与还原。

##### ✅ 对比表格：三种 ThreadLocal 机制

| 特性                         | `ThreadLocal` | `InheritableThreadLocal` | `TransmittableThreadLocal`       |
| ---------------------------- | ------------- | ------------------------ | -------------------------------- |
| 同一线程内传递               | ✅             | ✅                        | ✅                                |
| 父子进程（`new Thread`）传递 | ❌             | ✅                        | ✅                                |
| 线程池任务传递               | ❌             | ❌                        | ✅                                |
| `CompletableFuture` 支持     | ❌             | ❌                        | ✅（通过 `TtlCompletableFuture`） |
| 自动清理                     | ❌             | ❌                        | ✅（配合 `replay/restore`）       |
| 防止上下文污染               | ❌             | ❌                        | ✅                                |
| 是否开源                     | JDK 内置      | JDK 内置                 | ✅ 阿里开源（MIT 协议）           |
| 适用场景                     | 简单同步流程  | 简单父子线程             | 微服务、异步化、线程池           |

##### ✅ 最佳实践建议

1. **普通场景**：使用 `ThreadLocal` + `try-finally remove()`
2. **简单异步（new Thread）**：可用 `InheritableThreadLocal`
3. **生产级异步（线程池、CompletableFuture）**：**必须使用 `TransmittableThreadLocal`**
4. **结合 MDC**：用 TTL 传递 `traceId`，实现全链路追踪

##### 📚 参考资料

- **TransmittableThreadLocal 官方仓库**：[https://github.com/alibaba/transmittable-thread-local](https://github.com/alibaba/transmittable-thread-local)
- **JavaGuide 原文**：[https://javaguide.cn/java/concurrent/threadlocal.html](https://javaguide.cn/java/concurrent/threadlocal.html)
- **Spring Cloud Sleuth / SkyWalking**：底层也使用类似机制实现分布式追踪

#### PageHelper中的线程污染问题

```java
PageHelper.startPage(1, 10);
try {
    List<User> users = userMapper.selectAll();
    return users;
} finally {
    PageHelper.clear(); // 强制清理 ThreadLocal，最安全！
}
```

| 方案                    | 是否线程安全            | 是否无痛          | 是否推荐           |
| ----------------------- | ----------------------- | ----------------- | ------------------ |
| **MyBatis-Plus 分页**   | ✅（参数传递）           | ✅                 | ⭐⭐⭐⭐⭐              |
| **Spring Data 分页**    | ✅（`Pageable` 参数）    | ✅                 | ⭐⭐⭐⭐☆              |
| **自定义分页工具类**    | ✅（显式参数）           | ✅                 | ⭐⭐⭐⭐☆              |
| **原生 SQL + 动态标签** | ✅                       | ✅                 | ⭐⭐⭐⭐               |
| **PageHelper**          | ❌（依赖 `ThreadLocal`） | ❌（需 `clear()`） | ⚠️ 仅限简单同步场景 |

#### 两次请求保证是一个线程吗

##### . **现代 Web 服务器（如 Tomcat、Jetty、Netty）使用线程池**

- 服务器启动时会创建一个**线程池**（例如：`http-nio-8080-exec-1~200`）。
- 每当有新的 HTTP 请求到来，就从线程池中分配一个线程来处理。
- 处理完成后，线程**归还给线程池**，等待处理下一个请求（可能是其他用户或其他接口）。

👉 所以：

- **第一次请求** → 线程 A 处理
- **第二次请求** → 可能还是线程 A，也可能是线程 B、C……
- **不保证是同一个线程**

```
# 示例日志（来自不同请求）
2025-04-05 10:00:01 [http-nio-8080-exec-3]  INFO c.e.web.UserController - 请求1：查询用户信息
2025-04-05 10:00:05 [http-nio-8080-exec-7]  INFO c.e.web.UserController - 请求2：更新用户信息
```

📌 **记住一句话**：

> **“一个请求，一个上下文；线程复用是常态，清理不净是灾难。”**

如果你正在做微服务或高并发系统，务必通过 `MDC + TraceId + 请求拦截器` 构建清晰的上下文管理机制，而不是依赖线程 identity。



#### Spring Boot2+MDC+拦截器+Logback支持请求上下文追踪

##### 🧩 一、项目结构（Spring Boot 2.7.x）

```bash
src/
├── main/
│   ├── java/
│   │   └── com/example/demo/
│   │       ├── DemoApplication.java
│   │       ├── config/LogbackConfig.java
│   │       ├── interceptor/TraceInterceptor.java
│   │       ├── util/TraceContext.java
│   │       └── controller/UserController.java
│   └── resources/
│       ├── application.yml
│       └── logback-spring.xml
```

---

##### ✅ 二、1. `pom.xml`（Spring Boot 2.7.18）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>springboot-mdc-demo</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version>
        <relativePath/>
    </parent>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

---

##### ✅ 二、2. 上下文工具类：`TraceContext.java`

```java
package com.example.demo.util;

import org.slf4j.MDC;
import java.util.UUID;

/**
 * 使用 MDC 管理请求上下文
 */
public class TraceContext {

    public static final String TRACE_ID = "traceId";
    public static final String USER_ID = "userId";

    public static void setTraceId(String traceId) {
        if (traceId == null || traceId.trim().isEmpty()) {
            traceId = "trace-" + UUID.randomUUID().toString().substring(0, 8);
        }
        MDC.put(TRACE_ID, traceId);
    }

    public static void setUserId(String userId) {
        MDC.put(USER_ID, userId != null ? userId : "anonymous");
    }

    public static String getTraceId() {
        return MDC.get(TRACE_ID);
    }

    public static void clear() {
        MDC.clear(); // ⚠️ 必须清理，防止线程复用污染
    }
}
```

---

##### ✅ 二、3. 拦截器：`TraceInterceptor.java`

```java
package com.example.demo.interceptor;

import com.example.demo.util.TraceContext;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class TraceInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 1. 获取或生成 traceId
        String traceId = request.getHeader("X-Trace-Id");
        TraceContext.setTraceId(traceId);

        // 2. 获取用户ID（模拟从 token 解析）
        String userId = request.getHeader("X-User-Id");
        TraceContext.setUserId(userId);

        // 打印日志便于调试
        System.out.println("[TRACE] 请求开始 | traceId=" + TraceContext.getTraceId() + 
                          ", userId=" + TraceContext.getTraceId());

        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                               Object handler, Exception ex) {
        // ⚠️ 关键：请求结束必须清理 MDC
        TraceContext.clear();
        System.out.println("[TRACE] MDC 上下文已清理");
    }
}
```

---

##### ✅ 二、4. 注册拦截器（`WebConfig.java`）

```java
package com.example.demo.config;

import com.example.demo.interceptor.TraceInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private TraceInterceptor traceInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(traceInterceptor)
                .addPathPatterns("/**")
                .excludePathPatterns("/actuator/**", "/error");
    }
}
```

---

##### ✅ 二、5. `logback-spring.xml`（支持 MDC 输出）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 引入 Spring Boot 默认日志配置 -->
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
    <include resource="org/springframework/boot/logging/logback/console-appender.xml"/>

    <!-- 控制台输出，包含 MDC 字段 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [%X{traceId:-N/A}, %X{userId:-anonymous}] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
    </appender>

    <!-- 根日志器 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

> `%X{traceId:-N/A}` 表示如果 `traceId` 不存在，显示 `N/A`

---

##### ✅ 二、6. `application.yml`

```yaml
server:
  port: 8080

# 启用 logback-spring.xml
logging:
  config: classpath:logback-spring.xml
  level:
    com.example: DEBUG
```

---

##### ✅ 二、7. 控制器示例：`UserController.java`

```java
package com.example.demo.controller;

import com.example.demo.util.TraceContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    private static final Logger log = LoggerFactory.getLogger(UserController.class);

    @GetMapping("/user")
    public String getUser(@RequestHeader(value = "name", required = false) String name) {
        log.info("开始处理用户请求，name={}", name);

        // 模拟异步处理（子线程会继承 MDC）
        new Thread(() -> {
            log.debug("【子线程】正在执行异步任务");
        }).start();

        log.info("用户请求处理完成");
        return "Hello " + name + " [traceId=" + TraceContext.getTraceId() + "]";
    }
}
```

---

##### ✅ 三、启动类：`DemoApplication.java`

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

---

##### ✅ 四、测试验证

###### 1. 发送请求

```bash
curl -H "X-Trace-Id: abc123" \
     -H "X-User-Id: u789" \
     -H "name: 张三" \
     http://localhost:8080/user
```

###### 2. 查看日志输出

```log
2025-04-05 11:10:20.123 [http-nio-8080-exec-1] [abc123, u789] INFO  c.e.d.controller.UserController - 开始处理用户请求，name=张三
2025-04-05 11:10:20.125 [Thread-12] [abc123, u789] DEBUG c.e.d.controller.UserController - 【子线程】正在执行异步任务
2025-04-05 11:10:20.126 [http-nio-8080-exec-1] [abc123, u789] INFO  c.e.d.controller.UserController - 用户请求处理完成
[TRACE] MDC 上下文已清理
```

✅ 所有日志都携带 `traceId` 和 `userId`，且线程复用不会污染！

---

##### ✅ 五、生产环境建议

| 场景                         | 建议                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| **线程池中传递 MDC**         | 使用 [TransmittableThreadLocal](https://github.com/alibaba/transmittable-thread-local) |
| **生成全局唯一 traceId**     | 雪花算法 / Redis / UUID                                      |
| **集成 SkyWalking / Zipkin** | 实现分布式链路追踪                                           |
| **日志采集**                 | 将 MDC 字段输出到 ELK / SLS，便于检索                        |

---

##### 📦 项目打包

你可以将此项目打包为一个 **Starter 模块**，在多个服务中复用：

```java
// 自动配置类（@Configuration + @ConditionalOnMissingBean）
// 提供开关：mdc.tracing.enabled=true/false
```



### Volatile

**`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。** 如果我们将变量声明为 **`volatile`** ，在对这个变量进行读写操作的时候，会通过插入特定的 **内存屏障** 的方式来禁止指令重排序。

在 Java 中，`Unsafe` 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：

```java
public native void loadFence();
public native void storeFence();
public native void fullFence();
```

#### 手写线程安全的单例模式

**双重校验锁实现对象单例（线程安全）**：



```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

`uniqueInstance` 采用 `volatile` 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：

1. 为 `uniqueInstance` 分配内存空间
2. 初始化 `uniqueInstance`
3. 将 `uniqueInstance` 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 `getUniqueInstance`() 后发现 `uniqueInstance` 不为空，因此返回 `uniqueInstance`，但此时 `uniqueInstance` 还未被初始化。



### StampedLock

#### ✅ 正确理解：StampedLock 为什么性能更好？

`StampedLock` 是 Java 8 引入的一种更高效的读写锁机制，相比传统的 `ReentrantReadWriteLock`，其性能优势主要来自于以下几个方面，**其中最关键的是“乐观读”（Optimistic Reading）机制**。

#### 🔍 乐观读（Optimistic Read）是核心优势

- **乐观读允许多个读操作不加锁地进行**，它通过一个“版本戳”（stamp）来标记共享数据的状态。
- 读操作先尝试“乐观读”：获取一个戳（stamp），然后读取数据，最后通过 `validate(stamp)` 检查在这期间是否有写操作发生。
- 如果没有写操作（即戳未失效），则读取的数据是有效的，整个过程**没有加锁**，开销极小。
- 如果有写操作发生（戳失效），则退化为传统的“悲观读锁”。

👉 这意味着：**在读多写少的场景中，大多数读操作可以无锁完成，大大减少了线程调度和锁竞争的开销**。

#### 🔍 写线程的饥饿问题改善

- `StampedLock` 使用了更精细的锁状态管理和公平性策略。
- 它支持锁的**升降级**（如 `tryConvertToWriteLock`），减少了重复加锁的开销。
- 虽然乐观读期间写线程仍会被阻塞，但由于乐观读很快完成（无锁），**写线程等待的时间大大缩短**，从而缓解了写饥饿问题。

#### 🔍 更低的开销和更高的吞吐量

- `StampedLock` 基于 CLH 锁队列的变种实现，内部状态通过 `volatile` 变量和 CAS 操作管理，避免了传统锁的许多开销。
- 没有使用 `AbstractQueuedSynchronizer`（AQS），而是自定义同步机制，更加轻量。
- 在高并发读场景下，性能远超 `ReentrantReadWriteLock`。



#### 📊 对比总结

| 特性             | ReentrantReadWriteLock | StampedLock                |
| ---------------- | ---------------------- | -------------------------- |
| 读锁类型         | 悲观读（阻塞）         | 支持乐观读（无锁）+ 悲观读 |
| 写锁             | 悲观写                 | 悲观写                     |
| 读写竞争         | 读多时写易饥饿         | 乐观读快，写等待时间短     |
| 锁降级/升级      | 支持降级               | 支持转换（tryConvert...）  |
| 性能（读多写少） | 一般                   | 非常高                     |
| 可重入           | 是                     | **否**（注意！）           |
| 实现基础         | AQS                    | 自定义 CAS 状态            |

#### ⚠️ 注意事项

- `StampedLock` **不是可重入的**，同一线程重复获取会死锁。
- 使用乐观读时必须进行 `validate()` 验证，否则无法保证数据一致性。
- 编程模型更复杂，容易出错，需谨慎使用。

#### ✅ 结论

> `StampedLock` 性能更好的**关键原因**是引入了**乐观读机制**，使得在读操作频繁且写操作较少的场景下，大多数读可以**无锁完成**，从而显著减少线程阻塞和上下文切换，提升吞吐量。

写线程的“饥饿问题”是**间接改善**的，因为乐观读执行快，释放快，写线程等待时间变短，而不是因为乐观读“允许写线程获取锁”

### 线程池

#### 核心线程空闲时处于什么状态

核心线程空闲时，其状态分为以下两种情况：

- **设置了核心线程的存活时间** ：核心线程在空闲时，会处于 `WAITING` 状态，等待获取任务。如果阻塞等待的时间超过了核心线程存活时间，则该线程会退出工作，将该线程从线程池的工作线程集合中移除，线程状态变为 `TERMINATED` 状态。
- **没有设置核心线程的存活时间** ：核心线程在空闲时，会一直处于 `WAITING` 状态，等待获取任务，核心线程会一直存活在线程池中。

当队列中有可用任务时，会唤醒被阻塞的线程，线程的状态会由 `WAITING` 状态变为 `RUNNABLE` 状态，之后去执行对应任务。

接下来通过相关源码，了解一下线程池内部是如何做的。

线程在线程池内部被抽象为了 `Worker` ，当 `Worker` 被启动之后，会不断去任务队列中获取任务。

在获取任务的时候，会根据 `timed` 值来决定从任务队列（ `BlockingQueue` ）获取任务的行为。

如果「设置了核心线程的存活时间」或者「线程数量超过了核心线程数量」，则将 `timed` 标记为 `true` ，表明获取任务时需要使用 `poll()` 指定超时时间。

- `timed == true` ：使用 `poll(timeout, unit)` 来获取任务。使用 `poll(timeout, unit)` 方法获取任务超时的话，则当前线程会退出执行（ `TERMINATED` ），该线程从线程池中被移除。
- `timed == false` ：使用 `take()` 来获取任务。使用 `take()` 方法获取任务会让当前线程一直阻塞等待（`WAITING`）。

```java
// ThreadPoolExecutor
private Runnable getTask() {
    boolean timedOut = false;
    for (;;) {
        // ...

        // 1、如果「设置了核心线程的存活时间」或者是「线程数量超过了核心线程数量」，则 timed 为 true。
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
        // 2、扣减线程数量。
        // wc > maximuimPoolSize：线程池中的线程数量超过最大线程数量。其中 wc 为线程池中的线程数量。
        // timed && timeOut：timeOut 表示获取任务超时。
        // 分为两种情况：核心线程设置了存活时间 && 获取任务超时，则扣减线程数量；线程数量超过了核心线程数量 && 获取任务超时，则扣减线程数量。
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }
        try {
            // 3、如果 timed 为 true，则使用 poll() 获取任务；否则，使用 take() 获取任务。
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            // 4、获取任务之后返回。
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

#### CallerRunsPolicy拒绝策略有什么风险？如何解决？

✅ **风险**：因为`CallerRunsPolicy`这个拒绝策略，导致耗时的任务用了主线程执行，导致线程池阻塞，进而导致后续任务无法及时执行，严重的情况下很可能导致 OOM。

✅ **解决办法**：

- 增加阻塞队列的大小
- 调整线程池`maximumPoolSize` （最大线程数）参数，这样可以提高任务处理速度，避免累计在 `BlockingQueue`的任务过多导致内存用完。
- 任务持久化：
  - 设计一张任务表将任务存储到 MySQL 数据库中。
  - Redis 缓存任务。
  - 将任务提交到消息队列中。

#### 线程池中线程异常后，销毁还是复用？

✅ **结论总结：线程池中 `execute()` 与 `submit()` 对异常的处理机制完全不同，需根据使用方式区分对待。**

##### 🔁 一、使用 `execute()` 提交任务
- **异常未被捕获时**：  
  → 会**导致当前执行线程终止**。  
  → 异常默认打印到控制台（通过线程的 `UncaughtExceptionHandler`）。  
- **线程池行为**：  
  → 检测到线程终止后，会**自动创建一个新线程**来维持线程池的基本大小。  
- **适用场景**：  
  → 不关心任务结果，仅提交任务执行。

📌 **示例：**
```java
executor.execute(() -> {
    throw new RuntimeException("Task failed!");
});
// 结果：线程崩溃，日志输出异常，线程池补一个新线程
```

##### 📦 二、使用 `submit()` 提交任务
- **异常发生时**：  
  → 异常**不会导致线程终止**，线程可继续复用。  
  → 异常被**封装在 `Future` 对象中**。  
- **获取异常的方式**：  
  → 调用 `future.get()` 时，抛出 `ExecutionException`，通过 `.getCause()` 获取原始异常。  
- **适用场景**：  
  → 需要获取任务执行结果或处理异常。

📌 **示例：**
```java
Future<?> future = executor.submit(() -> {
    throw new RuntimeException("Task failed!");
});

try {
    future.get(); // 此处抛出 ExecutionException
} catch (ExecutionException e) {
    Throwable cause = e.getCause(); // 获取原始异常
    System.out.println("Actual error: " + cause);
}
// 结果：线程正常，继续处理后续任务
```

##### 🆚 对比总结

| 特性                 | `execute()`            | `submit()`                                      |
| -------------------- | ---------------------- | ----------------------------------------------- |
| **返回值**           | 无（void）             | `Future<T>`                                     |
| **异常是否终止线程** | ✅ 是                   | ❌ 否                                            |
| **异常是否自动打印** | ✅ 是（到日志）         | ❌ 否（需调用 `get()` 才暴露）                   |
| **异常处理方式**     | 无法捕获，只能靠日志   | 可通过 `Future.get()` 捕获 `ExecutionException` |
| **线程是否复用**     | 否（线程挂了，需重建） | 是（线程继续执行其他任务）                      |
| **适用场景**         | “即发即忘”任务         | 需要结果或错误处理的任务                        |

##### ✅ 最佳实践建议

1. **使用 `submit()` + `try-catch(future.get())`**  
   → 更安全，可控制异常处理逻辑。

2. **在 `execute()` 的任务中主动捕获异常**  
   → 防止线程意外终止：
   ```java
   executor.execute(() -> {
       try {
           // 业务逻辑
       } catch (Exception e) {
           log.error("Task error", e);
       }
   });
   ```

3. **设置全局异常处理器（可选）**  
   ```java
   Thread.setDefaultUncaughtExceptionHandler((t, e) -> {
       log.error("Uncaught exception in thread " + t.getName(), e);
   });
   ```

#### 如何给线程池命名?

初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。

默认情况下创建的线程名字类似 `pool-1-thread-n` 这样的，没有业务含义，不利于我们定位问题。

给线程池里的线程命名通常有下面两种方式：

**1、利用 guava 的 `ThreadFactoryBuilder`**

```java
ThreadFactory threadFactory = new ThreadFactoryBuilder()
                        .setNameFormat(threadNamePrefix + "-%d")
                        .setDaemon(true).build();
ExecutorService threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);
```

**2、自己实现 `ThreadFactory`。**

```java
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 线程工厂，它设置线程名称，有利于我们定位问题。
 */
public final class NamingThreadFactory implements ThreadFactory {

    private final AtomicInteger threadNum = new AtomicInteger();
    private final String name;

    /**
     * 创建一个带名字的线程池生产工厂
     */
    public NamingThreadFactory(String name) {
        this.name = name;
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r);
        t.setName(name + " [#" + threadNum.incrementAndGet() + "]");
        return t;
    }
}
```

#### 如何设定线程池的大小?

- **CPU 密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

线程数更严谨的计算的方法应该是：`最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））`，其中 `WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）`。

线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。

我们可以通过 JDK 自带的工具 VisualVM 来查看 `WT/ST` 比例。

CPU 密集型任务的 `WT/ST` 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。

IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。



#### 如何动态修改线程池的参数?

 虽然 `ThreadPoolExecutor` 提供了以下方法来修改参数，但**并非所有参数都能真正“动态生效”**：

| 参数              | 动态修改方法               | 是否真正动态生效             |
| ----------------- | -------------------------- | ---------------------------- |
| `corePoolSize`    | `setCorePoolSize(int)`     | ✅ 是（会触发线程创建或回收） |
| `maximumPoolSize` | `setMaximumPoolSize(int)`  | ✅ 是（影响后续线程扩容）     |
| `workQueue`       | ❌ 无 `setWorkQueue()` 方法 | ❌ 否（队列一旦设置不可更改） |

> ⚠️ **关键点**：
>
> - `corePoolSize` 和 `maximumPoolSize` 可以通过 API 动态调整。
> - **`workQueue` 无法直接动态修改**。若需实现队列容量的动态调整（如动态扩容），必须**自定义队列**，例如美团开源方案中提到的 `ResizableCapacityLinkedBlockIngQueue` —— 通过移除 `LinkedBlockingQueue` 中 `capacity` 的 `final` 修饰，使其容量可变。

#### 如何设计一个能够根据任务的优先级来执行的线程池？

假如我们需要实现一个优先级任务线程池的话，那可以考虑使用 `PriorityBlockingQueue` （优先级阻塞队列）作为任务队列

`PriorityBlockingQueue` 是一个支持优先级的无界阻塞队列，可以看作是线程安全的 `PriorityQueue`，两者底层都是使用小顶堆形式的二叉堆，即值最小的元素优先出队。不过，`PriorityQueue` 不支持阻塞操作。

要想让 `PriorityBlockingQueue` 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：

1. 提交到线程池的任务实现 `Comparable` 接口，并重写 `compareTo` 方法来指定任务之间的优先级比较规则。
2. 创建 `PriorityBlockingQueue` 时传入一个 `Comparator` 对象来指定任务之间的排序规则(推荐)。

不过，这存在一些风险和问题，比如：

- `PriorityBlockingQueue` 是无界的，可能堆积大量的请求，从而导致 OOM。
- 可能会导致饥饿问题，即低优先级的任务长时间得不到执行。
- 由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 `ReentrantLock`），因此会降低性能。

对于 OOM 这个问题的解决比较简单粗暴，就是继承`PriorityBlockingQueue` 并重写一下 `offer` 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 false 。

饥饿问题这个可以通过优化设计来解决（比较麻烦），比如等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。

对于性能方面的影响，是没办法避免的，毕竟需要对任务进行排序操作。并且，对于大部分业务场景来说，这点性能影响是可以接受的。



#### `executor.submit()` 算不算“创建线程”？

##### 🔹 答案：**不一定**。

`executor.submit()` **本身不是创建线程**，而是**向线程池提交任务**。

是否创建线程，取决于**线程池的当前状态**：

| 情况                                               | 是否创建线程                   |
| -------------------------------------------------- | ------------------------------ |
| 线程池中线程数 < 核心线程数（corePoolSize）        | ✅ 会创建新线程                 |
| 当前线程数 < 最大线程数（maxPoolSize），且队列已满 | ✅ 可能创建新线程               |
| 已达最大线程数或队列未满                           | ❌ 不创建线程，任务入队或被拒绝 |

##### 📌 示例说明：

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

executor.submit(() -> System.out.println("Task 1")); // 可能创建线程
executor.submit(() -> System.out.println("Task 2")); // 可能创建线程
executor.submit(() -> System.out.println("Task 3")); // 任务入队，不创建新线程
```

- 前两个任务会创建或复用线程。
- 第三个任务放入队列等待，**不创建新线程**。

##### ✅ 关键区别：创建线程 vs 提交任务

| 对比项                   | 创建线程（new Thread().start()） | 使用 `executor.submit()`                                   |
| ------------------------ | -------------------------------- | ---------------------------------------------------------- |
| 是否直接控制线程生命周期 | ✅ 是                             | ❌ 否（由线程池管理）                                       |
| 是否立即创建线程         | ✅ 是                             | ⚠️ 不一定（按需创建）                                       |
| 资源管理                 | ❌ 手动管理，易失控               | ✅ 线程复用，高效可控                                       |
| 是否属于“创建线程”       | ✅ 是                             | 🔄 是“可能触发线程创建”的操作，但**本身不是创建线程的动作*# |

#### 监测线程池的运行状态

你可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件。

除此之外，我们还可以利用 `ThreadPoolExecutor` 的相关 API 做一个简陋的监控。从下图可以看出， `ThreadPoolExecutor`提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。

你提供的 `printThreadPoolStatus` 方法是一个用于**周期性打印线程池状态**的工具方法。要让它“运行”起来，你需要做两件事：

1.  **调用这个方法**，传入一个实际的 `ThreadPoolExecutor` 对象。
2.  **确保日志能输出**（即 `log.info(...)` 能正常工作）。

##### ✅ 步骤一：准备一个线程池

首先，你需要有一个 `ThreadPoolExecutor` 实例。例如：

```java
import java.util.concurrent.*;

public class ThreadPoolMonitorExample {

    private static final Logger log = LoggerFactory.getLogger(ThreadPoolMonitorExample.class);

    public static void main(String[] args) {
        // 创建一个线程池
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
            2,                    // 核心线程数
            4,                    // 最大线程数
            60L,                  // 空闲线程存活时间
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(10), // 任务队列
            new ThreadFactoryBuilder().setNameFormat("demo-worker-%d").build()
        );

        // 👉 调用你的打印方法
        printThreadPoolStatus(threadPool);

        // 提交一些任务，观察输出
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            threadPool.submit(() -> {
                log.info("Task {} is running...", taskId);
                try {
                    Thread.sleep(3000); // 模拟耗时操作
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                log.info("Task {} is done.", taskId);
            });
        }

        // 保持主线程运行，以便看到周期性输出
        try {
            Thread.sleep(20000); // 观察20秒
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        threadPool.shutdown();
    }

    // 你提供的方法（需要稍作调整）
    public static void printThreadPoolStatus(ThreadPoolExecutor threadPool) {
        ScheduledExecutorService scheduledExecutorService = 
            new ScheduledThreadPoolExecutor(
                1, 
                r -> {
                    Thread t = new Thread(r, "monitor-thread-pool-status");
                    t.setDaemon(true); // 设置为守护线程，避免阻塞JVM退出
                    return t;
                }
            );

        scheduledExecutorService.scheduleAtFixedRate(() -> {
            log.info("=========================");
            log.info("ThreadPool Size: [{}]", threadPool.getPoolSize());
            log.info("Active Threads: {}", threadPool.getActiveCount());
            log.info("Completed Tasks : {}", threadPool.getCompletedTaskCount());
            log.info("Tasks in Queue: {}", threadPool.getQueue().size());
            log.info("=========================");
        }, 0, 1, TimeUnit.SECONDS);
    }

    // 如果使用了 guava，可以用 ThreadFactoryBuilder
    // 否则上面用了 lambda 简化
}
```

##### ✅ 步骤二：添加日志依赖（如使用 SLF4J + Logback）

在 `pom.xml` 中加入：

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.36</version>
</dependency>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.11</version>
</dependency>
```

##### ✅ 输出示例

运行后你会看到类似如下周期性输出（每秒一次）：

```
=========================
ThreadPool Size: [2]
Active Threads: 2
Completed Tasks : 0
Tasks in Queue: 3
=========================
```

随着任务完成，`Completed Tasks` 会增加，队列和活跃线程数会变化。

##### ⚠️ 注意事项

1.  **`createThreadFactory` 方法缺失**：
    你代码中的 `createThreadFactory(...)` 是自定义方法，我用 lambda 替代了它。如果你有这个工具类，可以保留；否则建议用 `Executors.defaultThreadFactory()` 或 Guava 的 `ThreadFactoryBuilder`。

2.  **内存与资源泄漏风险**：
    `ScheduledExecutorService` 不会自动停止。如果线程池长期运行，没问题；但如果只是临时监控，建议提供关闭机制：

    ```java
    public static ScheduledExecutorService printThreadPoolStatus(ThreadPoolExecutor threadPool) {
        ScheduledExecutorService scheduler = new ScheduledThreadPoolExecutor(1, ...);
        ScheduledFuture<?> future = scheduler.scheduleAtFixedRate(() -> { ... }, 0, 1, TimeUnit.SECONDS);
        
        // 可以返回 future 或 scheduler，便于后续调用 future.cancel(true) 停止
        return scheduler;
    }
    ```

3.  **生产环境慎用**：
    每秒打印一次日志可能太多，建议改为每 5~10 秒一次，避免日志爆炸。

### 创建线程有几种方式？

在 Java 中，**真正“创建线程”** 的方式本质上只有一种：**创建 `Thread` 对象并调用其 `start()` 方法**。

但根据实现方式，通常说有 **4 种常用方式** 来“启动一个新线程”：

#### 1. 继承 `Thread` 类
```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running");
    }
}
new MyThread().start();
```

#### 2. 实现 `Runnable` 接口
```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread running");
    }
}
new Thread(new MyRunnable()).start();
```

#### 3. 实现 `Callable` 接口 + `FutureTask`
```java
Callable<String> task = () -> "Result";
FutureTask<String> futureTask = new FutureTask<>(task);
new Thread(futureTask).start();
```

#### 4. 使用匿名内部类或 Lambda 表达式（本质同 2 或 3）
```java
new Thread(() -> System.out.println("Hello")).start();
```

> ✅ **总结**：以上 4 种方式都**直接创建了 `Thread` 对象并调用 `start()`**，属于“显式创建线程”

### CompletableFuture

当然，以下是 **`CompletableFuture`** 的全面总结，涵盖其核心功能、常用 API、使用场景、最佳实践以及注意事项，适用于 Java 8+ 的异步编程开发。

#### ✅ 什么是 CompletableFuture？

`CompletableFuture` 是 Java 8 引入的位于 `java.util.concurrent` 包下的一个类，实现了 `Future` 和 `CompletionStage` 接口，用于支持**异步编程、函数式编程和任务编排**。

> 🎯 它解决了传统 `Future` 的痛点：
> - 无法手动完成（complete）
> - 不能链式调用
> - 需要 `get()` 阻塞获取结果

`CompletableFuture` 支持：
- **非阻塞回调**
- **任务编排（串行、并行、聚合）**
- **异常处理**
- **自定义线程池**

#### ✅ 核心特性

| 特性         | 说明                                                      |
| ------------ | --------------------------------------------------------- |
| ✅ 异步执行   | 可在指定线程池中异步执行任务                              |
| ✅ 非阻塞回调 | 任务完成后自动触发回调函数                                |
| ✅ 函数式编程 | 支持 `thenApply`, `thenAccept`, `thenRun` 等链式操作      |
| ✅ 组合与聚合 | 支持 `thenCompose`, `thenCombine`, `allOf`, `anyOf`       |
| ✅ 异常处理   | 支持 `exceptionally`, `handle`, `whenComplete`            |
| ✅ 手动完成   | 可通过 `complete()` 或 `completeExceptionally()` 手动结束 |

#### ✅ 常用 API 分类总结

#####  **创建异步任务**

| 方法                                                         | 说明                                     |
| ------------------------------------------------------------ | ---------------------------------------- |
| `CompletableFuture.runAsync(Runnable runnable)`              | 无返回值，使用 ForkJoinPool.commonPool() |
| `CompletableFuture.runAsync(Runnable runnable, Executor executor)` | 指定线程池，无返回值                     |
| `CompletableFuture.supplyAsync(Supplier<U> supplier)`        | 有返回值，使用默认线程池                 |
| `CompletableFuture.supplyAsync(Supplier<U> supplier, Executor executor)` | 指定线程池，有返回值 ✅ 推荐              |

> ⚠️ 建议始终**传入自定义线程池**，避免使用默认公共线程池（影响其他任务）。

```java
ExecutorService executor = Executors.newFixedThreadPool(4);
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return "Hello from async thread";
}, executor);
```

#####  **链式处理（串行）**

| 方法                        | 返回值                    | 是否消费结果             |
| --------------------------- | ------------------------- | ------------------------ |
| `thenApply(Function<T, U>)` | `CompletableFuture<U>`    | ✅ 转换结果               |
| `thenAccept(Consumer<T>)`   | `CompletableFuture<Void>` | ✅ 消费结果，无返回       |
| `thenRun(Runnable)`         | `CompletableFuture<Void>` | ❌ 不消费结果，只执行后续 |

```java
CompletableFuture.supplyAsync(() -> "Hello")
    .thenApply(s -> s + " World")
    .thenAccept(System.out::println);
```

##### **组合与聚合**

| 方法                                                       | 说明                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| `thenCompose(Function<T, CompletableFuture<U>>)`           | 用于**串行组合**，flatMap 类似，前一个任务返回的是 `CompletableFuture` |
| `thenCombine(CompletableFuture<U>, BiFunction<T,U,R>)`     | **并行执行两个任务**，合并结果                               |
| `CompletableFuture.allOf(CompletableFuture<?>... futures)` | 等待**所有任务完成**，返回 `CompletableFuture<Void>`         |
| `CompletableFuture.anyOf(CompletableFuture<?>... futures)` | 等待**任一任务完成**，返回 `CompletableFuture<Object>`       |

```java
// 并行执行两个任务并合并结果
CompletableFuture<String> f1 = supplyAsync(() -> "Hello");
CompletableFuture<String> f2 = supplyAsync(() -> "World");

f1.thenCombine(f2, (a, b) -> a + " " + b).thenAccept(System.out::println);

// 所有任务完成
CompletableFuture<Void> all = CompletableFuture.allOf(f1, f2);
all.thenRun(() -> System.out.println("All done!"));
```

##### **异常处理**

| 方法                                     | 说明                                            |
| ---------------------------------------- | ----------------------------------------------- |
| `exceptionally(Function<Throwable, T>)`  | 捕获异常并返回默认值（类似 try-catch）          |
| `handle(BiFunction<T, Throwable, R>)`    | 无论是否异常都执行，可统一处理结果和异常 ✅ 推荐 |
| `whenComplete(BiConsumer<T, Throwable>)` | 类似 `handle`，但不改变返回值，仅用于日志或清理 |

```java
CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("Oops!");
})
.exceptionally(ex -> "Fallback Value")
.thenAccept(System.out::println); // 输出: Fallback Value
```

```java
.handle((result, ex) -> {
    if (ex != null) {
        log.error("Error occurred", ex);
        return "Default";
    }
    return result;
});
```

##### **获取结果**

| 方法                               | 行为                                         |
| ---------------------------------- | -------------------------------------------- |
| `get()`                            | 阻塞等待，直到结果返回（可能抛异常）         |
| `get(long timeout, TimeUnit unit)` | 超时等待                                     |
| `join()`                           | 阻塞等待，但**不抛检查异常**，推荐在流中使用 |
| `isDone()`                         | 判断是否完成                                 |

```java
String result = future.join(); // 推荐用于函数式链式调用
```

#### ✅ 典型使用场景

| 场景                 | 示例                                 |
| -------------------- | ------------------------------------ |
| 🔹 异步加载数据       | 用户信息、配置、缓存预热             |
| 🔹 并行调用多个服务   | 查询用户、订单、积分并聚合           |
| 🔹 超时控制           | `orTimeout()`, `completeOnTimeout()` |
| 🔹 链路追踪上下文传递 | 需结合 `TransmittableThreadLocal`    |
| 🔹 重试机制           | 结合 `handle` + 递归或循环实现       |

#### ✅ 最佳实践

1. ✅ **始终使用自定义线程池**
   ```java
   ExecutorService executor = new ThreadPoolExecutor(...);
   supplyAsync(task, executor);
   ```

2. ✅ **优先使用 `handle()` 而非 `exceptionally()`**
   - 更灵活，可同时处理成功和失败情况。

3. ✅ **避免阻塞主线程**
   - 尽量使用回调（`thenAccept` 等），而非频繁调用 `get()`。

4. ✅ **使用 `allOf().join()` 等待多个任务**
   - 注意：`allOf` 返回 `Void`，需手动获取各 future 的结果。

5. ✅ **关闭线程池**
   ```java
   executor.shutdown();
   ```

6. ✅ **考虑上下文传递**
   - 使用 [TransmittableThreadLocal](https://github.com/alibaba/transmittable-thread-local) 解决 `ThreadLocal` 在异步线程中丢失问题。

##### ✅ 常见面试题（精要）

1. **`CompletableFuture` 和 `Future` 的区别？**
   - `Future` 不能回调、不能组合、必须 `get()` 阻塞；
   - `CompletableFuture` 支持异步回调、链式组合、异常处理。

2. **`thenApply` 和 `thenCompose` 的区别？**
   - `thenApply`：同步转换结果；
   - `thenCompose`：用于链式异步任务（flatMap）。

3. **如何实现一个任务依赖另外两个任务执行完再执行？**
   ```java
   CompletableFuture.allOf(f1, f2).thenRun(() -> System.out.println("All done"));
   ```

4. **`allOf` 和 `anyOf` 的返回值是什么？**
   - `allOf` 返回 `CompletableFuture<Void>`
   - `anyOf` 返回 `CompletableFuture<Object>`

##### ✅ 注意事项

- ❌ 不要使用默认线程池（`ForkJoinPool.commonPool()`），避免被其他任务影响。
- ❌ `CompletableFuture` 默认不会处理异常，若不调用 `get/join/handle`，异常可能被“吞掉”。
- ⚠️ `allOf` 的结果是 `Void`，需单独获取每个 future 的结果。
- ⚠️ 异步任务中的 `ThreadLocal` 上下文会丢失，需使用 TTL 解决。

### AQS

**AQS**（`AbstractQueuedSynchronizer`）是 Java `java.util.concurrent`（JUC）包中的核心基础框架类，由 Doug Lea 编写，用于构建**锁（Lock）和同步器（Synchronizer）** 的基础框架。

> 🎯 它提供了一种基于**FIFO 等待队列**的**多线程访问共享资源的同步机制**。

AQS 的典型应用包括：
- `ReentrantLock`
- `Semaphore`
- `CountDownLatch`
- `ReentrantReadWriteLock`
- `ThreadPoolExecutor.Worker`（内部使用）

#### AQS和自旋锁

##### ✅ 自旋锁存在的问题

**自旋锁（Spin Lock）** 的基本思想是：当一个线程尝试获取锁失败时，它不会立即阻塞，而是进入一个循环（“自旋”），不断尝试获取锁，直到成功为止。

典型的实现方式是通过 **CAS（Compare-and-Swap）** 操作来修改一个共享的原子变量（如 `state`）。

###### ❌ 存在的主要问题：

1. **高竞争下的性能下降**
    在高并发场景下，多个线程同时对同一个原子变量执行 CAS 操作，会导致大量的 CAS 失败。CPU 资源被浪费在无效的重试上。
2. **“饥饿”问题（Starvation）**
    由于没有调度顺序保证，某些线程可能始终抢不到锁。例如，新来的线程可能“插队”成功，而已经自旋等待很久的线程一直失败，造成不公平。
3. **缓存一致性流量压力大**
    多个线程频繁读写同一个共享变量，会导致 CPU 缓存行在多个核心之间频繁失效和同步（即“缓存颠簸”），严重影响性能。

##### ✅ CLH 锁的改进思路

**CLH 锁（Craig, Landin, and Hagersten Locks）** 是一种基于隐式链表的公平自旋锁，核心思想是：

> **将对共享变量的竞争，转化为对各自前驱节点状态的监听。**

##### 🔧 实现机制：

- 每个线程对应一个节点（Node），节点中有一个 `locked` 字段，表示该节点是否仍在等待/持有锁。
- 线程尝试获取锁时，会创建节点并将其插入到队列尾部（通过原子操作保证）。
- 每个线程只**自旋检查其前驱节点的 `locked` 状态**，而不是所有线程都竞争同一个变量。
- 当前驱节点释放锁（`locked = false`）时，当前线程就知道轮到自己了，于是退出自旋，获得锁。

##### ✅ 优点：

1. **公平性保障（FIFO）**
    线程按申请顺序排队，先来先服务，避免了饥饿问题。
2. **降低缓存争用**
    每个线程只监听自己的前驱节点，不同线程访问的内存地址不同，减少了缓存一致性流量。
3. **避免全局竞争**
    不再所有线程都去 CAS 同一个变量，而是通过链表结构分散竞争。

##### CLH锁 与 AQS 的关系

Java 中的 **AQS（AbstractQueuedSynchronizer）** 正是借鉴了 CLH 锁的思想，并进行了优化：

- **自旋 + 阻塞**： CLH 锁使用纯自旋方式等待锁的释放，但大量的自旋操作会占用过多的 CPU 资源。AQS 引入了自旋 + 阻塞的混合机制： 
  - 如果线程获取锁失败，会先短暂自旋尝试获取锁；
  - 如果仍然失败，则线程会进入阻塞状态，等待被唤醒，从而减少 CPU 的浪费。
- **单向队列改为双向队列**：CLH 锁使用单向队列，节点只知道前驱节点的状态，而当某个节点释放锁时，需要通过队列唤醒后续节点。AQS 将队列改为 **双向队列**，新增了 `next` 指针，使得节点不仅知道前驱节点，也可以直接唤醒后继节点，从而简化了队列操作，提高了唤醒效率。

> ⚠️ 注意：AQS 并非完全等同于 CLH，而是“CLH 的变种”——使用了双向链表便于取消和中断处理，且自旋策略更复杂。

##### ✅ 总结

| 特性               | 传统自旋锁                 | 原始 CLH 锁                      | AQS 变种 CLH 锁（JUC 基石）                       |
| ------------------ | -------------------------- | -------------------------------- | ------------------------------------------------- |
| **公平性**         | 不保证                     | 保证（FIFO）                     | 保证（可配置公平/非公平）                         |
| **竞争方式**       | 所有线程争抢同一变量       | 线程自旋前驱节点的 `locked` 状态 | 线程自旋前驱节点的 `waitStatus`                   |
| **缓存友好性**     | 差（缓存颠簸严重）         | 好（避免全局争用）               | 较好（但略逊于原始 CLH）                          |
| **是否解决“饥饿”** | 否                         | 是                               | 是（公平模式下）                                  |
| **底层结构**       | 单一原子变量（如 `state`） | 隐式单向链表（通过 `pred` 指针） | **双向链表**（`prev` 和 `next`）                  |
| **节点取消支持**   | 不支持                     | 支持有限（需复杂处理）           | **支持良好**（通过 `prev`/`next` 快速剔除）       |
| **中断响应**       | 无                         | 难以实现                         | **支持**（可响应线程中断）                        |
| **条件队列支持**   | 无                         | 无                               | **支持**（通过 `ConditionObject`）                |
| **典型应用**       | 简单同步原语               | 学术模型 / 早期并发算法          | `ReentrantLock`、`Semaphore`、`CountDownLatch` 等 |

#### AQS 的核心思想

AQS 的核心思想是：**用一个 `volatile int state` 来表示同步状态，通过 CAS 操作修改状态，并用一个双向链表构成的 FIFO 队列管理等待线程。**

🔑 三大核心要素：

| 组件           | 作用                                                       |
| -------------- | ---------------------------------------------------------- |
| `state`        | 表示同步状态（如：锁是否被占用、信号量许可数、倒计时次数） |
| `CAS` 操作     | 原子性更新 `state`，保证线程安全                           |
| `变体CLH 队列` | 双向链表队列，存储等待获取锁的线程（实际是 Node 节点）     |

#### ✅ AQS 的工作原理

##### **state 状态管理**
- `private volatile int state` 是 AQS 的核心变量。
- 子类通过 `getState()`、`setState(int)`、`compareAndSetState(int, int)` 来读写状态。
- 不同的同步器对 `state` 的解释不同：
  - `ReentrantLock`：0 表示无锁，1 表示已锁，>1 表示重入次数。
  - `Semaphore`：表示可用许可数。
  - `CountDownLatch`：表示倒计时次数。

##### **两种模式：独占（Exclusive） vs 共享（Shared）**

| 模式         | 说明                               | 典型实现                                                     |
| ------------ | ---------------------------------- | ------------------------------------------------------------ |
| **独占模式** | 同一时刻只有一个线程能获取同步状态 | `ReentrantLock`、`ReentrantReadWriteLock.WriteLock`          |
| **共享模式** | 多个线程可同时获取同步状态         | `Semaphore`、`CountDownLatch`、`ReentrantReadWriteLock.ReadLock` |

AQS 提供了两套 API：
- `tryAcquire` / `tryRelease` → 独占模式
- `tryAcquireShared` / `tryReleaseShared` → 共享模式

子类需根据需求重写这些方法。

##### **线程阻塞与唤醒机制**

AQS 不直接阻塞线程，而是依赖 `LockSupport.park()` 和 `LockSupport.unpark()` 实现线程的挂起与唤醒。

- 获取锁失败 → 将线程封装成 `Node` 加入等待队列 → 调用 `park()` 阻塞。
- 释放锁成功 → 调用 `unpark()` 唤醒队列中的下一个线程。

#####  **CLH 队列（同步队列）**

- AQS 内部维护一个**双向链表**（CLH 变种），称为**同步队列（Sync Queue）**。
- 每个节点（`Node`）代表一个等待线程，包含：
  - 线程引用
  - 等待状态（`waitStatus`）
  - 前驱和后继节点
- 当线程竞争锁失败时，会被加入队尾；头节点（`head`）是当前持有锁的线程（或刚释放的）。

> ⚠️ 注意：AQS 还支持**条件队列（Condition Queue）**，用于实现 `await()` / `signal()`，如 `ReentrantLock.newCondition()`。

#### ✅ AQS 的关键 API（子类需重写）

| 方法                    | 说明                                   | 模式 |
| ----------------------- | -------------------------------------- | ---- |
| `tryAcquire(int)`       | 尝试获取同步状态（不可重入需自己实现） | 独占 |
| `tryRelease(int)`       | 尝试释放同步状态                       | 独占 |
| `tryAcquireShared(int)` | 尝试获取共享状态，返回负值表示失败     | 共享 |
| `tryReleaseShared(int)` | 尝试释放共享状态                       | 共享 |
| `isHeldExclusively()`   | 当前线程是否独占同步状态（如可重入锁） | 独占 |

> ✅ AQS 已实现 `acquire`、`release` 等模板方法，子类只需重写上述 `tryXxx` 方法即可。

#### ✅ 常见 AQS 实现类对比

| 类                       | 模式        | state 含义                     | 用途                  |
| ------------------------ | ----------- | ------------------------------ | --------------------- |
| `ReentrantLock`          | 独占        | 0=无锁，1=锁定，>1=重入次数    | 可重入互斥锁          |
| `Semaphore`              | 共享        | 可用许可数                     | 限流、资源池          |
| `CountDownLatch`         | 共享        | 倒计时次数（从 N 到 0）        | 等待 N 个任务完成     |
| `CyclicBarrier`          | 共享        | 参与线程数                     | 等待 N 个线程到达屏障 |
| `ReentrantReadWriteLock` | 独占 + 共享 | 高 16 位写锁，低 16 位读锁计数 | 读写分离锁            |

| 对比项       | `CountDownLatch`                 | `CyclicBarrier`               |
| ------------ | -------------------------------- | ----------------------------- |
| **计数方向** | 递减（从 N 到 0）                | 递增（从 0 到 N）             |
| **触发条件** | 计数器减到 0                     | 达到预设数量                  |
| **可重用性** | ❌ 不可重用（计数器不能重置）     | ✅ 可重用（可 `reset()` 重置） |
| **等待方式** | 一个或多个线程等待“其他线程完成” | 多个线程互相等待“彼此到达”    |
| **底层实现** | AQS（共享模式）                  | `ReentrantLock` + `Condition` |
| **典型场景** | 主线程等待多个子任务完成         | 多个线程协同，分阶段执行      |

```java
CountDownLatch latch = new CountDownLatch(3);

for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " 完成任务");
        latch.countDown(); // 计数减1
    }).start();
}

System.out.println("主线程等待...");
latch.await(); // 阻塞，直到计数为0
System.out.println("所有任务完成，主线程继续");
```

```java
CyclicBarrier barrier = new CyclicBarrier(3, () -> {
    System.out.println("所有线程已到达，开始下一阶段");
});

for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " 到达第一阶段");
        try {
            barrier.await(); // 等待其他线程
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " 进入第二阶段");
    }).start();
}
```



#### ✅ AQS 的典型使用流程（以 `ReentrantLock` 为例）

```java
ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    // 临界区
} finally {
    lock.unlock();
}
```

底层流程：
1. 调用 `lock()` → 尝试 `CAS` 修改 `state` 从 0 到 1。
2. 成功：当前线程获得锁。
3. 失败：将线程封装为 `Node` 加入 CLH 队列，`park()` 阻塞。
4. 调用 `unlock()` → `state` 减 1，若为 0 则释放锁，唤醒后继节点。

#### ✅ 面试常见问题（精要）

1. **AQS 是什么？它的核心原理？**  
   > AQS 是构建锁和同步器的基础框架，核心是 `state + CLH 队列 + CAS`，通过模板方法模式实现独占/共享模式。

2. **AQS 如何实现线程等待？**  
   > 失败线程被封装成 `Node` 加入 CLH 队列，调用 `LockSupport.park()` 阻塞。

3. **ReentrantLock 是如何基于 AQS 实现的？**  
   > 非公平锁：先 CAS 抢锁，失败则入队；公平锁：直接入队。`state` 表示锁状态和重入次数。

4. **CountDownLatch 和 CyclicBarrier 的区别？**  
   > - `CountDownLatch`：计数递减到 0，**不可重用**，基于 AQS 共享模式。  
   > - `CyclicBarrier`：线程到达后等待，**可重用**，基于 `ReentrantLock + Condition`。

5. **Semaphore 的实现原理？**  
   > 基于 AQS 共享模式，`state` 表示许可数，`acquire` 成功则 `state` 减 1，`release` 则加 1。

#### ✅ 总结一句话

> **AQS 是 Java 并发包的基石，通过 “state + CLH 队列 + 模板方法” 实现了锁与同步器的统一框架，是 `ReentrantLock`、`Semaphore`、`CountDownLatch` 等并发工具的底层支撑。掌握 AQS，就掌握了 Java 高并发的“心脏”** ✅

### 缓存一致性

在多核 CPU 系统中，每个核心通常都有自己的高速缓存（如 L1、L2 缓存），当多个核心同时访问和修改共享的内存数据时，就可能出现**缓存一致性问题**——即不同核心的缓存中可能保存了同一内存地址的不同副本，导致数据不一致。

为了解决这个问题，CPU 厂商引入了**缓存一致性协议**（Cache Coherence Protocol），其中最典型的就是 **MESI 协议**（Modified, Exclusive, Shared, Invalid）。

- 缓存一致性问题是多核系统中的核心挑战。
- MESI 是最经典的缓存一致性协议之一。
- 不同 CPU 架构可能采用不同的协议（如 Intel、AMD 的实现略有差异）。
- 硬件层面的协议保证了缓存一致性，但上层语言（如 Java）仍需通过内存模型（JMM）来规范并发行为。

#### MESI 协议简介：

MESI 是一种基于“监听”（snooping）的缓存一致性协议，它通过为每个缓存行（Cache Line）设置四种状态来维护一致性：

- **M（Modified）**：缓存行已被修改，与主存不一致，但只存在于当前缓存中。
- **E（Exclusive）**：缓存行未被修改，与主存一致，且仅存在于当前缓存中。
- **S（Shared）**：缓存行未被修改，可能存在于多个缓存中。
- **I（Invalid）**：缓存行无效，不能使用。

当某个 CPU 核心修改了某个数据时，MESI 协议会通过总线监听机制通知其他核心将对应的缓存行置为无效，从而保证只有一个核心可以写数据，其他核心在读取时必须从主存或其他缓存中获取最新值。

#### 其他缓存一致性手段：

除了 MESI 协议，还有其他缓存一致性协议，例如：
- **MOESI**：在 MESI 基础上增加了“Owned”状态，支持缓存到缓存的数据传输，提升性能。
- **MESIF**（Intel 使用）：类似 MOESI，用于优化读共享场景。
- **Dragon Protocol**、**Firefly Protocol**：适用于更复杂的系统架构。

此外，现代 CPU 还通过**内存屏障**（Memory Barrier）、**写缓冲区**（Write Buffer）、**无效队列**（Invalidate Queue）等机制来优化性能，同时也给程序员带来了更高的复杂性，因此需要通过**内存模型**（如 Java 的 JMM）来向上层屏蔽底层差异。



#### **谁负责解决“缓存一致性”问题？**

✅ **硬件层面（CPU + 缓存一致性协议）**

- 缓存一致性问题（Cache Coherence）是由 **多核 CPU 的硬件架构** 引起的。
- 解决这个问题的 **主要责任在 CPU 硬件本身**，而不是操作系统。
- 如你之前提到的 **MESI 协议** 等缓存一致性协议，是 CPU 内部通过总线监听或目录式机制实现的，属于 **硬件自动完成的任务**。

👉 操作系统 **依赖** 这些硬件机制，但 **并不负责实现** 缓存一致性。

#### **操作系统做了什么？**

操作系统的主要职责包括：

- 管理内存（虚拟内存、页表、内存分配）
- 提供进程/线程抽象
- 调度 CPU 时间片
- 抽象硬件，提供系统调用接口

但它 **不直接管理缓存状态**。缓存一致性由 CPU 自动维护。

操作系统假设底层硬件已经提供了基本的一致性保障（比如通过 MESI 协议），然后在此基础上构建多任务、多线程环境。

#### 📌 两种“内存模型”：

| 类型             | 所属                     | 说明                                                         |
| ---------------- | ------------------------ | ------------------------------------------------------------ |
| **硬件内存模型** | CPU 架构（如 x86、ARM）  | 描述 CPU 如何执行内存读写顺序，比如是否允许重排序（reordering） |
| **语言内存模型** | 编程语言（如 Java、C++） | 规定多线程程序中内存操作的可见性、原子性和顺序性             |

例如：
- **Java 内存模型（JMM）**：是 Java 语言规范的一部分，定义了 `volatile`、`synchronized`、`final` 等关键字的行为。
- **C++ memory model**：C++11 引入了标准的多线程内存模型。
- **x86-TSO**：x86 架构的硬件内存模型，相对强一致性。
- **ARM/Power**：弱内存模型，允许更多重排序。

👉 操作系统（如 Linux 或 Windows）本身 **没有独立的“内存模型”定义**。它们运行在某种 CPU 架构上，并配合编程语言和编译器来支持并发语义。

#### ✅ 那么，操作系统和内存一致性有什么关系？

虽然操作系统不定义内存模型，但它在以下几个方面 **间接参与**：

##### ✅ 提供同步原语的支持
- 实现 `futex`（Linux）、`Critical Section`（Windows）
- 支持互斥锁、信号量、条件变量等高级同步机制
- 这些机制依赖底层 CPU 的原子指令（如 `CAS`、`LOCK` 前缀）

##### ✅ 处理内存映射与共享内存
- 多个进程共享同一块物理内存时（如 mmap、shm），操作系统需确保这些页面在多个 CPU 缓存中保持一致。
- 但这仍然依赖硬件的 MESI 协议来完成，OS 只是正确设置页表和缓存属性（如写通、回写等）。

##### ✅ 与编译器/运行时协作
- OS 提供系统调用接口，让程序可以使用 `pthread_mutex_lock` 等函数。
- 这些函数内部会插入内存屏障（Memory Barrier），保证顺序性。

#### ✅ 正确总结

| 问题                          | 谁来解决                                |
| ----------------------------- | --------------------------------------- |
| 缓存一致性（Cache Coherence） | ✅ CPU 硬件（MESI 等协议）               |
| 内存重排序、可见性问题        | ✅ 硬件内存模型 + 语言内存模型（如 JMM） |
| 多线程同步机制                | ✅ 操作系统提供 API，语言/库封装使用     |
| “操作系统内存模型”？          | ❌ 不存在这样的概念（原文误解）          |

#### 🛠 举个例子说明协作关系：

```java
// Java 代码
volatile int flag = 0;

// Thread 1
flag = 1;

// Thread 2
if (flag == 1) { ... }
```

这个 `volatile` 的行为是如何保障的？

1. **Java 语言**：根据 **JMM（Java Memory Model）**，`volatile` 写具有“释放语义”，读具有“获取语义”。
2. **编译器**：生成带有内存屏障的字节码或本地代码。
3. **JVM**：在 x86 上插入 `Lock` 指令，在 ARM 上插入 `dmb` 指令。
4. **CPU**：执行这些指令，触发缓存同步（MESI 协议），确保其他核心能看到最新值。
5. **操作系统**：提供线程调度、内存分配，但不直接参与 `volatile` 的语义实现。

### 指令重排序

#### 🔁 指令重排序的三种主要类型

| 类型              | 发生阶段              | 原因                                                         |
| ----------------- | --------------------- | ------------------------------------------------------------ |
| 1. 编译器优化重排 | 编译期                | 编译器（如 javac、JIT）在不改变单线程语义的前提下，调整语句顺序以优化性能。 |
| 2. 指令并行重排   | 运行期（CPU 执行）    | CPU 支持指令级并行（ILP），当多条指令无数据依赖时，可乱序执行，提高吞吐。 |
| 3. 内存系统重排   | 运行期（缓存/写缓冲） | 写操作可能先进入写缓冲区，未及时刷新到主存，造成“看起来像”重排序。 |

> 📌 注意：第三种“内存系统重排”不是真正的指令执行顺序改变，而是由于**缓存一致性延迟 + 写缓冲区**导致的**内存可见性问题**，在 JMM 中表现为本地内存与主内存不一致。

#### 🛠 如何解决重排序问题？

针对不同层次的重排序，有不同的应对机制：

#####  **对抗编译器重排序**

- **方式**：使用 `volatile`、`synchronized`、`final` 等关键字，告诉编译器“这里不能乱序”。
- **原理**：这些关键字会插入**编译屏障（Compiler Barrier）**，禁止编译器对相关语句进行重排序。

#####  **对抗处理器重排序（包括指令并行 + 写缓冲）**

- **方式**：插入 **内存屏障（Memory Barrier / Memory Fence）**
- 作用：
  - 在处理器写入值时，强制将写缓冲区中的数据刷新到主内存
  - 在读取值之前，使处理器本地缓存中的相关数据失效，强制从主内存中加载最新值，从而保障变量的可见性。
  - 阻止特定类型的读/写操作被重排序，从而保证屏障前后的内存操作顺序。

#### 常见内存屏障类型：

| 屏障类型   | 说明                                                    |
| ---------- | ------------------------------------------------------- |
| LoadLoad   | 确保“读-读”顺序，前一个读操作完成后才能执行后续读       |
| StoreStore | 确保“写-写”顺序，前一个写操作刷入内存后，才能执行后续写 |
| LoadStore  | 确保“读-写”顺序                                         |
| StoreLoad  | 最强屏障，确保“写-读”顺序，通常会导致 CPU 停顿          |

> ✅ 在 Java 中，`volatile` 变量的写操作前后会插入 StoreStore 和 StoreLoad 屏障；读操作后会插入 LoadLoad 和 LoadStore 屏障。

#### ✅ Java 内存模型（JMM）的作用

JMM 是一个**抽象的规范**，它：

1. 定义了多线程环境下变量的访问规则；
2. 抽象了主内存与本地内存（线程工作内存）的关系；
3. 规定了 `volatile`、`synchronized`、`final` 等关键字如何禁止重排序；
4. 在底层依赖硬件内存模型（如 x86-TSO）和内存屏障来实现语义。

> ✅ JMM 的目标：让程序员在不同硬件平台上写出正确、可移植的并发程序。

#### happens-before 8条规则

happens-before 的规则就 8 条，说多不多，重点了解下面列举的 5 条即可。全记是不可能的，很快就忘记了，意义不大，随时查阅即可。

1. **程序顺序规则**：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；
2. **解锁规则**：解锁 happens-before 于加锁；
3. **volatile 变量规则**：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。
4. **传递规则**：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；
5. **线程启动规则**：Thread 对象的 `start()`方法 happens-before 于此线程的每一个动作。

如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序。

#### `happens-before` 和 JMM 的关系

> **`happens-before` 是 JMM 实现内存可见性和防止重排序的核心工具，是 JMM 的“规则引擎”。**

你可以把它们的关系类比为：

| 类比           | 解释                                               |
| -------------- | -------------------------------------------------- |
| 🔧 工具 与 框架 | `happens-before` 是 JMM 用来实现并发安全的“工具”   |
| 🧱 砖块 与 大厦 | `happens-before` 是构建 JMM 这座“并发大厦”的“砖块” |
| 📜 法律 与 国家 | JMM 是“国家”，`happens-before` 是“法律条文”        |

### Atomic原子类

[JavaGuide-Atomic原子类使用](https://javaguide.cn/java/concurrent/atomic-classes.html#atomic-%E5%8E%9F%E5%ADAtomic原子类%90%E7%B1%BB%E4%BB%8B%E7%BB%8D)

#### AtomicStampedReference

能解决ABA问题的类

```java
// 创建一个 AtomicStampedReference 对象，初始值为 "SnailClimb"，初始版本号为 1
AtomicStampedReference<String> asr = new AtomicStampedReference<>("SnailClimb", 1);

// 打印初始值和版本号
int[] initialStamp = new int[1];
String initialRef = asr.get(initialStamp);
System.out.println("Initial Reference: " + initialRef + ", Initial Stamp: " + initialStamp[0]);

// 更新值和版本号
int oldStamp = initialStamp[0];
String oldRef = initialRef;
String newRef = "Daisy";
int newStamp = oldStamp + 1;

boolean isUpdated = asr.compareAndSet(oldRef, newRef, oldStamp, newStamp);
System.out.println("Update Success: " + isUpdated);

// 打印更新后的值和版本号
int[] updatedStamp = new int[1];
String updatedRef = asr.get(updatedStamp);
System.out.println("Updated Reference: " + updatedRef + ", Updated Stamp: " + updatedStamp[0]);

// 尝试用错误的版本号更新
boolean isUpdatedWithWrongStamp = asr.compareAndSet(newRef, "John", oldStamp, newStamp + 1);
System.out.println("Update with Wrong Stamp Success: " + isUpdatedWithWrongStamp);

// 打印最终的值和版本号
int[] finalStamp = new int[1];
String finalRef = asr.get(finalStamp);
System.out.println("Final Reference: " + finalRef + ", Final Stamp: " + finalStamp[0]);
```

### IO

#### InputStream(字节输入流)

英文直接用字节流就能读写，中文用字符流。

```java
try (InputStream fis = new FileInputStream("input.txt")) {
    System.out.println("Number of remaining bytes:"
            + fis.available());
    int content;
    long skip = fis.skip(2);
    System.out.println("The actual number of bytes skipped:" + skip);
    System.out.print("The content read from file:");
    while ((content = fis.read()) != -1) {
        System.out.print((char) content);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

```java
// 新建一个 BufferedInputStream 对象
BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("input.txt"));
// 读取文件的内容并复制到 String 对象中
String result = new String(bufferedInputStream.readAllBytes());
System.out.println(result);
```

##### DataInputStream、DataOutputStream

`DataInputStream` 应该与 `DataOutputStream` 配对使用：

**写入数据 (使用 DataOutputStream):**

java深色版本

```java
try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.dat"))) {
    dos.writeBoolean(true);
    dos.writeInt(12345);
    dos.writeUTF("Hello World");
}
```

**读取数据 (使用 DataInputStream):**

java深色版本

```java
try (DataInputStream dis = new DataInputStream(new FileInputStream("data.dat"))) {
    boolean b = dis.readBoolean(); // 正确读出 true
    int i = dis.readInt();         // 正确读出 12345
    String s = dis.readUTF();      // 正确读出 "Hello World"
}
```

##### ObjectInputStream

**文件包含有效的序列化数据**: `object.data` 文件必须是由 `ObjectOutputStream` 写入的、有效的 Java 序列化数据。如果文件损坏或格式错误，会抛出 `IOException` 或 `ClassNotFoundException`

另外，用于序列化和反序列化的类必须实现 `Serializable` 接口，对象中如果有属性不想被序列化，使用 `transient` 修饰。

```java
MyClass object = null;
try (ObjectInputStream input = new ObjectInputStream(new FileInputStream("object.data"))) {
    object = (MyClass) input.readObject();
} catch (IOException | ClassNotFoundException e) {
    e.printStackTrace(); // 或进行更合适的错误处理
}
// 不需要显式调用 input.close()
```

#### OutputStream(字节输入流)

```java
try (FileOutputStream output = new FileOutputStream("output.txt")) {
    byte[] array = "JavaGuide".getBytes();
    output.write(array);
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 缓冲流

```java
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * 演示 FileOutputStream 与 BufferedOutputStream 的使用
 * BufferedOutputStream 通过内部缓冲区减少了直接的磁盘 I/O 操作次数，从而提高写入效率。
 */
public class BufferedOutputExample {

    public static void main(String[] args) {
        // 声明资源，推荐使用 try-with-resources 语句自动管理
        // 这样可以确保流在使用完毕后（无论是否发生异常）都会被正确关闭
        try (FileOutputStream fileOutputStream = new FileOutputStream("output.txt");
             BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream)) {

            // --- 写入字节数据 ---
            System.out.println("正在写入字节数据到 output.txt...");

            // 方法1: 写入单个字节 (int 的低8位)
            String message1 = "Hello, ";
            for (byte b : message1.getBytes()) {
                bos.write(b); // write(int b) 写入b的低8位
            }

            // 方法2: 写入字节数组
            String message2 = "Buffered World!\n";
            byte[] data = message2.getBytes(); // 将字符串转换为字节数组 (默认平台编码)
            bos.write(data);

            // 方法3: 写入字节数组的一部分
            String message3 = "This is additional data.";
            byte[] moreData = message3.getBytes();
            // 只写入 "This is " (前8个字节)
            bos.write(moreData, 0, 8);

            // 注意: 此时数据可能还在缓冲区中，尚未真正写入磁盘
            // bos.flush(); // 可以手动刷新缓冲区，强制将数据写入底层流 (非必需，close()会自动flush)

            System.out.println("数据写入完成！");

            // try-with-resources 会自动调用 bos.close() 和 fileOutputStream.close()
            // close() 方法内部会先调用 flush() 确保所有缓冲数据被写出，然后关闭流

        } catch (IOException e) {
            // 处理可能发生的I/O异常，如文件无法创建、磁盘满等
            System.err.println("发生I/O错误: " + e.getMessage());
            e.printStackTrace();
        }

        // 验证：尝试读取刚写入的文件内容
        try (java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.FileReader("output.txt"))) {
            System.out.println("\n--- 读取 output.txt 文件内容 ---");
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("读取文件时发生错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

#### 适配器和装饰器 设计模式

##### 适配器模式 (Adapter Pattern) 例子：音乐播放器

**场景**：我们有一个旧的音乐播放器系统，只能播放 `MP3` 文件。现在需要支持播放 `VLC` 格式的文件。`VLCPlayer` 是一个已经存在的类，但它的接口 (`playVlc`) 与我们的播放器期望的接口 (`play`) 不兼容。

**目标**：创建一个适配器，让 `VLCPlayer` 能够被当作一个普通的 `MediaPlayer` 来使用。

```java
// 目标接口 (Target): 客户端期望使用的接口
interface MediaPlayer {
    void play(String audioType, String fileName);
}

// 被适配者 (Adaptee): 已经存在的类，但接口不兼容
class VLCPlayer {
    public void playVlc(String fileName) {
        System.out.println("Playing vlc file. Name: " + fileName);
    }

    public void playMp4(String fileName) {
        // VLCPlayer 可能也支持 MP4，但这不是重点
        System.out.println("Playing mp4 file with VLC. Name: " + fileName);
    }
}

// 适配器 (Adapter): 实现目标接口，持有被适配者
class MediaAdapter implements MediaPlayer {
    private VLCPlayer vlcPlayer;

    // 构造函数中注入被适配者
    public MediaAdapter() {
        this.vlcPlayer = new VLCPlayer();
    }

    // 实现目标接口的方法
    @Override
    public void play(String audioType, String fileName) {
        // 在适配器内部，根据请求的类型，调用被适配者的特定方法
        if ("vlc".equalsIgnoreCase(audioType)) {
            vlcPlayer.playVlc(fileName); // 调用被适配者的方法
        } else if ("mp4".equalsIgnoreCase(audioType)) {
            vlcPlayer.playMp4(fileName); // VLCPlayer 也支持MP4
        }
        // 其他格式不支持...
    }
}

// 高级播放器 (AdvancedMediaPlayer): 另一个被适配者 (可选，用于展示多适配)
class AdvancedAudioPlayer {
    public void playAac(String fileName) {
        System.out.println("Playing aac file. Name: " + fileName);
    }

    public void playWav(String fileName) {
        System.out.println("Playing wav file. Name: " + fileName);
    }
}

// 另一个适配器
class AdvancedMediaAdapter implements MediaPlayer {
    private AdvancedAudioPlayer advancedPlayer;

    public AdvancedMediaAdapter() {
        this.advancedPlayer = new AdvancedAudioPlayer();
    }

    @Override
    public void play(String audioType, String fileName) {
        if ("aac".equalsIgnoreCase(audioType)) {
            advancedPlayer.playAac(fileName);
        } else if ("wav".equalsIgnoreCase(audioType)) {
            advancedPlayer.playWav(fileName);
        }
    }
}

// 客户端代码 (Client)
class AudioPlayer implements MediaPlayer {
    private MediaAdapter mediaAdapter;
    private AdvancedMediaAdapter advancedMediaAdapter;

    @Override
    public void play(String audioType, String fileName) {
        // 内置支持MP3
        if ("mp3".equalsIgnoreCase(audioType)) {
            System.out.println("Playing mp3 file. Name: " + fileName);
        }
        // 对于VLC和MP4，使用适配器
        else if ("vlc".equalsIgnoreCase(audioType) || "mp4".equalsIgnoreCase(audioType)) {
            if (mediaAdapter == null) {
                mediaAdapter = new MediaAdapter(); // 延迟初始化
            }
            mediaAdapter.play(audioType, fileName);
        }
        // 对于AAC和WAV，使用另一个适配器
        else if ("aac".equalsIgnoreCase(audioType) || "wav".equalsIgnoreCase(audioType)) {
            if (advancedMediaAdapter == null) {
                advancedMediaAdapter = new AdvancedMediaAdapter();
            }
            advancedMediaAdapter.play(audioType, fileName);
        }
        else {
            System.out.println("Unsupported audio type: " + audioType + " for file: " + fileName);
        }
    }
}

// 测试
public class AdapterPatternDemo {
    public static void main(String[] args) {
        AudioPlayer player = new AudioPlayer();

        player.play("mp3", "beyond_the_horizon.mp3");
        player.play("vlc", "alone.vlc");
        player.play("mp4", "far_far_away.mp4");
        player.play("aac", "mind_me.aac");
        player.play("wav", "hello.wav");
        player.play("avi", "random.avi"); // 不支持
    }
}
```

**输出**:
```
Playing mp3 file. Name: beyond_the_horizon.mp3
Playing vlc file. Name: alone.vlc
Playing mp4 file with VLC. Name: far_far_away.mp4
Playing aac file. Name: mind_me.aac
Playing wav file. Name: hello.wav
Unsupported audio type: avi for file: random.avi
```

**关键点**: `MediaAdapter` 将 `VLCPlayer` (Adaptee) 的接口适配成了 `MediaPlayer` (Target) 的接口，使得 `AudioPlayer` 可以统一处理不同格式。

##### 装饰器模式 (Decorator Pattern) 例子：咖啡店订单

**场景**：咖啡店卖不同种类的咖啡（如浓缩咖啡、摩卡），并且可以给咖啡添加各种调料（如牛奶、糖、巧克力）。调料的价格和描述需要动态地加到基础咖啡上。使用继承会产生大量子类（EspressoWithMilk, EspressoWithSugar, EspressoWithMilkAndSugar...），装饰器模式可以更灵活地组合。

**目标**：动态地、透明地为咖啡对象添加功能（调料），并且可以叠加多个装饰。

```java
// 组件 (Component): 定义对象接口
abstract class Beverage {
    protected String description = "Unknown Beverage";

    public String getDescription() {
        return description;
    }

    public abstract double cost();
}

// 具体组件 (Concrete Component): 基础实现
class Espresso extends Beverage {
    public Espresso() {
        description = "Espresso";
    }

    @Override
    public double cost() {
        return 1.99;
    }
}

class HouseBlend extends Beverage {
    public HouseBlend() {
        description = "House Blend Coffee";
    }

    @Override
    public double cost() {
        return 0.89;
    }
}

// 装饰器 (Decorator): 维持一个对组件的引用，并定义与组件一致的接口
abstract class CondimentDecorator extends Beverage {
    // 所有调料装饰器都必须重新实现 getDescription
    // 因为描述会变化
    public abstract String getDescription();
}

// 具体装饰器 (Concrete Decorator): 添加具体功能
class Milk extends CondimentDecorator {
    Beverage beverage; // 持有被装饰的组件

    public Milk(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Milk";
    }

    @Override
    public double cost() {
        return .10 + beverage.cost(); // 价格 = 牛奶价格 + 被装饰饮料的价格
    }
}

class Sugar extends CondimentDecorator {
    Beverage beverage;

    public Sugar(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Sugar";
    }

    @Override
    public double cost() {
        return .05 + beverage.cost();
    }
}

class Chocolate extends CondimentDecorator {
    Beverage beverage;

    public Chocolate(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Chocolate";
    }

    @Override
    public double cost() {
        return .20 + beverage.cost();
    }
}

// 测试
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        // 点一杯加牛奶的浓缩咖啡
        Beverage beverage1 = new Espresso();
        beverage1 = new Milk(beverage1); // 用Milk装饰
        System.out.println(beverage1.getDescription() + " $" + String.format("%.2f", beverage1.cost()));

        // 点一杯加糖和巧克力的综合咖啡
        Beverage beverage2 = new HouseBlend();
        beverage2 = new Sugar(beverage2);     // 用Sugar装饰
        beverage2 = new Chocolate(beverage2); // 再用Chocolate装饰 (可以叠加)
        beverage2 = new Milk(beverage2);      // 再加牛奶！
        System.out.println(beverage2.getDescription() + " $" + String.format("%.2f", beverage2.cost()));
    }
}
```

**输出**:
```
Espresso, Milk $2.09
House Blend Coffee, Sugar, Chocolate, Milk $1.24
```

**关键点**:
*   `Milk`, `Sugar`, `Chocolate` 是**装饰器**，它们包装了 `Beverage`（可以是基础咖啡，也可以是已经被装饰过的咖啡）。
*   它们通过调用被装饰对象 (`beverage`) 的 `cost()` 和 `getDescription()` 方法，并在此基础上添加自己的成本和描述，实现了功能的**叠加**。
*   可以非常灵活地组合，比如 `new Milk(new Sugar(new Espresso()))`，而不需要为每一种组合创建一个新类。

| 特性     | 适配器模式 (Adapter)                                     | 装饰器模式 (Decorator)                                       |
| :------- | :------------------------------------------------------- | :----------------------------------------------------------- |
| **目的** | **转换接口**，让不兼容的类可以一起工作。                 | **动态添加职责**，在不修改原有代码的情况下扩展对象功能。     |
| **关系** | **适配**：改变接口以符合客户端期望。                     | **增强**：保持接口不变，增加新行为。                         |
| **结构** | 通常实现目标接口，包含被适配者。                         | 通常继承/实现组件接口，包含组件。                            |
| **例子** | `InputStreamReader` (字节流 -> 字符流), 电源插头转换器。 | Java I/O 流 (`BufferedInputStream` 包装 `FileInputStream`)，GUI 窗口边框/滚动条。 |
| **核心** | **接口转换** (Interface Conversion)                      | **功能叠加** (Functionality Stacking)                        |

#### 打印流

是的，**绝对可以！** `PrintStream`（以及 `PrintWriter`）的“打印”目的地并不仅限于控制台（`System.out`）。`System.out` 只是 `PrintStream` 的一个**预定义实例**，其默认输出目标是控制台。

`PrintStream` 和 `PrintWriter` 的强大之处在于它们可以被**重定向**到各种不同的输出目标。你可以创建它们的实例，并将输出目标指定为你需要的任何地方。

##### 打印到文件 (File)

这是最常见的重定向方式。

```java
import java.io.*;

public class PrintToFile {
    public static void main(String[] args) {
        String filename = "output.log";

        try (
            // 1. 创建一个 PrintStream，目标是文件
            PrintStream filePrintStream = new PrintStream(new FileOutputStream(filename));
            // 或者使用 PrintWriter (字符流，通常更推荐用于文本)
            PrintWriter filePrintWriter = new PrintWriter(new FileWriter(filename, true)); // true 表示追加
        ) {
            // 使用 PrintStream 打印到文件
            filePrintStream.println("这条消息会写入到 " + filename + " 文件中 (使用 PrintStream)。");
            filePrintStream.println("时间: " + new java.util.Date());

            // 使用 PrintWriter 打印到文件
            filePrintWriter.println("这条消息也会写入到 " + filename + " 文件中 (使用 PrintWriter)。");
            filePrintWriter.printf("格式化输出: 用户 %s 登录，IP: %s%n", "Alice", "192.168.1.100");

            // 注意: PrintWriter 需要手动 flush 或 close 才能确保数据写入磁盘
            filePrintWriter.flush(); // 刷新缓冲区
            // try-with-resources 会自动 close

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

---

##### 打印到网络套接字 (Socket)

在客户端-服务器编程中，服务器可以使用 `PrintStream`/`PrintWriter` 将响应发送给连接的客户端。

```java
// 服务器端代码片段 (Server Side)
import java.io.*;
import java.net.*;

public class ServerExample {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(8080);
        System.out.println("服务器启动，等待连接...");

        Socket clientSocket = serverSocket.accept(); // 接受客户端连接
        System.out.println("客户端已连接: " + clientSocket.getInetAddress());

        try (
            // 获取客户端 Socket 的输出流
            OutputStream outToClient = clientSocket.getOutputStream();
            // 包装成 PrintStream，方便发送文本
            PrintStream printStream = new PrintStream(outToClient, true); // true 表示自动刷新
        ) {
            // 向客户端发送消息
            printStream.println("HTTP/1.1 200 OK");
            printStream.println("Content-Type: text/plain");
            printStream.println(); // 空行表示头部结束
            printStream.println("Hello from Server!");
            printStream.println("当前时间: " + new java.util.Date());
        } finally {
            clientSocket.close();
            serverSocket.close();
        }
    }
}
```

##### 打印到内存 (ByteArrayOutputStream)

有时你希望将格式化的输出先收集在内存中，而不是立即输出到文件或网络。`ByteArrayOutputStream` 是一个很好的中间目标。

```java
import java.io.*;

public class PrintToMemory {
    public static void main(String[] args) {
        try (
            // 1. 创建一个内存字节流
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            // 2. 将 PrintStream 的目标指向这个内存流
            PrintStream ps = new PrintStream(baos);
        ) {
            // 向 "内存" 打印
            ps.println("这行文本被打印到了内存中。");
            ps.println("变量值: " + 42);
            ps.printf("格式化: %.2f%n", 3.14159);

            // 现在，可以从内存流中获取结果
            String outputInMemory = baos.toString("UTF-8"); // 将内存中的字节转换为字符串
            System.out.println("从内存中读取的内容:");
            System.out.println(outputInMemory);

            // 你也可以将这个内存内容写入文件、发送网络等
            // Files.write(Paths.get("from_memory.txt"), outputInMemory.getBytes());

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

##### 重定向 System.out 本身

你甚至可以改变 `System.out` 这个全局对象的输出目标！这在日志重定向或测试中很有用。

```java
import java.io.*;

public class RedirectSystemOut {
    public static void main(String[] args) {
        String logFile = "app.log";

        try (
            // 创建一个指向文件的 PrintStream
            PrintStream fileStream = new PrintStream(new FileOutputStream(logFile));
        ) {
            // 关键步骤: 使用 System.setOut() 重定向标准输出
            System.setOut(fileStream);

            // 从现在开始，所有对 System.out 的调用都会写入 app.log 文件！
            System.out.println("程序开始执行...");
            System.out.println("重要日志: 初始化完成。");
            System.out.println("时间戳: " + new java.util.Date());

            // 注意: 此时控制台将看不到这些输出，它们都在文件里

        } catch (IOException e) {
            e.printStackTrace();
        }

        // 注意: fileStream 关闭后，System.out 会被设为 null，后续调用会抛出 NullPointerException
        // 在实际应用中，通常会一直保持一个日志流打开，或者在 finally 块中恢复 System.out
    }
}
```

##### 打印到其他 OutputStream

理论上，任何 `OutputStream` 的子类都可以作为 `PrintStream` 的目标。例如：

*   **`PipedOutputStream`**: 用于线程间通信。
*   **`FilterOutputStream`** 的子类：进行加密、压缩等处理后再输出。
*   **自定义 `OutputStream`**: 你可以创建自己的 `OutputStream` 实现，让 `PrintStream` 的输出经过特殊处理。

```java
// 伪代码示例
MyCustomOutputStream customOut = new MyCustomOutputStream(); // 假设你有自定义实现
PrintStream ps = new PrintStream(customOut);
ps.println("这条消息会经过我的自定义处理逻辑！");
```

##### PrintStream vs PrintWriter

*   **`PrintStream`**: 是 `FilterOutputStream` 的子类，属于**字节流**。它内部处理了字符到字节的转换（使用平台默认编码或指定编码），所以你可以直接打印 `String` 和基本类型。`System.out` 就是 `PrintStream`。
*   **`PrintWriter`**: 是 `Writer` 的子类，属于**字符流**。它更纯粹地处理字符。通常在需要明确字符编码控制时，`PrintWriter` 是更好的选择（如 `new PrintWriter(new OutputStreamWriter(new FileOutputStream(file), "UTF-8"))`）。

##### 总结

`PrintStream` 和 `PrintWriter` 就像一个“万能打印头”，`System.out` 只是这个打印头默认安装在“控制台”这个位置。通过创建新的 `PrintStream`/`PrintWriter` 实例并将其连接到不同的 `OutputStream`/`Writer`，你可以轻松地将格式化输出重定向到：

*   **文件** (最常见)
*   **网络连接** (Socket)
*   **内存** (ByteArrayOutputStream)
*   **管道** (PipedOutputStream)
*   **甚至改变 `System.out` 和 `System.err` 的全局目标**

这种灵活性使得它们在日志记录、报告生成、网络通信等场景中非常有用。

#### RandomAccessFile

`RandomAccessFile` 比较常见的一个应用就是实现大文件的 **断点续传** 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。

### IO模型



[黑马IO笔记-BIO、NIO、AIO](https://blog.csdn.net/unique_perfect/article/details/115108640)

Java 的 I/O（输入/输出）模型是其核心功能之一，用于处理数据的读取和写入。随着技术发展，Java 的 I/O 模型经历了从传统的阻塞 I/O 到更高效的非阻塞模型的演进。主要可以分为以下几种：

#### BIO (Blocking I/O) - 同步阻塞 I/O

这是最传统、最基础的 I/O 模型，存在于 `java.io` 包中。

*   **工作原理**:
    *   **同步**: 线程发起一个 I/O 操作后，必须等待该操作完成才能继续执行后续代码。
    *   **阻塞**: 在 I/O 操作（如 `read()` 或 `write()`）执行期间，调用线程会被**阻塞**，无法执行其他任务，直到数据准备好或操作完成。
*   **特点**:
    *   **编程简单**: API 直观易懂，使用 `InputStream`/`OutputStream` 和 `Reader`/`Writer` 等类。
    *   **资源消耗大**: 每个连接通常需要一个独立的线程来处理。当并发连接数很高时（如成千上万），会创建大量线程，导致巨大的线程上下文切换开销和内存消耗。
    *   **吞吐量低**: 大量线程因等待 I/O 而阻塞，CPU 利用率不高。
*   **适用场景**: 连接数少、并发量低的应用，如简单的客户端工具、小型服务器。
*   **示例**:
    ```java
    // 服务器端接收连接和读取数据（简化）
    ServerSocket serverSocket = new ServerSocket(8080);
    while (true) {
        Socket socket = serverSocket.accept(); // 阻塞等待连接
        // 为每个连接创建一个新线程处理
        new Thread(() -> {
            try (InputStream in = socket.getInputStream()) {
                byte[] buffer = new byte[1024];
                int len;
                while ((len = in.read(buffer)) != -1) { // 阻塞读取数据
                    // 处理数据...
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }).start();
    }
    ```

#### NIO (New I/O 或 Non-blocking I/O) - 同步非阻塞 I/O

⚠️需要注意：使用 NIO 并不一定意味着高性能，它的性能优势主要体现在高并发和高延迟的网络环境下。当连接数较少、并发程度较低或者网络传输速度较快时，NIO 的性能并不一定优于传统的 BIO 。

从 Java 1.4 开始引入 (`java.nio` 包)，旨在解决传统 BIO 的高并发瓶颈。

*   **核心组件**:
    *   **`Buffer` (缓冲区)**: 所有数据都通过 `Buffer` 对象进行读写。它是内存中的一块区域，用于存储数据。常见的有 `ByteBuffer`, `CharBuffer` 等。
    *   **`Channel` (通道)**: 类似于流 (`Stream`)，但更强大。`Channel` 是双向的（可读可写），而 `Stream` 通常是单向的。`Channel` 可以异步地读写 `Buffer`。常见的有 `FileChannel`, `SocketChannel`, `ServerSocketChannel`, `DatagramChannel`。
    *   **`Selector` (选择器)**: NIO 的核心，用于**多路复用**。一个 `Selector` 可以监听多个 `Channel` 的 I/O 事件（如连接就绪 `OP_ACCEPT`、读就绪 `OP_READ`、写就绪 `OP_WRITE`）。线程通过调用 `Selector` 的 `select()` 方法，可以**阻塞**地等待**任意一个**注册的 `Channel` 上发生感兴趣的 I/O 事件。
*   **工作原理**:
    *   **同步**: 线程需要主动发起 I/O 操作（如 `read()`/`write()`）并等待结果。
    *   **非阻塞**: `Channel` 可以配置为非阻塞模式。当调用 `read()` 或 `write()` 时，如果数据未准备好，方法会立即返回（返回值指示操作状态，如读取了多少字节），线程不会被阻塞，可以去处理其他任务。
    *   **多路复用**: `Selector` 允许单个线程管理多个 `Channel`。线程调用 `select()` 阻塞，直到至少有一个 `Channel` 准备好进行 I/O 操作。然后线程可以遍历 `Selector` 返回的就绪 `Channel` 集合，对它们进行非阻塞的读写操作。
*   **特点**:
    *   **高并发**: 一个线程可以管理成千上万个连接，极大地减少了线程数量，降低了资源开销。
    *   **编程复杂**: API 相对复杂，需要理解 `Buffer` 的 `position`, `limit`, `capacity` 等概念，以及 `Selector` 的事件循环机制。
    *   **性能好**: 在高并发场景下，性能远超 BIO。
*   **适用场景**: 高并发、高吞吐量的网络服务器（如 Web 服务器、游戏服务器、消息中间件）。
*   **示例 (简化)**:
    ```java
    // 服务器端使用 NIO (简化骨架)
    Selector selector = Selector.open();
    ServerSocketChannel serverChannel = ServerSocketChannel.open();
    serverChannel.bind(new InetSocketAddress(8080));
    serverChannel.configureBlocking(false); // 设置为非阻塞
    serverChannel.register(selector, SelectionKey.OP_ACCEPT); // 注册到 Selector
    
    while (true) {
        int readyChannels = selector.select(); // 阻塞，直到有事件发生
        if (readyChannels == 0) continue;
    
        Set<SelectionKey> selectedKeys = selector.selectedKeys();
        Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
    
        while (keyIterator.hasNext()) {
            SelectionKey key = keyIterator.next();
            keyIterator.remove();
    
            if (key.isAcceptable()) {
                // 处理新连接
                SocketChannel clientChannel = serverChannel.accept();
                clientChannel.configureBlocking(false);
                clientChannel.register(selector, SelectionKey.OP_READ);
            } else if (key.isReadable()) {
                // 处理读就绪
                SocketChannel clientChannel = (SocketChannel) key.channel();
                ByteBuffer buffer = ByteBuffer.allocate(1024);
                int bytesRead = clientChannel.read(buffer); // 非阻塞读
                if (bytesRead > 0) {
                    // 处理数据...
                    buffer.flip(); // 切换到读模式
                    // ... 读取 buffer 中的数据
                    buffer.clear(); // 清理，准备下次写入
                }
            }
            // ... 处理其他事件 (如 OP_WRITE)
        }
    }
    ```

#### AIO (Asynchronous I/O) - 异步非阻塞 I/O

从 Java 7 开始引入 (`java.nio.channels` 包中的 `AsynchronousChannel` 相关类)，是真正的异步 I/O。

*   **工作原理**:
    *   **异步**: 当进行 I/O 操作（如 `read()` 或 `write()`）时，线程发起调用后**立即返回**，不等待操作完成。I/O 操作由操作系统底层在后台完成。
    *   **非阻塞**: 发起操作的线程完全不阻塞，可以继续执行其他任务。
    *   **回调通知**: 当 I/O 操作完成后，系统会通过以下两种方式之一通知应用：
        1.  **Future**: 操作返回一个 `Future` 对象，你可以通过轮询 `Future` 的 `isDone()` 或调用 `get()` (会阻塞直到完成) 来获取结果。
        2.  **CompletionHandler**: 提供一个回调接口 (`CompletionHandler<V, A>`)，当操作成功或失败时，系统会自动调用其 `completed(V result, A attachment)` 或 `failed(Throwable exc, A attachment)` 方法。
*   **核心组件**:
    *   `AsynchronousFileChannel`: 用于异步文件 I/O。
    *   `AsynchronousSocketChannel`: 用于异步网络客户端 I/O。
    *   `AsynchronousServerSocketChannel`: 用于异步网络服务器端 I/O。
*   **特点**:
    *   **真正的异步**: 线程发起 I/O 后无需等待，效率最高。
    *   **资源利用率高**: 线程可以处理更多任务，CPU 利用率高。
    *   **编程模型不同**: 基于回调或 `Future`，代码逻辑可能变得分散（回调地狱），调试相对复杂。
    *   **依赖操作系统**: AIO 的性能和实现深度依赖于底层操作系统的支持（如 Linux 的 `epoll` + `io_uring` 或 `aio_*` 系列函数，Windows 的 IOCP）。
*   **适用场景**: 对延迟和吞吐量要求极高的场景，尤其是在 I/O 操作耗时较长（如大文件读写、网络延迟高）时优势明显。但目前在 Java 生态中，NIO (特别是基于 `Selector` 的 Reactor 模式) 仍是主流，AIO 应用相对较少。
*   **示例 (使用 CompletionHandler)**:
    ```java
    AsynchronousSocketChannel client = AsynchronousSocketChannel.open();
    client.connect(new InetSocketAddress("localhost", 8080), null,
        new CompletionHandler<Void, Object>() {
            @Override
            public void completed(Void result, Object attachment) {
                System.out.println("连接成功！");
                // 可以开始异步读写...
                ByteBuffer buffer = ByteBuffer.allocate(1024);
                client.read(buffer, null, new CompletionHandler<Integer, ByteBuffer>() {
                    @Override
                    public void completed(Integer result, ByteBuffer attachment) {
                        if (result > 0) {
                            attachment.flip();
                            // 处理读取到的数据...
                            System.out.println("读取到 " + result + " 字节");
                            attachment.clear();
                            // 可以继续发起下一次 read
                        }
                    }
    
                    @Override
                    public void failed(Throwable exc, ByteBuffer attachment) {
                        System.err.println("读取失败: " + exc.getMessage());
                    }
                });
            }
    
            @Override
            public void failed(Throwable exc, Object attachment) {
                System.err.println("连接失败: " + exc.getMessage());
            }
        });
    
    // 主线程可以继续做其他事，无需等待连接或读取完成
    System.out.println("连接请求已发出，主线程继续执行...");
    // 通常需要一些机制（如 CountDownLatch）来防止主线程过早退出
    ```

#### 总结对比

| 特性              | BIO (Blocking I/O)                       | NIO (Non-blocking I/O)                 | AIO (Asynchronous I/O)                              |
| :---------------- | :--------------------------------------- | :------------------------------------- | :-------------------------------------------------- |
| **模型**          | 同步阻塞                                 | 同步非阻塞 (多路复用)                  | **异步非阻塞**                                      |
| **核心**          | `Stream`                                 | `Buffer`, `Channel`, `Selector`        | `AsynchronousChannel`, `Future`/`CompletionHandler` |
| **线程模型**      | 一个连接一个线程 (Thread-Per-Connection) | 一个线程处理多个连接 (Reactor 模式)    | 回调线程池处理完成事件                              |
| **并发能力**      | 低                                       | 高                                     | **极高** (理论上)                                   |
| **资源消耗**      | 高 (线程多)                              | 低                                     | 低                                                  |
| **编程复杂度**    | 简单                                     | 复杂                                   | 复杂 (回调)                                         |
| **性能 (高并发)** | 差                                       | 好                                     | **最好** (尤其在 I/O 耗时长时)                      |
| **典型应用**      | 小型应用                                 | Netty, Tomcat (NIO 模式), 高并发服务器 | 少数对延迟要求极高的场景                            |

**简单来说**：
*   **BIO**: 简单但效率低，适合小项目。
*   **NIO**: 通过 `Selector` 实现单线程管理多连接，是目前高性能网络编程的**主流选择**。
*   **AIO**: 理论上效率最高，但编程模型复杂且依赖 OS，**应用相对较少**。NIO 结合良好的线程池设计通常已能满足大部分高性能需求。

### 强软弱虚

| 引用类型             | 语法                                 | 被回收时机                                  | 用途                   | 典型应用                      |
| :------------------- | :----------------------------------- | :------------------------------------------ | :--------------------- | :---------------------------- |
| **强引用 (Strong)**  | `Object obj = new Object();`         | 永远不会被回收 (除非强引用断开且无其他引用) | 普通对象引用           | 绝大多数对象                  |
| **软引用 (Soft)**    | `new SoftReference<>(obj)`           | **内存不足时**                              | 内存敏感的缓存         | 图片缓存、大对象缓存          |
| **弱引用 (Weak)**    | `new WeakReference<>(obj)`           | **下一次 GC 时**                            | 规范映射、避免内存泄漏 | `WeakHashMap`                 |
| **虚引用 (Phantom)** | `new PhantomReference<>(obj, queue)` | **任何时候 (只要被回收)**                   | 跟踪对象回收、资源清理 | 监控、`DirectByteBuffer` 清理 |

### 类加载器和双亲委派机制



#### 什么是类加载器 (ClassLoader)?

*   **定义**: 类加载器是 Java 运行时环境的一部分，负责将 `.class` 文件（字节码）从文件系统、网络或其他来源**加载到 JVM 内存中**，并生成一个 `java.lang.Class` 对象。
*   **作用**:
    *   **加载 (Loading)**: 读取 `.class` 文件的二进制数据。
    *   **链接 (Linking)**:
        *   **验证 (Verification)**: 确保字节码的正确性和安全性。
        *   **准备 (Preparation)**: 为类的静态变量分配内存，并设置默认初始值（如 `0`, `false`, `null`）。
        *   **解析 (Resolution)**: 将类、接口、字段和方法的符号引用转换为直接引用（可选，在使用时解析）。
    *   **初始化 (Initialization)**: 执行类的静态初始化块 (`static {}`) 和静态变量的赋值操作。这是类加载的最后一步，也是执行 Java 代码的第一步。

#### JVM 内置的三大类加载器

JVM 在启动时会创建三个主要的类加载器，它们构成了一个**层次结构**：

| 类加载器                                                     | 加载路径                                                     | 说明                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Bootstrap ClassLoader (启动类加载器)**                     | `<JAVA_HOME>/lib` 目录下的核心类库，如 `rt.jar`, `tools.jar` 等。 | - **最顶层**的加载器，由 C/C++ 实现，是 JVM 的一部分。<br>- **不是 Java 对象**，因此在 Java 代码中无法直接引用它（`String.class.getClassLoader()` 返回 `null`）。<br>- 负责加载最基础、最核心的 Java API。 |
| **Extension ClassLoader (扩展类加载器)**                     | `<JAVA_HOME>/lib/ext` 目录下的 jar 包，或由 `java.ext.dirs` 系统变量指定的路径中的 jar 包。 | - 由 Java 实现，父类是 `ClassLoader`。<br>- 负责加载 Java 的**扩展**功能库。 |
| **Application ClassLoader (应用程序类加载器 / 系统类加载器)** | `classpath` 指定的路径下的所有 jar 包和目录。                | - 由 Java 实现，是 `ClassLoader` 的子类。<br>- **默认的类加载器**，用于加载用户自己编写的类和第三方依赖库。<br>- `Thread.currentThread().getContextClassLoader()` 通常返回这个加载器。 |

> **记忆技巧 1 (路径)**:
> - **Bootstrap**: `lib` -> **最核心** (Boot: 启动)
> - **Extension**: `lib/ext` -> **扩展** (Ext: Extension)
> - **Application**: `classpath` -> **应用/用户代码**

> **记忆技巧 2 (层级)**: 想象一个倒三角或金字塔：
> ```
>        Bootstrap (顶层, C++实现, 加载 rt.jar)
>            |
>            |
>      Extension (Java实现, 加载 lib/ext)
>            |
>            |
>  Application (Java实现, 加载 classpath)
> ```
> **箭头方向代表“委托”方向**。

#### 双亲委派机制 (Parent Delegation Model)

*   **核心思想**: 当一个类加载器收到加载类的请求时，它**不会立即自己去加载**，而是先将这个请求**委托给它的父类加载器**去尝试加载。只有当父类加载器无法完成加载（通常是因为在它的搜索路径下找不到该类）时，子加载器才会尝试自己去加载。
*   **工作流程**:
    1.  一个类加载器 (`ClassLoader`) 收到加载 `com.example.MyClass` 的请求。
    2.  它首先检查自己是否已经加载过这个类（避免重复加载）。如果已加载，直接返回 `Class` 对象。
    3.  如果没有加载过，它会调用 `parent.loadClass(name)` 将请求**委派**给其父类加载器。
    4.  这个过程会**递归向上**，直到 `Bootstrap ClassLoader`。
    5.  `Bootstrap ClassLoader` 在 `rt.jar` 等路径下查找 `com.example.MyClass`。
        *   如果找到，加载并返回 `Class` 对象。
        *   如果找不到，返回 `ClassNotFoundException` 给 `Extension ClassLoader`。
    6.  `Extension ClassLoader` 接着在 `lib/ext` 路径下查找。
        *   如果找到，加载并返回。
        *   如果找不到，返回 `ClassNotFoundException` 给 `Application ClassLoader`。
    7.  `Application ClassLoader` 最后在 `classpath` 下查找。
        *   如果找到，加载并返回。
        *   如果找不到，抛出 `ClassNotFoundException`。

*   **优点**:
    *   **避免类的重复加载**: 父加载器加载过的类，子加载器不会再加载，保证了类的唯一性。
    *   **保证核心类库的安全性**: 防止恶意代码用自己的 `java.lang.Object` 等核心类来替换 JDK 提供的类。因为核心类总是由 `Bootstrap ClassLoader` 加载，自定义的类加载器无法加载同名的核心类（会被委派给父加载器，而父加载器已经加载了正确的类）。

*   **破坏双亲委派**:
    *   **场景**: 双亲委派模型在某些场景下不够灵活，需要被“破坏”。
    *   **经典例子**:
        1.  **JDBC**: `DriverManager` 在 `rt.jar` 中，由 `Bootstrap ClassLoader` 加载。但具体的数据库驱动（如 `com.mysql.cj.jdbc.Driver`）在用户的 `classpath` 中，由 `Application ClassLoader` 加载。`Bootstrap` 加载器无法加载用户类。**解决方案**: 使用 **线程上下文类加载器 (Thread Context ClassLoader)**。`DriverManager` 使用 `Thread.currentThread().getContextClassLoader()` (通常是 `Application ClassLoader`) 来加载驱动实现。
        2.  **OSGi**: 模块化框架，需要实现模块间的类隔离，打破了传统的父子层级结构。
        3.  **Tomcat**: 为了实现 Web 应用的隔离和热部署，自定义了类加载器层次（`WebAppClassLoader` -> `Common ClassLoader` -> `Shared ClassLoader`），并且 `WebAppClassLoader` 会**优先**尝试自己加载 Web 应用的类，而不是先委派给父加载器（即**逆向委派**），这是对双亲委派的典型破坏。

> **记忆技巧 3 (双亲委派流程)**: 记住口诀：
> **"先问爹，爹问爷，爷不行，爹不行，自己上！"**
> - 收到请求 -> 问父加载器 (`parent`)
> - 父加载器 -> 问其父 (`parent.parent`)
> - 一直问到顶层 (`Bootstrap`)
> - 顶层找不到 -> 返回给下一级
> - 一级级往下传，直到最底层 (`Application`)
> - 最底层也找不到 -> 抛出异常

> **记忆技巧 4 (破坏场景)**:
> - **JDBC**: 想到 `DriverManager` (核心API) 和 `mysql-connector` (用户jar) -> **上下文类加载器**。
> - **Tomcat**: 想到多个 Web 应用 -> **隔离** -> **WebAppClassLoader 优先自己加载**。

#### 如何记忆？—— 结构化与场景化

1.  **构建知识框架**:
    *   先记住**三大类加载器**的名字、加载路径和层级关系（Bootstrap -> Extension -> Application）。
    *   理解**双亲委派**的核心流程：**委托 -> 查找 -> 失败 -> 自己加载**。
    *   牢记双亲委派的**两大优点**：防重复、保安全。
    *   掌握**破坏双亲委派**的**经典场景和原因**：JDBC (跨代加载)、Tomcat (应用隔离)。

2.  **画图记忆**:
    *   动手画出类加载器的**层级图**。
    *   在图上标出双亲委派的**委托箭头**（从下往上）。
    *   用不同颜色或虚线标出**破坏双亲委派**的场景（如 Tomcat 的逆向箭头）。

3.  **联想记忆**:
    *   把 `Bootstrap` 想成“祖宗”，`Extension` 想成“父亲”，`Application` 想成“儿子”。“儿子”有事先问“父亲”，“父亲”再问“祖宗”。
    *   `rt.jar` 是“祖传宝典”，只能由“祖宗”加载。

4.  **代码验证**:
    *   写代码打印 `String.class.getClassLoader()` (结果是 `null`)。
    *   打印 `自定义类.class.getClassLoader()` (结果是 `sun.misc.Launcher$AppClassLoader`)。
    *   打印 `自定义类.class.getClassLoader().getParent()` (结果是 `sun.misc.Launcher$ExtClassLoader`)。

5.  **面试准备**:
    *   准备回答：“什么是双亲委派？”、“为什么需要双亲委派？”、“如何破坏双亲委派？”、“Tomcat 为什么要破坏双亲委派？”。

好的，我们来系统性地总结和对比 JVM 监控与故障分析工具。这些工具是 Java 开发者和运维工程师诊断性能问题、内存泄漏、线程死锁等线上问题的“利器”。

这些工具可以大致分为两类：**命令行工具**（轻量、适合服务器环境）和 **图形化工具**（直观、适合本地分析）。

### JVM监控与故障修复

#### 核心命令行工具 (JDK 自带)

这些工具通常位于 `$JAVA_HOME/bin` 目录下，是进行线上问题排查的基础。

| 工具         | 全称                                            | 主要用途                                                     | 关键命令/参数                                                | 特点                                                         |
| :----------- | :---------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **`jps`**    | Java Virtual Machine Process Status Tool        | **列出当前服务器上所有正在运行的 Java 进程**及其 `LVMID` (Local Virtual Machine Identifier)。 | `jps -l` (显示主类全名) <br> `jps -v` (显示 JVM 参数) <br> `jps -m` (显示传给 main 方法的参数) | **第一步**：快速定位目标 Java 进程的 PID。                   |
| **`jstat`**  | Java Virtual Machine Statistics Monitoring Tool | **实时监控 JVM 的各种统计信息**，特别是**垃圾收集 (GC) 情况**。 | `jstat -gc <pid> <interval> <count>` <br> `-gc`: 显示 GC 堆状态 <br> `-gccapacity`: 堆容量 <br> `-gcutil`: GC 利用率 <br> `-class`: 类加载/卸载统计 <br> `<interval>`: 采样间隔 (ms) <br> `<count>`: 采样次数 | **核心监控工具**：用于分析 GC 频率、停顿时间、各代内存变化。是判断是否存在内存问题的第一手资料。 |
| **`jinfo`**  | Configuration Info for Java                     | **查看和修改正在运行的 Java 进程的配置参数**。               | `jinfo <pid>` (查看所有参数) <br> `jinfo -flag <name> <pid>` (查看特定参数，如 `-flag MaxHeapSize`) <br> `jinfo -flag [+/-]<name> <pid>` (动态开启/关闭布尔型参数，如 `-flag +PrintGCDetails`) | **查看参数**：确认 JVM 启动参数（尤其是 GC 相关参数）。<br> **有限修改**：只能修改部分 `-XX` 参数。 |
| **`jmap`**   | Memory Map for Java                             | **生成 Java 进程的内存快照 (Heap Dump)**，或**查看堆内存的详细统计信息**。 | `jmap -heap <pid>` (显示堆详细信息) <br> `jmap -histo[:live] <pid>` (显示对象实例数和大小的直方图) <br> `jmap -dump:format=b,file=heap.hprof <pid>` (**生成堆转储文件**) | **内存分析核心**：`-dump` 用于生成 `heap dump` 文件，是分析内存泄漏的**关键**。`-histo` 可快速查看内存中占用最多的对象类型。 |
| **`jstack`** | Stack Trace for Java                            | **生成 Java 进程当前时刻的线程快照 (Thread Dump)**，列出所有线程的堆栈信息。 | `jstack <pid>` <br> `jstack -l <pid>` (显示额外的锁信息，推荐使用) | **线程分析核心**：用于诊断**线程死锁、死循环、长时间等待、高 CPU 占用**等问题。通过分析线程状态和堆栈，可以定位代码瓶颈。 |

> **记忆技巧**: 联想记忆
> *   `jps` -> `ps` (Linux 进程查看)
> *   `jstat` -> `stat` (状态统计)
> *   `jinfo` -> `info` (信息查看)
> *   `jmap` -> `map` (内存映射/快照)
> *   `jstack` -> `stack` (调用栈)

#### 核心图形化工具 (JDK 自带)

这些工具提供了更直观的界面，通常需要将数据从服务器导出到本地分析。

| 工具                            | 主要用途                         | 特点                                                         | 与命令行工具的关系                                           |
| :------------------------------ | :------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **`jconsole`**                  | **Java 监视与管理控制台**        | - 提供图形化界面，实时监控 JVM 的 **内存、线程、类加载、GC、MBean**。<br> - 可以连接本地或远程 JVM。<br> - 内置简单的线程和内存分析功能。 | - 它的监控数据底层依赖 `jstat`、`jinfo` 等。<br> - 可以手动触发 GC (`Perform GC`) 和生成堆/线程转储。 |
| **`jvisualvm`** (或 `visualvm`) | **多合一故障诊断和性能分析工具** | - 功能比 `jconsole` **强大得多**，是 `jconsole` + `jstat` + `jmap` + `jstack` + `jinfo` 的图形化整合。<br> - 可以加载和分析本地的 `heap dump` (.hprof) 文件，进行内存泄漏分析。<br> - 可以加载和分析 `thread dump` 文件。<br> - 支持 Profiling (性能剖析)，可以监控方法执行时间和对象创建。<br> - 支持插件扩展。 | - 是**最推荐**的本地分析工具。<br> - 可以连接运行中的 JVM 实时监控，也可以离线分析 dump 文件。 |

---

#### 第三方与高级工具

| 工具/技术                                                    | 主要用途                           | 特点                                                         |
| :----------------------------------------------------------- | :--------------------------------- | :----------------------------------------------------------- |
| **`Arthas` (阿尔萨斯)**                                      | **阿里巴巴开源的 Java 诊断利器**   | - **线上问题排查神器**！无需重启 JVM，无需修改代码。<br> - 基于命令行，功能极其强大：`dashboard` (实时仪表盘), `thread` (线程分析), `sc`/`sm` (查看已加载类/方法), `jad` (反编译), `watch` (观察方法入参/返回值/异常), `trace` (方法内部调用路径追踪), `monitor` (监控方法执行), `tt` (方法执行记录回放) 等。<br> - 特别适合在**生产环境**快速定位复杂问题。 |
| **`JFR` (Java Flight Recorder) + `JMC` (Java Mission Control)** | **低开销的生产环境事件收集和分析** | - **JFR**: 内置于 JVM 的事件记录器，可以以**极低的性能开销**（通常 < 2%）持续收集 JVM 和应用程序的运行时数据（GC、内存分配、线程、锁、IO、方法采样等）。<br> - **JMC**: 图形化分析工具，用于打开和分析 JFR 生成的 `.jfr` 记录文件。<br> - **适合长期监控和事后分析**，能还原问题发生时的完整上下文。Java 8u40+ 商业版可用，Java 11+ 开源免费。 |
| **`GC 日志分析`**                                            | **深入分析垃圾回收行为**           | - 通过 `-XX:+PrintGCDetails -Xloggc:gc.log` 等参数开启 GC 日志。<br> - 使用工具如 **`GCViewer`**, **`gceasy.io`** 在线工具分析日志。<br> - 可以精确看到每次 GC 的类型 (Minor GC, Full GC)、触发原因、各代内存变化、停顿时间 (Pause Time)、吞吐量等，是调优 GC 参数的基础。 |
| **`Prometheus + Grafana` + `Micrometer`/`JMX Exporter`**     | **生产环境监控告警系统**           | - **Prometheus**: 时序数据库，用于拉取和存储监控指标。<br> - **JMX Exporter**: 一个 Java Agent，可以将 JVM 的 JMX 指标暴露为 Prometheus 可抓取的 HTTP 端点。<br> - **Grafana**: 强大的可视化工具，用于展示 Prometheus 中的数据，制作监控大盘。<br> - **Micrometer**: 应用指标收集库，可将应用自定义指标和 JVM 指标发送到 Prometheus 等后端。<br> - 这是构建**现代化、自动化监控体系**的标准方案。 |

#### 工具使用场景对比与选择

| 问题场景                                                | 推荐工具                                                     |
| :------------------------------------------------------ | :----------------------------------------------------------- |
| **快速查看有哪些 Java 进程在运行？**                    | `jps`                                                        |
| **实时监控 JVM 内存和 GC 情况？**                       | `jstat` (命令行), `jconsole`/`jvisualvm` (图形化)            |
| **确认 JVM 启动参数？**                                 | `jinfo`                                                      |
| **怀疑有内存泄漏，如何分析？**                          | 1. `jmap -dump` 生成堆转储文件。<br> 2. 使用 `jvisualvm` 或 `Eclipse MAT` (Memory Analyzer Tool) 分析 `.hprof` 文件，查找大对象或对象引用链。 |
| **CPU 占用过高，如何定位？**                            | 1. `top -H -p <pid>` 找到占用最高的线程 ID (TID)。<br> 2. 将 TID 转换为 16 进制 (`printf "%x\n" <tid>`)。<br> 3. `jstack <pid>` 查看线程堆栈，搜索 16 进制的 TID，定位到具体代码行。<br> *(更简单: `Arthas` 的 `thread --top` 或 `thread <nid>`)* |
| **怀疑线程死锁？**                                      | `jstack -l <pid>`，查找 `Found one Java-level deadlock` 相关信息。<br> `jvisualvm` 的线程标签页也能自动检测死锁。 |
| **生产环境需要动态诊断，不想重启？**                    | **`Arthas`** (首选)                                          |
| **需要长期、低开销地记录 JVM 运行状况，用于事后分析？** | **`JFR + JMC`**                                              |
| **需要构建自动化监控告警系统？**                        | **`Prometheus + Grafana + JMX Exporter/Micrometer`**         |
| **需要对代码进行性能剖析 (Profiling)，找性能瓶颈？**    | `jvisualvm` (内置 Profiler), `JFR`, `Arthas trace`, 或专业的 Profiler 工具 (如 `Async-Profiler`)。 |

#### JProfiler(商业软件，慎用)

**JProfiler** 是一款由 **Eclipse Metrics (原 ej-technologies)** 公司开发的、功能非常强大的**商业级 Java 性能分析和监控工具 (Java Profiler)**。

它属于我们上面提到的“**第三方与高级工具**”范畴，并且是其中非常知名和成熟的一款。可以把它看作是 `jvisualvm` 内置 Profiler 功能的**专业、企业级、功能全面得多的增强版**。

##### JProfiler 是什么？（定位与核心功能）

JProfiler 的核心定位是帮助开发者**诊断和解决 Java 应用程序的性能问题**。它通过在 JVM 中注入一个轻量级的代理（Agent），来收集应用程序运行时的详细数据，并提供一个直观、强大的图形化界面进行分析。

它的主要功能远超基础的 JVM 监控，深入到代码级别：

1.  **CPU Profiling (CPU 性能剖析)**:
    *   **热点分析 (Hot Spots)**: 精确找出哪些方法消耗了最多的 CPU 时间。
    *   **调用图 (Call Graph)**: 以图形化方式展示方法之间的调用关系和耗时，清晰地看到性能瓶颈的路径。
    *   **热点类/包**: 查看哪些类或包是 CPU 消耗大户。
    *   **方法统计**: 详细记录每个方法的调用次数、执行时间、自身时间（Self Time）等。
    *   **支持多种采样和检测模式**，以平衡性能开销和数据精度。

2.  **Memory Profiling (内存剖析)**:
    *   **堆遍历 (Heap Walker)**: 这是分析内存泄漏的利器。可以查看堆中所有对象的实例，按类、包、ClassLoader 等分组，分析对象的引用链（incoming/outgoing references），找出是什么阻止了对象被回收。
    *   **分配调用树 (Allocation Call Tree)**: 追踪对象是在哪个方法调用栈中被分配的，帮助你定位大量对象创建的源头。
    *   **记录对象分配**: 可以记录特定时间段内对象的分配情况。
    *   **比较堆转储 (Heap Dumps)**: 可以加载和比较多个 `hprof` 文件，分析对象数量的增长趋势，这是确认内存泄漏的关键。

3.  **Thread Profiling (线程剖析)**:
    *   **线程状态监控**: 实时监控所有线程的状态（运行、等待、阻塞、监视器等待等）。
    *   **线程历史**: 查看线程在过去一段时间的状态变化。
    *   **线程转储 (Thread Dumps)**: 生成和分析线程快照。
    *   **死锁检测**: 自动检测线程死锁和潜在的死锁。
    *   **Monitor & Locks**: 分析监视器（Monitor）和锁的争用情况，找出导致线程阻塞的锁。

4.  **Monitoring (监控)**:
    *   提供类似 `jconsole` 的实时监控视图，展示 CPU、内存（堆、非堆、各代）、类、线程、GC 活动等。
    *   可以设置阈值告警。

5.  **Telemetries (遥测)**:
    *   可以集成自定义的监控数据（如业务指标）到 JProfiler 的监控视图中。

6.  **Remote Profiling (远程分析)**:
    *   可以轻松地连接到远程服务器上的 Java 应用进行分析，通常通过修改启动脚本添加 JProfiler Agent 参数来实现。

##### JProfiler 与其他工具的对比

| 工具                                | 类型                | 是否免费 | 主要优势                                                     | 主要劣势                                                    | 与 JProfiler 的关系/对比                                     |
| :---------------------------------- | :------------------ | :------- | :----------------------------------------------------------- | :---------------------------------------------------------- | :----------------------------------------------------------- |
| **`jvisualvm`**                     | JDK 自带            | 免费     | 免费、集成度高、基础功能齐全（监控、dump分析、简单Profiler）。 | Profiler 功能相对基础，分析能力有限，界面较老。             | **JProfiler 的免费轻量级替代品**。JProfiler 在 Profiling 的深度、广度、易用性和可视化上全面超越 `jvisualvm`。 |
| **`JFR (Java Flight Recorder)`**    | JDK 内置 (Java 11+) | 免费     | 极低开销、生产环境友好、可长期记录、数据非常全面。           | 需要专门的分析工具（JMC），实时交互性不如 Profiler 工具。   | **互补关系**。JFR 适合长期、低开销的“黑匣子”记录。JProfiler 适合需要**主动、深入、交互式**分析的场景（如定位一个具体的性能瓶颈）。两者可以结合使用。 |
| **`Arthas`**                        | 开源                | 免费     | 免重启、线上诊断神器、命令行操作灵活、功能强大（watch, trace, tt等）。 | 命令行操作有一定学习成本，图形化分析能力弱。                | **互补关系**。Arthas 适合**线上快速诊断和修复**。JProfiler 适合**线下深度性能分析和优化**。Arthas 更“快”，JProfiler 更“深”。 |
| **`Eclipse MAT (Memory Analyzer)`** | 开源                | 免费     | 专注于堆转储分析，内存泄漏分析功能极其强大。                 | 只能分析离线的 `hprof` 文件，不能实时监控或 CPU Profiling。 | **JProfiler 的 Heap Walker 功能对标 MAT**。JProfiler 集成了强大的内存分析能力，无需切换到另一个工具。 |

##### JProfiler 的优缺点

*   **优点**:
    *   **功能极其全面**: CPU, Memory, Threads 三大核心问题一网打尽。
    *   **分析能力强大**: 图形化界面直观，分析功能深入（如调用图、堆遍历、分配调用树）。
    *   **用户体验好**: 界面现代，操作流畅，文档和教程丰富。
    *   **生产环境可用**: 虽然有一定开销，但其采样模式和优化使其可以在生产环境谨慎使用（相比一些 Profiler，JProfiler 的开销控制得相对较好）。
    *   **集成性好**: 支持与 IDE (IntelliJ IDEA, Eclipse) 集成。

*   **缺点**:
    *   **商业收费**: 这是最大的缺点。个人和小团队使用成本较高，需要购买许可证。
    *   **有一定性能开销**: 启用 Profiling 会增加 JVM 的负担，尤其是在“检测 (Instrumentation)”模式下。需要根据场景选择合适的模式。
    *   **学习曲线**: 功能太多，新手可能需要时间熟悉。

#### 总结

1.  **基础必备**: `jps`, `jstat`, `jmap`, `jstack`, `jinfo` 是每个 Java 工程师都必须掌握的命令行工具。
2.  **本地分析利器**: `jvisualvm` 是功能最全的本地分析工具，强烈推荐掌握。
3.  **线上诊断神器**: `Arthas` 极大地提升了线上问题排查的效率，是现代 Java 开发者的必备技能。
4.  **深度监控与调优**: `JFR/JMC` 和 `GC 日志分析` 是进行深度性能分析和 GC 调优的关键。
5.  **生产监控体系**: `Prometheus + Grafana` 是构建企业级监控告警平台的事实标准。

## 算法

> ACM模式要熟悉，注意报错位置提示

### 数组

> 1. 要用栈或者队列的时候，`ArrayDeque<Character> deque=new ArrayDeque<>();`
>
>    - `offerLast()` `pollLast`就是栈
>
>    - `offerLast()` `pollFirst`就是队列
>
>    - 用`pop()`，因为栈顶为空时候会抛异常，用之前要判断stack不为空
>
> 2. 左右指针`left`和`right`,`mid=left+((right-left)>>1)`
>
> 3. 前后指针`pre`和`cur`，一般都从0开始

- [x] [704.二分查找](https://leetcode.cn/problems/binary-search/)
- [x] [35.搜索插入位置](https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html)
- [x] [34.在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html)
- [x] [69.x 的平方根](https://leetcode.cn/problems/sqrtx/)
- [x] [367.有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)
- [x] [27.移除元素](https://leetcode.cn/problems/remove-element/)
- [x] [26.删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
- [x] [283.移动零](https://leetcode.cn/problems/move-zeroes/)
- [x] [844.比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)
- [x] [977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)
- [x] [209.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
- [x] [904.水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)【滑动窗口，重点】
- [x] [76.最小覆盖子串(opens new window)](https://leetcode.cn/problems/minimum-window-substring/)【滑动窗口】
- [x] [59.螺旋矩阵二](https://leetcode.cn/problems/spiral-matrix-ii/)
- [x] [54.螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
- [x] [剑指Offer 29.顺时针打印矩阵(opens new window)](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)
- [x] [58.区间和](https://kamacoder.com/problempage.php?pid=1070)
- [x] [44.开发商购买土地](https://kamacoder.com/problempage.php?pid=1044)【前缀和】

### 链表

- [x] [203.移除链表](https://leetcode.cn/problems/remove-linked-list-elements/)
- [x] [707.设计链表](https://leetcode.cn/problems/design-linked-list/)【虚拟头结点，用length记录链表长度比较好判断是否越界】
- [x] [206.反转链表](https://leetcode.cn/problems/reverse-linked-list/)
- [x] [24.两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)
- [x] [19.删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)【提前移动n+1个位置】
- [x] [160.链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)【拼接列表】
- [x] [142.环形列表二](https://leetcode.cn/problems/linked-list-cycle-ii/)【快慢指针】

### 哈希表

- [x] [242.有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)
- [x] [349.两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)
- [x] [202.快乐数](https://leetcode.cn/problems/happy-number/)
- [x] [1.两数之和](https://leetcode.cn/problems/two-sum/)
- [x] [454.四数相加二](https://leetcode.cn/problems/4sum-ii/)
- [x] [383.赎金信](https://leetcode.cn/problems/ransom-note/)
- [x] [15.三数之和](https://leetcode.cn/problems/3sum/)
- [x] [18.四数之和](https://leetcode.cn/problems/4sum/)

### 字符串

- [x] [344.反转字符串](https://leetcode.cn/problems/reverse-string/)
- [x] [541.反转字符串二](https://leetcode.cn/problems/reverse-string-ii/)
- [x] [替换数字](https://kamacoder.com/problempage.php?pid=1064)
- [x] [151.翻转字符串里的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)
- [x] [右转字符串](https://kamacoder.com/problempage.php?pid=1065)
- [x] [**28.实现strStr()**](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)【KMP前缀表需要背下来】
- [x] [**459.重复的子字符串**](https://leetcode.cn/problems/repeated-substring-pattern/)【KMP前缀表需要背下来】

#### 28.实现strStr()另外解法

```java
class Solution {
    public int strStr(String haystack, String needle) {
        List<Character> parentList=new ArrayList<>();
        for(Character c:haystack.toCharArray()){
            parentList.add(c);
        }
        List<Character> subList=new ArrayList<>();
        for(Character c:needle.toCharArray()){
            subList.add(c);
        }
        return Collections.indexOfSubList(parentList,subList);
    }
   
}
```





### 双指针

前面都做过了

### 栈与队列

> ArrayDeque是常见的队列和栈的好帮手
>
> - 队列：offer()、poll()、add()、remove()、peek() 
> - 栈：pop()、push()
> - 搞不清楚的话用offerFirst()等API也行，算法AC出来就行

- [x] [232.用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
- [x] [225.用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)
- [x] [20.有效的括号](https://leetcode.cn/problems/valid-parentheses/)
- [x] [1047.删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)
- [x] [150.逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)【栈】
- [x] [239.滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)【LinkedList<Integer>单调栈】✓✓
- [x] [347.前K个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)【HashMap+PriorityQueue<int[]>小顶堆】

## Linux命令

### Free命令

`free` 是 Linux 系统中一个非常常用的命令，用于显示系统中**物理内存**和**交换内存（swap）** 的使用情况。

---

#### 📌 基本语法

```bash
free [选项]
```

---

#### 🖥️ 示例输出

```bash
$ free -h
               total        used        free      shared     buff/cache   available
Mem:           7.7Gi       2.3Gi       1.8Gi       156Mi       3.6Gi       5.0Gi
Swap:          2.0Gi          0B       2.0Gi
```

---

#### 🔍 各列含义

| 列名           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| **total**      | 总内存大小                                                   |
| **used**       | 已使用的内存（= total - free - buff/cache）                  |
| **free**       | 完全未被使用的内存                                           |
| **shared**     | 多个进程共享的内存（如 tmpfs、容器等）                       |
| **buff/cache** | 用于缓冲区（buffers）和页面缓存（cache）的内存               |
| **available**  | **预估**的可用内存（应用程序可立即使用），比 `free` 更准确，考虑了可回收的缓存 |

> ✅ **`available` 是判断系统是否“内存充足”的关键指标**。

---

#### 🧰 常用选项

| 选项   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| `-h`   | 以**人类可读**的方式显示（自动使用 K, M, G 等单位）✅ 推荐使用 |
| `-m`   | 以 **MB** 为单位显示                                         |
| `-g`   | 以 **GB** 为单位显示                                         |
| `-k`   | 以 **KB** 为单位显示（默认）                                 |
| `-s N` | 每 N 秒刷新一次（持续监控）<br>例如：`free -h -s 2` 每 2 秒刷新一次 |
| `-c N` | 显示 N 次后退出（配合 `-s` 使用）<br>例如：`free -h -s 1 -c 5` 每秒刷新，共显示 5 次 |

---

#### 🎯 实用技巧

1. **快速查看内存使用率**：
   ```bash
   free -h
   ```

2. **持续监控内存变化**（类似 `top` 的内存部分）：
   ```bash
   free -h -s 3
   ```

3. **只看可用内存**（判断是否需要扩容或优化）：
   ```bash
   free -h | grep Mem | awk '{print "Available: " $7}'
   ```

4. **查看 swap 使用情况**：
   ```bash
   free -h | grep Swap
   ```
   > 如果 `used` > 0，说明系统开始使用交换分区，可能内存不足。

---

#### ⚠️ 注意事项

- `used` 内存并不完全等于“应用程序占用”，它包含了内核缓冲和缓存。
- `buff/cache` 虽然被标记为“已用”，但**在内存紧张时可以被回收**，所以这部分内存其实是“可释放”的。
- 因此，**`available` 比 `free` 更能反映系统还能分配多少内存给新程序**。

---

#### ✅ 总结

> `free -h` 是查看 Linux 内存使用情况的**最常用、最推荐命令**，重点关注 **`available`** 列，它告诉你系统还有多少内存可以分配给新应用。

适合用于系统监控、性能调优、排查内存不足等问题。



## 面对HR提问

#### **面对** **HR** **或者其他** **Level** **比较低的面试官时**

1. 能不能谈谈你作为一个公司老员工对公司的感受? (这个问题比较容易回答，不会让面试官陷入无话

可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司

到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上

还可以拉进你与面试官的距离。)

2. 能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你?有

什么地方你觉得还不太好或者可以继续完善吗？ （类似第一个问题，都是问面试官个人对于公司的

看法，）

3. 我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？(这个是我常问的。我觉得说自己表

现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)

4. 接下来我会有一段空档期，有什么值得注意或者建议学习的吗？ （体现出你对工作比较上心，自助

学习意识比较强。）

5. 这个岗位为什么还在招人？ (岗位真实性和价值咨询)
6. 大概什么时候能给我回复呢？ (终面的时候，如果面试官没有说的话，可以问一下)
7. 公司技术栈、业务方向、办公地点、薪资架构、福利待遇、加班情况、签约年限、新员工的培养计划、签订合同是和谁签、实习期是否全额工资、实习期长度、公司研发部门人员架构

#### **面对部门领导**

1. 部门的主要人员分配以及对应的主要工作能简单介绍一下吗？

2. 未来如果我要加入这个团队，你对我的期望是什么？ （部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）

3. 公司对新入职的员工的培养机制是什么样的呢？ （正规的公司一般都有培养机制，提前问一下是对

   你自己的负责也会显的你比较上心）

4. 以您来看，这个岗位未来在公司内部的发展如何？ (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)

5. 团队现在面临的最大挑战是什么？ (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期。)
