# 面试学习笔记



## 1. Java基础

### 字节码的好处？

- JVM 可以理解的代码就叫做字节码，是一种IR **Intermediate Representation**（中间表示）**Java 字节码是 Java 语言从源代码到最终执行过程中的关键 IR**。

- **在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点**。

`.class->机器码` 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 **JIT（Just in Time Compilation）** 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 **Java 是编译与解释共存的语言** 。

Java的执行过程整体可以分为两个部分

- 第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。
- 接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。

### IR是什么？

1. **Java 字节码作为 IR**：

- 当你用 Java 编写代码并使用 `javac` 编译时，源代码（`.java` 文件）会被编译成一种称为 **Java 字节码** 的中间形式（`.class` 文件）。
- 这种字节码就是 Java 平台的 **中间表示 (IR)**。它不是特定于某个 CPU 的机器码，而是一种抽象的、平台无关的指令集。
- Java 虚拟机 (JVM) 负责解释执行这些字节码，或者通过即时编译器 (JIT) 将其动态编译成本地机器码以提高性能。
- 因此，**Java 字节码是 Java 语言从源代码到最终执行过程中的关键 IR**。

2. **其他编译器/分析工具中的 IR**：

- 一些更高级的 Java 工具或框架（如用于程序分析、优化、混淆、静态检查的工具）可能会在处理 Java 字节码之前或之后，将其转换成自己内部定义的、更易于分析和操作的 **自定义 IR**。
- 例如，像 **ASM**、**Javassist** 这样的字节码操作库，或者像 **Soot** 这样的程序分析框架，它们在内部可能会构建自己的 IR 来表示 Java 程序的结构（如控制流图 CFG、调用图等），以便进行更复杂的分析和转换。

### 什么是程序分析、优化、混淆、静态检查？

1. **程序分析 (Program Analysis)**
   - **定义**：程序分析是指系统地检查和理解程序的结构、行为、属性和潜在问题的过程。其目的是获取关于程序的深层信息，而不一定执行它（静态分析）或在执行时观察它（动态分析）。
   - 在 Java 中的应用：
     - **控制流分析 (Control Flow Analysis)**：构建程序的控制流图 (CFG)，展示代码块如何通过分支（if/else）、循环（for/while）和函数调用相互连接。这对于理解程序执行路径至关重要。
     - **数据流分析 (Data Flow Analysis)**：追踪程序中数据（变量）的定义、使用和传播。例如，分析一个变量在哪些地方被赋值，在哪些地方被读取，或者判断一个变量是否可能为 `null`。
     - **指针分析 / 别名分析 (Pointer/Alias Analysis)**：确定程序中的引用（指针）可能指向哪些对象，以及哪些不同的引用可能指向同一个对象（别名）。这在理解对象生命周期和并发问题时非常重要。
     - **调用图分析 (Call Graph Analysis)**：构建一个图，显示程序中哪些方法调用了哪些其他方法。这对于理解程序的整体结构、进行优化和检测死代码很有用。
     - **依赖分析**：分析类、方法、包之间的依赖关系。
   - **为什么需要 IR**：直接分析字节码指令序列比较复杂。自定义的 IR（如更高级的三地址码、SSA 形式）可以更清晰地表示控制流和数据流，使得分析算法（如数据流分析中的定值-引用链计算）更容易实现和优化。
2. **优化 (Optimization)**
   - **定义**：优化是指在不改变程序外部行为（语义）的前提下，修改程序以提高其性能（如运行速度、内存占用）或减小其体积（如代码大小）的过程。
   - 在 Java 中的应用：
     - **JIT 编译器优化**：JVM 的即时编译器（如 HotSpot 的 C1/C2）会将频繁执行的字节码编译成本地机器码，并在此过程中应用大量优化，如方法内联（Inlining）、循环展开（Loop Unrolling）、公共子表达式消除（CSE）、死代码消除（Dead Code Elimination）、逃逸分析（Escape Analysis）等。
     - **AOT 编译器优化**：像 GraalVM Native Image 这样的工具将 Java 程序提前编译（Ahead-of-Time）为本地可执行文件，会进行更激进的优化和链接。
     - **字节码优化工具**：一些工具专门用于优化 `.class` 文件，例如 ProGuard（也包含混淆功能）可以进行类/字段/方法名的缩短、无用代码/资源的移除、代码结构的简化等。
   - **为什么需要 IR**：优化通常需要复杂的分析（如上面提到的数据流、控制流分析）。一个设计良好的 IR 能够清晰地暴露程序的结构和数据依赖关系，使得优化算法（如识别可内联的方法、判断循环不变量）能够更有效地应用。优化后的 IR 再被转换回目标格式（字节码或机器码）。
3. **混淆 (Obfuscation)**
   - **定义**：混淆是指有意地修改程序的代码或结构，使其对人类（尤其是逆向工程师）来说变得难以阅读、理解和分析，但同时保持其原有的功能和行为。主要目的是保护知识产权和防止恶意篡改。
   - 在 Java 中的应用：
     - **名称混淆 (Name Obfuscation)**：将具有描述性意义的类名、方法名、字段名替换为无意义的短字符串（如 `a`, `b`, `c`）或 Unicode 难以阅读的字符。这是最常见和最基础的混淆。
     - **流混淆 (Flow Obfuscation)**：修改程序的控制流，例如插入无用的条件分支、循环或 try-catch 块，或者打乱代码执行顺序（在不改变逻辑的前提下），使控制流图变得复杂难懂。
     - **字符串加密 (String Encryption)**：将代码中的字符串常量加密存储，在运行时才解密使用，防止通过字符串搜索轻易找到关键逻辑。
     - **类/包结构混淆**：改变类的继承关系或包结构（在不破坏功能的情况下），增加理解难度。
   - **为什么需要 IR**：要进行有效的混淆（尤其是流混淆和高级混淆），工具需要深入理解程序的逻辑结构和数据依赖。自定义 IR 提供了一个抽象层，允许混淆器安全地插入无用代码、重排指令或修改控制流，同时利用分析确保不会破坏程序的正确性。直接在字节码层面操作风险更高。
4. **静态检查 (Static Checking)**
   - **定义**：静态检查是一种在程序**不实际运行**的情况下，通过分析其源代码或字节码来发现潜在错误、代码缺陷、安全漏洞、风格问题或违反编码规范的软件质量保证技术。
   - 在 Java 中的应用：
     - **编译器警告**：`javac` 本身会进行基本的静态检查，如未使用的变量、不可达代码、类型不匹配等。
     - **Lint 工具**：如 **Checkstyle** (检查代码风格和规范), **PMD** (检测常见编程缺陷、未使用代码、复杂度过高等), **SpotBugs** (前身是 FindBugs，利用字节码分析检测空指针解引用、资源泄漏、并发问题等潜在 bug)。
     - **安全扫描工具**：如 **SonarQube/SonarLint** (集成多种检查，包括安全漏洞、代码异味、重复代码等), **Fortify**, **Checkmarx** (专门用于发现安全漏洞，如 SQL 注入、XSS、不安全的反序列化等)。
     - **Null 安全分析**：一些工具或语言特性（如 Kotlin 的非空类型，或 Java 的 `@Nullable`/`@NonNull` 注解配合分析工具）可以静态地推断变量是否可能为 null，从而预防 `NullPointerException`。

### 什么是热点代码？

Java的执行过程整体可以分为两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析、语法分析、语义分析，编译原理中这部分的编译称为前端编译。接下来无需编译直接逐条将字节码解释执行，在解释执行的过程中，虚拟机同时对程序运行的信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会进行后端编译——把字节码编译成机器码，但不是所有的代码都会被编译，只有被JVM认定为的热点代码，才可能被编译。

当方法或者代码块的在一定时间内的调用次数超过这个阈值时就会被编译，存入codeCache中。当下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。

### 静态编译与动态编译

Java的JVM中的JIT编译器是动态编译，选用GraalVM(完整的JDK发行版)可以做到静态编译 **AOT(Ahead of Time Compilation)** 

AOT 的主要优势在于启动时间、内存占用和打包体积。JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。

GraalVM 不仅能提供 AOT 编译，还能提供 JIT 编译

我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，**AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化**。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 `.class` 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。

### 移位运算符

移位运算符最常用于快速乘以或除以 2 的幂次方。除此之外，它还在以下方面发挥着重要作用：

- **位字段管理**：例如存储和操作多个布尔值。
- **哈希算法和加密解密**：通过移位和与、或等操作来混淆数据。
- **数据压缩**：例如霍夫曼编码通过移位运算符可以快速处理和操作二进制数据，以生成紧凑的压缩格式。
- **数据校验**：例如 CRC（循环冗余校验）通过移位和多项式除法生成和校验数据完整性。
- **内存对齐**：通过移位操作，可以轻松计算和调整数据的对齐地址



