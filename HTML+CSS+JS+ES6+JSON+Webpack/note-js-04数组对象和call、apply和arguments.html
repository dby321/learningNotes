<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // 造一个数组对象
        var arr = new Array(10, 20, 30);


        // 字面量创建 数组
        var arr = [1, 2, 3, 4, 5];

        console.log("------------------");
        // 数组中放对象
        var obj = {
            name: "董滨雨",
            age: 18
        };
        var obj2 = {
            name: "李铭霞",
            age: 18
        };
        var arr = [obj, obj2];
        console.log(arr[0]);
        console.log(arr[1]);
        console.log(arr[0].name);

        // 数组中放数组 二维数组

        console.log("------------------");

        // 数组常见方法
        var arr = ["董滨雨", 12.3, Infinity, undefined];
        console.log(arr);
        // push()    数组 结尾加
        arr.push("结尾加");
        console.log(arr);

        // pop()     数组 结尾减
        arr.pop();
        console.log(arr);

        // unshift() 数组 开头加
        arr.unshift("开头加");
        console.log(arr);

        // shift()   数组 开头减
        arr.shift();
        console.log(arr);

        console.log("---------------------");
        // 数组的遍历
        // 方法一
        for (var i = 0; i < arr.length; i++) {
            console.log("arr" + i + ":" + arr[i]);
        }
        console.log("--------------");
        // 方法二 forEach 高阶函数,和java一致
        arr.forEach((element, index, obj) => {
            console.log(element + "|" + index + "|" + obj);
        });

        console.log("---------------------");
        // slice()该方法不会改变原数组[start,end)
        arr2 = arr.slice(0, 2);
        arr3 = arr.slice(1);
        // 针对很长的数组 -1是指倒数第一个
        arr4 = arr.slice(0, -1);
        console.log(arr);
        console.log(arr2);
        console.log(arr3);
        console.log(arr4);

        console.log("----------------------");
        // splice()会改变原数组 返回被删除后的数组
        arr5 = arr.splice(0, 2, "李铭霞", "真好看");
        console.log(arr);
        console.log(arr5);

        console.log("----------------------");
        // 数组的去重
        var arr = [1, 2, 3, 4, 5, 5, 3, 2];
        console.log(arr);
        for (var i = 0; i < arr.length; i++) {
            for (var j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    arr.splice(j--, 1);
                }
            }
        }
        console.log(arr);
        console.log("----------------------");
        // reverse() 反转
        // concat() 连接数组 不改变原数组
        arr10 = arr.concat(arr2, "牛魔王");
        console.log(arr10);

        // join() 将数组转换为字符串
        var result = arr.join("--");
        console.log(result);
        // sort() 会默认使用Unicode编码排序，对数字排序可能会出错
        // 正确实现升序
        var shengxu = arr.sort((a, b) => {
            return a - b;
        });
        console.log(shengxu);




        console.log("-------------------------");
        /* call()和apply()要通过 函数对象 来调用 
            类似于Java中的静态方法
        */
        var obj = {
            name: "董滨雨",
            age: 22
        };

        function Person() {
            console.log("这是Person " + this);
        }
        // 这三种方式等效
        // this此时指向 Window对象
        Person.apply(); // 这是Person [object Window]
        Person.call(); // 这是Person [object Window]
        Person(); // 这是Person [object Window] 
        console.log("-------------------------");
        // 第一个参数是谁，this就是谁
        // this此时指向 Object对象
        Person.call(obj); // 这是Person [object Object] 
        Person.apply(obj); // 这是Person [object Object]


        // call(this指向的对象obj,实参1,实参2)
        function People(a, b) {
            console.log("this:" + this + " a:" + a + " b:" + b);
        }
        People.call(obj, 2, 3); // this:[object Object] a:2 b:3
        // apply(this指向的对象obj,[实参1,实参2]) 需要将实参封装到一个数组中
        People.apply(obj, [2, 3]); // this:[object Object] a:2 b:3

        var obj = {
            name: "obj"
        };
        var obj2 = {
            name:"obj2"
        }
        function fun(){
            console.log(this.name);
        }
        fun.call(obj); // obj
        fun.call(obj2); // obj2

        function fun(a, b){
            console.log("a = " + a + ", b = " + b);
        }
        fun.call(obj, 2, 3); // a = 2, b = 3
        fun.apply(obj, [2, 3]); // a = 2, b = 3

        /*
            # this的总结
            1.以函数形式调用时，this永远是window 
                - 其实 函数==window.函数，所以this也可以认为是 调用方法(函数)的对象window
                - 故 1和2 是统一的
            2.以方法的形式调用时，this是调用方法的对象
            3.以构造方法的形式调用时，this是新创建的那个对象
            4.使用call和apply调用时，this是指定的那个对象
        */

        /* 
            # arguments 是一个类数组对象
                - .length 获取实参的长度 就算不定义形参也能得到.length
                - .callee 得到当前函数
         */
        function fun(a,b){
            console.log("arguments.length = " + arguments.length + ", arguments[0] = " + arguments[0]); 
            console.log(arguments.callee);// 得到当前的函数对象fun()
            console.log(arguments.callee.name);// 得到当前的 函数对象名 "fun"
        }

        fun("董滨雨","123");
    </script>
</body>

</html>