# 2021Study-Java

[尚硅谷-宋红康JavaSE基础篇](https://www.bilibili.com/video/BV1Kb411W75N)

## 0 编程入门



### 0.1 概述

计算机包括**硬件（hardware）**和**软件（software）**两部分。

**程序设计**

**定义**：创建或开发软件，软件包含了指令，告诉计算机做什么

**应用场景**：软件遍布我们周围，除了个人计算机，飞机、汽车、手机甚至烤面包机中，同样运行着软件



**程序设计语言**

软件开发人员在称为程序设计语言的强大工具帮助下创建软件



如何选择学习哪种程序设计语言？？？

- 程序设计语言很多，每种都是为了实现某个特定目的而发明的

- **没有“最好”的语言**
- 经验丰富的程序员知道各种语言擅长的各个场景，因此，会尽可能的掌握各种不同的程序设计语言
- 如果掌握了一门编程语言，其他语言也会上手容易。关键是**学习如何使用程序设计方法来解决问题**

### 0.2 计算机硬件介绍

<img src=".\images\image-20210205175815808.png" alt="image-20210205175815808" style="zoom:50%;" />

在个人计算机上，**总线**搭建在**主板**上，主板是一个连接计算机各个部分的电路板

------

<img src=".\images\image-20210205180228145.png" alt="image-20210205180228145" style="zoom:50%;" />

**中央处理器（Central Processing Unit,CPU）**是计算机的电脑，它从内存中获取指令，然后执行这些指令

包括：控制单元（control unit）和算数/逻辑单元（arithmetic/login unit）。

**控制单元**：用于控制和协调其他组件的动作

**算术/逻辑单元**：用于完成数值运算（+-*/）和逻辑运算（比较）



每个计算机都有一个内部时钟，该时钟以一个固定速度发射电子脉冲。时钟速度越快，在给定的时间段内执行的指令就越多。速度的计量单位是**赫兹（Hz）**，1Hz相当于每秒发射一个脉冲。目前以**千兆赫（GHz）**来表述



最初一个CPU只有一个**核心（core）**。核是处理器中实现指令读取和执行的部分。多核CPU是具有两个以上的核组件，CPU的处理能力更高



现在的CPU都是构建在一块小小的**硅半导体芯片**上，这块芯片上包含数百万称为**晶体管**的小电路开关，用于处理信息



1khz=1024hz

1mhz=1024khz

1ghz=1024mhz

______

IT定律之计算机行业发展规律

- **摩尔定律**：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月变会增加一倍，性能也将提升一倍。
- **安迪-比尔定律**：what Andy gives,Bill takes away。软件吃掉硬件性能
- **反摩尔定律**：IT公司如果今天和18个月前卖掉同样多的产品，营业额就要降一半。

_____

内存信息会在断点时丢失，故**存储设备**有三种：

- 磁盘驱动器 
- 光盘驱动器 
- USB闪存驱动器

> 软驱占据了A，B两个盘

------------------------

比特(bit)和字节(byte)

计算机中**最小的存储单元**是比特

计算机中**最基本的存储单元**是字节



千字节(kilobyte,KB)=1024B

兆字节(metabyte,MB)=1024KB

_____

**内存**(Random-Access Memory,RAM):由一个有序的字节序列组成，用于存储程序及程序需要的数据

- **一个程序和它的数据在被CPU执行前必须移到内存中**

- 每一个字节都有一个唯一的地址，使用这个地址确定字节的位置，以便快速存储和获取数据

- 内存和CPU一样，也构建在表面镶嵌有数百万晶体管的硅半导体芯片上。但内存芯片更简单、更低速、更便宜

<img src=".\images\image-20210207114101263.png" alt="image-20210207114101263" style="zoom:50%;" />

CPU速度>>内存速度>>硬盘速度

------

输入设备：键盘和鼠标

输出设备：显示器和打印机



屏幕分辨率越高，越清晰

<img src=".\images\image-20210207115047569.png" alt="image-20210207115047569" style="zoom:50%;" />

**LCD**:本身发白光，用不同颜色的遮光板挡住呈现不同的颜色

**LED**:自发光源，自身发出不同颜色的光

----

**通信设备**，计算机可以通过通信设备进行联网

常见的通信设备有：

- **拨号调制解调器**：使用的是电话线，传输速度可达56000bps(bps,每秒比特)
- **DSL(数字用户线)**:使用的也是电话线，但传输速度是上面的20倍
- **电缆调制解调器**：利用有线电视电缆进行数据传输，通常速度比DSL快
- **网络接口卡(NIC)**:将计算机介入局域网(LAN)的设备。局域网通常用于大学、商业组织和政府组织。速度甚至可达1000Mbps
- **无线网络(Wi-fi)**:已然普及。所有智能终端通过无限适配器连接到局域网或Internet上。

### 0.3 计算机发展史上的鼻祖

**图灵**是当之无愧的计算机科学和人工智能之父，甚至与牛顿、爱因斯坦等巨人比肩

图灵论文中的“**用有限的指定和有限的存储空间可算尽一切可算之物**”理论让当时所有科学家震惊

美国计算机学会(ACM)的年度**图灵奖**。中国人只有姚期智院士获得该奖项

<img src=".\images\image-20210207120659219.png" alt="image-20210207120659219" style="zoom:50%;" />

**冯·诺依曼**是计算机之父和博弈论之父

冯·诺依曼的理论要点是:**数字计算机的数制采用二进制；计算机应该按照程序顺序执行**

<img src=".\images\image-20210207121147506.png" alt="image-20210207121147506" style="zoom: 50%;" />

### 0.4 操作系统

操作系统是运行在计算机上最重要的程序，它可以管理和控制计算机的活动

操作系统的主要任务：

- 控制和监视系统的活动
- 分配和调度系统资源
- 调度操作

<img src=".\images\image-20210207141142491.png" alt="image-20210207141142491" style="zoom:50%;" />

### 0.5 万维网

<img src=".\images\image-20210207141533319.png" alt="image-20210207141533319" style="zoom:50%;" />

**万维网**：是无数个网络站点和网页的集合，他们构成了因特网Internet最主要的部分

**因特网**：因特网也包括电子邮件、Usenet以及新闻组

**互联网**：又称国际网络，指的是[网络](https://baike.baidu.com/item/网络/143243)与网络之间所串连成的庞大网络，这些网络以一组通用的协议相连，形成逻辑上的单一巨大国际网络。

> 现在好像没有区分那么细致

常见软件架构：

- **B/S(browser server)**:浏览器服务器模型

- **C/S(client server)**:客户端服务器模型

### 0.6 职业发展与提升

不要想立刻换岗位，而要做**技术沉淀**

<img src=".\images\image-20210207142856377.png" alt="image-20210207142856377" style="zoom:50%;" />

不要妄想通过自学学会编程，而要在**工作中实践**

<img src=".\images\image-20210207143609927.png" alt="image-20210207143609927" style="zoom:50%;" />



### 0.7 学习经验探讨【重点】

**三分看，七分练**

<img src=".\images\image-20210207144218607.png" alt="image-20210207144218607" style="zoom:50%;" />

**多看多练，温故知新**

<img src=".\images\image-20210207144547191.png" alt="image-20210207144547191" style="zoom:50%;" />

**通过重复对抗遗忘曲线**

<img src=".\images\image-20210207145048476.png" alt="image-20210207145048476" style="zoom:50%;" />

<img src=".\images\image-20210207145224071.png" alt="image-20210207145224071" style="zoom:50%;" />



## 1 Java概述

> **Java基础是学习JavaEE、大数据、Android开发、鸿蒙上APP的基石**
>
> 有时间，可以花一周时间**突击Python**

**鸿蒙**系统上的APP开发语言果然是Java

<img src=".\images\image-20210207152355920.png" alt="image-20210207152355920" style="zoom:50%;" />

-----

Java代码场景举例：

<img src=".\images\image-20210207152636576.png" alt="image-20210207152636576"  />

<img src=".\images\image-20210207152714896.png" alt="image-20210207152714896"  />



<img src=".\images\image-20210207152818512.png" alt="image-20210207152818512"  />



----



<img src=".\images\image-20210207153304364.png" alt="image-20210207153304364"  />



### 1.1 软件开发介绍

软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有**系统软件**和**应用软件**之分

人机交互方式：

- **图形化界面（Graphical User Interface,GUI）**
- **命令行方式（Command Line Interface,CLI）**

---

常用的**DOS命令**：

|                   |                                |
| ----------------- | ------------------------------ |
| dir               | 列出当前目录下的文件以及文件夹 |
| md                | 创建目录                       |
| rd                | 删除目录                       |
| cd                | 进入指定目录                   |
| cd ..             | 退回到上一级目录               |
| cd \              | 退回到根目录                   |
| del               | 删除文件 del *.txt             |
| exit              | 退出dos命令行                  |
| echo javase>1.doc | 将javase写出到1.doc文件中      |

### 1.2 计算机编程语言介绍

**计算机语言**：人与计算机交流的方式

**高级编程语言**:C,C++,Java,PHP,Kotlin,Python,Scala,Golang等



第一代语言是**机器语言**，指令以二进制代码形式存在。010101011010

第二代语言是**汇编语言**，使用助记符表示一条机器指令。add 2,3,result

第三代语言是**高级语言**

- C、Pascal(主要用于编程数学)、Fortran(公式翻译，广泛用于科学和数学应用)面向过程的语言

- C++面向过程/面向对象的语言
- Java跨平台的纯面向对象的语言
- .NET跨平台的面向对象语言
- Python、Scala…

[TIOBE编程语言排行](https://www.tiobe.com/tiobe-index/)

---

**Google的Android系统结构**

<img src=".\images\image-20210207162542016.png" alt="image-20210207162542016" style="zoom:50%;" />

### 1.3 Java语言概述

- 是**SUN(Stanford University Network，斯坦福大学网络公司)**，1995年推出的一门高级编程语言。
- 是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序(applet)。applet使用现代的图形用户界面与Web用户进行交互。applet内嵌在HTML代码中。
- 随着Java技术在Web方面的不断成熟，已经成为Web应用程序的首选开发语言

<img src=".\images\image-20210207164258042.png" alt="image-20210207164258042" style="zoom:50%;" />

**后台（服务器端）开发语言**:Java、PHP、Python、Golang、Node.js

<img src=".\images\image-20210207165245183.png" alt="image-20210207165245183" style="zoom:50%;" />



<img src=".\images\image-20210207165442789.png" alt="image-20210207165442789" style="zoom:50%;" />

> Java语言概述见**《Java编程思想》**

### 1.4 Java语言运行机制及运行过程

**Java语言的特点**：

- 特点一：**面向对象**
  - 两个基本概念：类，对象
  - 三大特性：封装，继承，多态
- 特点二：**健壮性**
  - 吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分，提供了一个相对安全的内存管理和访问机制
- 特点三：**跨平台**
  - “Write once,Run Anywhere”
  - 原理：只要在需要Java应用程序的操作系统上，先安装一个Java虚拟机（JVM）即可。由JVM来负责Java程序在该系统中的运行。

<img src=".\images\image-20210207170310862.png" alt="image-20210207170310862" style="zoom:50%;" />



**Java的两种核心机制**：

- **Java虚拟机(Java Virtual Machine)**
  - **JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。**
  - 不同的平台有不同的虚拟机
  - 只有某平台提供了对应的Java虚拟机，Java程序才可在此平台运行
  - Java虚拟机机制屏蔽了底层运行平台的差别，实现了“**一次编译，到处运行**”

<img src=".\images\image-20210207170941436.png" alt="image-20210207170941436" style="zoom:50%;" />

- **垃圾收集机制(Garbage Collection)**
  - 不再使用的内存空间应当回收———垃圾回收
    - 在C/C++等语言中，由程序员负责回收无用内存
    - Java语言消除了程序员回收无用内存空间的责任；它提供一种系统级线程追踪存储空间的分配情况。并在JVM空闲时，检查并释放哪些可被释放的存储空间
  - 垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。
  - **Java程序还会出现内存泄漏和内存溢出问题吗？yes！**

### 1.5 Java语言环境搭建

[菜鸟教程-Java 开发环境配置](https://www.runoob.com/java/java-environment-setup.html)

**JDK(Java Development Kit,Java开发工具包)**:

- JDK是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就不用单独安装JRE了。

- 其中的开发工具：**编辑工具(javac.exe)** **打包工具(jar.exe)**等

**JRE(Java Runtime Environment,Java运行环境)**:

- JRE包括JVM和Java程序所需的核心类库等，如果想运行一个开发好的Java程序，只需要安装JRE即可。

<img src=".\images\image-20210207180430198.png" alt="image-20210207180430198" style="zoom:50%;" />

<img src=".\images\image-20210207180530276.png" alt="image-20210207180530276" style="zoom:67%;" />

### 1.6 开发体验——HelloWorld

<img src=".\images\image-20210207183618833.png" alt="image-20210207183618833" style="zoom:67%;" />

### 1.7 常见问题及解决方法

- 一个.java源文件中**只能有一个公共类**，但是**可以有多个类**
- 公共类的类名要和.java源文件的文件名完全一样
- `String[] args`中的args可以变，可写成`String[] a`

```java
public class HelloJava{
    public static void main(String[] args){
        System.out.println("HelloWorld");
    }
}
class Person{}
class Animal{}
```



### 1.8 注释(Comment)

[菜鸟教程-Java文档注释](https://www.runoob.com/java/java-documentation.html)

- 单行注释`//`:注释了的内容不参与编译
- 多行注释`/* */`:注释了的内容不参与编译
- **文档注释**`/** */`Java特有的，可以被javadoc解析

文档注释的内容可以被JDK提供的工具**javadoc**所解析，生成一套以网页文件形式体现的该程序的说明文档

```
javadoc -d javadoc-HelloJava -author -version HelloJava.java
```

### 1.9 JavaAPI文档

[OSCHINA-JDK1.6中文API文档](https://tool.oschina.net/apidocs/apidoc?api=jdk-zh)

**API(Application Programing Interface,应用程序编程接口)**是Java提供的基本编程接口

### 1.10 良好的编程风格

- 正确的注释和注释风格
  - 使用**文档注释来注释整个类或整个方法**
  - 如果**注释方法中的某一个步骤，使用单行或多行注释**
- 正确的缩进和空白
  - 使用一次tab操作，实现缩进
  - 运算符两边各加一个空格
- 块的风格
  - Java API源代码选择了**行尾风格**

### 1.11 常用的Java开发工具

**IDE(Integrated Development Environment,集成开发环境)**

文本编辑工具：

- 记事本
- UltraEdit
- EditPlus
- TestPad
- NotePad

Java IDE:

- JBuilder
- NetBeans
- Eclipse
- MyEclipse
- IntelliJ IDEA

### 每日复习

#### 课程整体内容概述

![image-20210217102950033](.\images\image-20210217102950033.png)

![image-20210217103156262](.\images\image-20210217103156262.png)

#### Java语言概述

软件：系统软件和应用软件

人机交互模式：图形化界面 vs 命令行界面

**应用程序 = 算法（决定程序正确与否） + 数据结构（决定程序效率高低）** Pascal之父说的

---

计算机语言的发展迭代史

第一代：机器语言

第二代：汇编语言

第三代：高级语言

- 面向过程：C，Pascal,Fortran 
- 面向对象：Java,Js,Python,Scala,…

---

![image-20210217105111368](.\images\image-20210217105111368.png)

---

Java语言应用的领域：

- Java Web开发：后台开发
- 大数据开发
- Android应用程序开发：客户端开发

---

Java语言的特点

- 面向对象性：

  - 两个要素：类、对象
  - 三个特征：封装、继承、多态

- 健壮性：

  - 去除了C语言中的指针
  - 自动的垃圾回收机制—>仍然会出现内存溢出、内存泄漏

- 跨平台性：write once,run anywhere：一次编译到处运行，功劳归功于JVM

  ![image-20210217105554739](.\images\image-20210217105554739.png)

#### 开发环境搭建

![image-20210217105805902](.\images\image-20210217105805902.png)

---

path环境变量的配置

path环境变量：windows操作系统执行命令时所要搜寻的路径

为什么要配置path？：希望Java开发工具（javac.exe,java.exe）在任何的文件路径下都可以执行成功

![image-20210217110219002](.\images\image-20210217110219002.png)

#### 第一个Java程序

<img src=".\images\image-20210207183618833.png" alt="image-20210207183618833" style="zoom:67%;" />

编译 javac HelloWorld.java

运行 java HelloWorld

#### 注释与API文档等

API：application programming interface习惯上：将语言提供的类库，都成为api

API文档：针对于提供的类库如何使用，给的一个说明书。类似于《新华字典》

#### 开发工具的使用

工具嘛，不会用的**学一周就会了**

## 2 Java基本语法

[菜鸟教程-Java基本语法](https://www.runoob.com/java/java-basic-syntax.html)

### 2.1 关键字和保留字

**关键字(keyword)：**

- 定义:被Java语言赋予了特殊含义，用做专门用途的字符串（单词）
- 特点:关键字中所有字母都为小写

| 类别                 | 关键字                         | 说明                 |
| :------------------- | :----------------------------- | :------------------- |
| 访问控制             | private                        | 私有的               |
| protected            | 受保护的                       |                      |
| public               | 公共的                         |                      |
| default              | 默认                           |                      |
| 类、方法和变量修饰符 | abstract                       | 声明抽象             |
| class                | 类                             |                      |
| extends              | 扩充,继承                      |                      |
| final                | 最终值,不可改变的              |                      |
| implements           | 实现（接口）                   |                      |
| interface            | 接口                           |                      |
| native               | 本地，原生方法（非 Java 实现） |                      |
| new                  | 新,创建                        |                      |
| static               | 静态                           |                      |
| strictfp             | 严格,精准                      |                      |
| synchronized         | 线程,同步                      |                      |
| transient            | 短暂                           |                      |
| volatile             | 易失                           |                      |
| 程序控制语句         | break                          | 跳出循环             |
| case                 | 定义一个值以供 switch 选择     |                      |
| continue             | 继续                           |                      |
| default              | 默认                           |                      |
| do                   | 运行                           |                      |
| else                 | 否则                           |                      |
| for                  | 循环                           |                      |
| if                   | 如果                           |                      |
| instanceof           | 实例                           |                      |
| return               | 返回                           |                      |
| switch               | 根据值选择执行                 |                      |
| while                | 循环                           |                      |
| 错误处理             | assert                         | 断言表达式是否为真   |
| catch                | 捕捉异常                       |                      |
| finally              | 有没有异常都执行               |                      |
| throw                | 抛出一个异常对象               |                      |
| throws               | 声明一个异常可能被抛出         |                      |
| try                  | 捕获异常                       |                      |
| 包相关               | import                         | 引入                 |
| package              | 包                             |                      |
| 基本类型             | boolean                        | 布尔型               |
| byte                 | 字节型                         |                      |
| char                 | 字符型                         |                      |
| double               | 双精度浮点                     |                      |
| float                | 单精度浮点                     |                      |
| int                  | 整型                           |                      |
| long                 | 长整型                         |                      |
| short                | 短整型                         |                      |
| 变量引用             | super                          | 父类,超类            |
| this                 | 本类                           |                      |
| void                 | 无返回值                       |                      |
| 保留关键字           | goto                           | 是关键字，但不能使用 |
| const                | 是关键字，但不能使用           |                      |
| null                 | 空                             |                      |

### 2.2 标识符(Identifier)

Java 所有的组成部分都需要名字。**类名、变量名以及方法名都被称为标识符**。

关于 Java 标识符，有以下几点需要注意：

- **所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始**
- 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合
- 关键字不能用作标识符
- **标识符是大小写敏感的**
- 合法标识符举例：age、$salary、_value、__1_value
- 非法标识符举例：123abc、-salary

------

 **名称命名规范**:

- 包名：全小写 **域名反写** 

- 类名、接口名：**大驼峰 **XxxYyyZzz

- 一般变量名、方法名：**小驼峰** xxxYyyZzz

- 常量名：全大写,且用**下划线连接**XXX_YYY_ZZZ

------

### 2.3 变量

[菜鸟教程-Java 基本数据类型【包括网页后笔记】](https://www.runoob.com/java/java-basic-datatypes.html)

[菜鸟教程-Java 变量类型【包括网页后笔记】](https://www.runoob.com/java/java-variable-types.html)

**变量的概念：**

- 内存中的一个存储区域
- 该区域的数据可以在同一类型范围内不断变化
- 变量时程序中最基本的存储单元。包含变量类型、变量名和存储的值

**变量的作用：**

- 用于在内存中保存数据

**使用变量注意：**

- Java中的每个变量必须先声明名后使用

---

**变量的分类-按数据类型**

<img src=".\images\image-20210207210736908.png" alt="image-20210207210736908" style="zoom: 67%;" />

包装类的**SIZE**,**MAX_VALUE**,**MIN_VALUE**都有定义基本数据类型的相关信息

```
基本类型：byte 二进制位数：8
包装类：java.lang.Byte
最小值：Byte.MIN_VALUE=-128
最大值：Byte.MAX_VALUE=127

基本类型：short 二进制位数：16
包装类：java.lang.Short
最小值：Short.MIN_VALUE=-32768
最大值：Short.MAX_VALUE=32767

基本类型：int 二进制位数：32
包装类：java.lang.Integer
最小值：Integer.MIN_VALUE=-2147483648
最大值：Integer.MAX_VALUE=2147483647

基本类型：long 二进制位数：64
包装类：java.lang.Long
最小值：Long.MIN_VALUE=-9223372036854775808
最大值：Long.MAX_VALUE=9223372036854775807

基本类型：float 二进制位数：32
包装类：java.lang.Float
最小值：Float.MIN_VALUE=1.4E-45
最大值：Float.MAX_VALUE=3.4028235E38

基本类型：double 二进制位数：64
包装类：java.lang.Double
最小值：Double.MIN_VALUE=4.9E-324
最大值：Double.MAX_VALUE=1.7976931348623157E308

基本类型：char 二进制位数：16
包装类：java.lang.Character
最小值：Character.MIN_VALUE=0
最大值：Character.MAX_VALUE=65535
```

**类型默认值**

下表列出了 Java 各个类型的默认值：

| **数据类型**           | **默认值** |
| :--------------------- | :--------- |
| byte                   | 0          |
| short                  | 0          |
| int                    | 0          |
| long                   | 0L         |
| float                  | 0.0f       |
| double                 | 0.0d       |
| char                   | 'u0000'    |
| String (or any object) | null       |
| boolean                | false      |

------

**变量的分类-按声明位置不同**

<img src=".\images\image-20210207211013577.png" alt="image-20210207211013577" style="zoom:67%;" />





---

**类型转换：** 除了boolean外的7种基本数据类型有如下特点

```
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double 
```

- **自动类型转换（自动类型提升）：**
  - **口诀：小+大–>大**
  - 容量小的数据类型变量和容量大的数据类型变量做运算时，结果自动提升为容量大的数据类型变量。
  - 容量大小指的是数的范围的大和小，比如float>long
  - 当byte、char、short三种类型的变量做运算时，结果为int型
- **强制类型转换（自动类型提升的逆运算）**
  - 需要使用强转符`()`
  - double强转为int，数值上**截断**而不是四舍五入
  - 可能会导致**精度损失**
- **隐含强制类型转换**
  - 整型常量，默认类型为int型
  - 浮点型常量，默认类型为double型

------

**String**:

- 引用数据类型，字符串，使用一对`“”`
- 可以和8种基本数据类型运算，使用运算符`+`

> 8种基本数据类型和String做运算时**把握运算本质**，就不会错

<img src=".\images\image-20210208112627525.png" alt="image-20210208112627525"  />

------

**变量之进制**

- 所有数字在计算机**底层都是以二进制**形式存在
- 对于整数，有四种表示方式：
  - **二进制（binary）**：以 0b或0B 开头
  - 十进制（decimal）
  - **八进制（octal）**：以 0 开头
  - **十六进制（hex）**：以 0x 开头
- **十进制转二进制**：除2取余的逆

<img src=".\images\image-20210208121043886.png" alt="image-20210208121043886" style="zoom:50%;" />

**原码、反码、补码**

- **正数有三码合一**
- **负数的原码、反码、补码转换**如下：

<img src=".\images\image-20210208114947001.png" alt="image-20210208114947001" style="zoom:67%;" />![image-20210208115710469](.\images\image-20210208115710469.png)



<img src=".\images\image-20210208115710469.png" alt="image-20210208115710469" style="zoom:67%;" />

<img src=".\images\image-20210208115914498.png" alt="image-20210208115914498" style="zoom:67%;" />

- **计算机底层都以补码的方式来存储数据**，故-14在计算机底层为`11110010`，14在计算机底层为`00001110`。
- 可以通过windows自带的**计算器**加以验证

<img src=".\images\image-20210208115415565.png" alt="image-20210208115415565" style="zoom: 50%;" />



### 2.4 运算符

[菜鸟教程-Java 运算符](https://www.runoob.com/java/java-operators.html)

计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：

- **算术运算符**

| 操作符 | 描述                              | 例子                               |
| :----- | :-------------------------------- | :--------------------------------- |
| +      | 加法 - 相加运算符两侧的值         | A + B 等于 30                      |
| -      | 减法 - 左操作数减去右操作数       | A – B 等于 -10                     |
| *      | 乘法 - 相乘操作符两侧的值         | A * B等于200                       |
| /      | 除法 - 左操作数除以右操作数       | B / A等于2                         |
| ％     | 取余 - 左操作数除以右操作数的余数 | B%A等于0                           |
| ++     | 自增: 操作数的值增加1             | B++ 或 ++B 等于 21（区别详见下文） |
| --     | 自减: 操作数的值减少1             | B-- 或 --B 等于 19（区别详见下文） |

- **关系运算符**

| 运算符 | 描述                                                         | 例子             |
| :----- | :----------------------------------------------------------- | :--------------- |
| ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。         | （A == B）为假。 |
| !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。     | (A != B) 为真。  |
| >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。   | （A> B）为假。   |
| <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。   | （A <B）为真。   |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |

- **位运算符**

*注意：无`<<<`*

**m=(m^n)^n**

| 操作符 | 描述                                                         | 例子                           |
| :----- | :----------------------------------------------------------- | :----------------------------- |
| ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
| \|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
| ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
| 〜     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

- **逻辑运算符**

`&&`和`||`都是**短路逻辑**运算符

| 操作符 | 描述                                                         | 例子                |
| :----- | :----------------------------------------------------------- | :------------------ |
| &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。     | （A && B）为假。    |
| \| \|  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \| \| B）为真。 |
| ！     | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |

- **赋值运算符**

| 操作符  | 描述                                                         | 例子                                     |
| :------ | :----------------------------------------------------------- | :--------------------------------------- |
| =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |
| + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |
| - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |
| * =     | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |
| / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |
| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |
| << =    | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |
| >> =    | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |
| ＆=     | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |
| ^ =     | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |
| \| =    | 按位或赋值操作符                                             | C \| = 2等价于C = C \| 2                 |

- **其他运算符**
  - 条件运算符/三元运算符 `?:`
  - instanceof 运算符 name instanceof String
    

### 2.5 程序流程控制

[菜鸟教程-Java 循环结构 - for, while 及 do...while](https://www.runoob.com/java/java-loop.html)

[菜鸟教程-Java 条件语句 - if...else](https://www.runoob.com/java/java-if-else-switch.html)

[菜鸟教程-Java switch case 语句](https://www.runoob.com/java/java-switch-case.html)



## 3 数组

### 3.1 数组的概述

数组（Array）是**多个相同类型数据**按**一定顺序排列**的集合，并使用**一个名字命名**，并通过**编号**的方式对这些数据进行统一管理

- 数组是**有序排列**的
- 数组是**引用类型**的，数组中的元素可以是**任何数据类型（既可以是基本数据类型，也可以是引用数据类型）**
- 创建数组对象会在内存中开辟**一整块连续**的空间
- 数组的**长度一旦确定，就不能修改**

### 3.2 一维数组的使用



**数组的初始化：**

- **静态初始化**:数组的初始化和数组元素的赋值操作 同时进行

```
int[] ids;// 声明
ids=new int[]{1001,1002,1003,1004};
```

- **动态初始化**:数组的初始化和数组元素的赋值操作 分开进行

```
String[] names=new String[5];
```

---

**数组元素的调用：**通过角标的方式调用

数组的角标（或索引）从0开始，到数组的长度-1结束

<img src=".\images\image-20210208205853199.png" alt="image-20210208205853199" style="zoom:67%;" />



### 3.3 多维数组的使用

[简书-图解Java数组的内存分配](https://www.jianshu.com/p/4c80a972aedb)

对于二维数组的理解，我们可以看成是**一维数组array1 又作为另一个一维数组 array2 的元素**而存在。其实， 从数组底层的运行机制来看，其实没有多维数组。

- **动态初始化**

```
// 格式1
int[][] arr=new int[3][2];
// 格式2
int[][] arr=new int[3][];
```

- **静态初始化**

```
 int [][] arr = new int [][]{{3,8,2},{2,7},{9,0,1,6}}
```

注意特殊写法情况： **int [] x,y []; x 是一维数组， y 是二维数组**。

Java 中**多维数组 不 必都是规则矩阵**形式

![image-20210210112401398](.\images\image-20210210112401398.png)

### 3.4 数组中涉及到的常见算法

**数据结构与算法：**

1. 数据与数据之间的逻辑关系：集合、一对一、一对多、多对多

2. 数据的存储结构：

   - 线性表：顺序表（比如：数组）、链表、栈、队列
   - 树形结构：二叉树、三叉树、B树、B+树

   - 图形结构：有向图、无向图

3. 算法的主要分类

	- 排序算法
	- 搜索算法

------

**数组中涉及的常见算法：**

[CSDN-Java生成随机数公式](https://blog.csdn.net/lostpen/article/details/88420625)

[CSDN-Java反转数组](https://blog.csdn.net/neweastsun/article/details/79935638?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control)

[博客园-20世纪最伟大的十大算法](https://www.cnblogs.com/lemaden/p/10203065.html)

> 回形数有点难，暂时不解决

1. 数组元素的赋值（杨辉三角、**回形数**等）
2. 求数组性数组中元素的最大值、最小值、品均数、总和等
3. 数组的赋值、反转、查找（线性查找、二分法查找）
4. 数组元素的排序算法

### 3.5 Arrays工具类的使用

| 序号 | 方法和说明                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **public static int binarySearch(Object[] a, Object key)** 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。 |
| 2    | **public static boolean equals(long[] a, long[] a2)** 如果两个指定的 long 型数组彼此*相等*，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |
| 3    | **public static void fill(int[] a, int val)** 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |
| 4    | **public static void sort(Object[] a)** 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |

### 3.6 数组中的常见异常

- 数组角标越界的异常：ArrayIndexOutOfBoundsException
- 空指针异常：NullPointerException

## 4 面向对象编程（上）

面向对象学习的三条主线：

1. **Java类及类的成员：属性、方法、构造器、代码块、内部类**
2. 面向对象的大特征：封装性、继承性、多态性（抽象性）
3. 其他关键字：this、super、static、final、abstract、interface、package、import等

### 4.1 面向过程和面向对象

*我不抄概念了，抄了也不懂，干就完了*

- **面向过程：**强调的是功能行为，以函数为最小单位，考虑怎么做

- **面向对象：**将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做
  - 封装
  - 继承
  - 多态

------

**把大象装进冰箱需要三步：**

面向过程：

1. 把冰箱门打开
2. 抬起大象，塞进冰箱
3. 把冰箱门关闭

面向对象：

```
人{
	打开(冰箱){
		冰箱.开开();
	}
	抬起(大象){
		大象.进入(冰箱);
	}
	关闭(冰箱){
		冰箱.闭合();
	}
}
冰箱{
	开开(){}
	闭合(){}
}
大象{
	进入(冰箱){}
}
```

### 4.2 类和对象

对象（Object）有时也成称为实例（instance）

**以下概念每个编程语言说法有所不同，有细节的差别，不过不要太细究：**

- 属性 = 成员变量 = field = 域 =字段
- 行为 = 方法 = 成员方法 = 函数 =method

**类的成员构成**： 属性、方法、构造器、代码块、内部类 

![1618198909184](.\images\1618198909184.png)

------

**对象的创建过程：**见《Java编程思想》96页，此部分涉及到JVM，需要之后结合《深入理解Java虚拟机》一起看

**对象的内存解析：**

[Java学习1：图解Java内存分析详解（实例）](https://blog.csdn.net/qq_36743482/article/details/78527312)

<img src=".\images\image-20210211170911901.png" alt="image-20210211170911901" style="zoom:67%;" />

**对象数组的内存解析：**

![1618198439919](.\images\1618198439919.png)

理解万事万物皆对象

1. 在Java语言范畴中，将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
   - Scanner，String等
   - 文件：File
   - 网络资源：URL
2. 涉及到Java语言与前端HTML、后端数据库交互时，前后端结构在Java层面交互时，都体现为类、对象

内存解析的说明：

1. 引用类型的变量，只可能储存两类值：Null和地址值（含变量的类型） 

**匿名对象**的使用：

1. 理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象
2. 特征：匿名对象只能调用一次

3. 使用：`mall.show(new Phone())`

### 4.3 对象的创建和使用

**内存解析：**

![image-20210215121202645](.\images\image-20210215121202645.png)



虚拟机栈：即为平时提到的栈结构。将局部变量存储在栈结构中

堆：将new出来的结构（比如数组，对象）加载到堆空间中。补充：对象的属性（非static的）加载在堆空间中。

方法区：类的加载信息、常量池、静态域

------

[IDEA设置注释模板](https://www.cnblogs.com/zhengxl5566/p/10674808.html)

标准的Javadoc注释见《Java编程思想》35页

### 4.4 类的成员之一：属性（field）

[博客园-成员变量与局部变量的区别](https://www.cnblogs.com/huangminwen/p/5935130.html)



![1618198325584](.\images\1618198325584.png)

所有变量

- 成员变量
  - 实例变量
  - 类变量
- 局部对象
  - 形参（方法、构造器中定义的变量）
  - 方法局部变量（在方法内定义）
  - 代码块局部变量（在代码块内定义）
- 两者在初始化值方面的异同：
  - 同：都有生命周期
  - 异：**局部变量除形参外，均需显示初始化**

### 4.5 类的成员之二：方法（method）

略

### 4.6 再谈方法

**重载(Overload)**：在一个类中，允许定义方法名相同的多个方法，每个方法的参数数量或参数类型不同，但不同通过返回值来区分

- 特点：两同一不同（同一个类，相同方法名；参数列表不同）

*可以通过写一个ArrayUtil来锻炼自己*

E:\idea_workspace\2021Study-Java\2021Study-JavaSE\src\day09\ArrayUtil.java

E:\idea_workspace\2021Study-Java\2021Study-JavaSE\src\day09\OverloadExer.java

![image-20210217164748284](.\images\image-20210217164748284.png)

---

**可变个数形参**

- 可变个数形参的格式：**数据类型 …变量名**
- 当调用可变个数参数的方法时，**传入的参数个数可以是0个，1个，2个**

E:\idea_workspace\2021Study-Java\2021Study-JavaSE\src\day09\MethodArgsTest.java

---

[博客园-java中方法的参数传递机制](https://www.cnblogs.com/lixiaolun/p/4311863.html)

方法参数的值传递机制

- 形参：方法声明时的参数
- 实参：方法调用时实际传给形参的参数值

Java的实参值如何传入方法呢？

Java里方法的参数传递方式只有一种：**值传递**。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响

- **当形参是基本数据类型时，传递的是实际的值**
- **当形参是引用数据类型时，传递的是地址值**

![1618370546522](.\images\1618370546522.png)

![1618370555417](.\images\1618370555417.png)

---

**将对象作为参数传递给方法**

E:\idea_workspace\2021Study-Java\2021Study-JavaSE\src\day09\PassObject.java
E:\idea_workspace\2021Study-Java\2021Study-JavaSE\src\day09\RecursionTest.java

----

**递归方法**

1. 递归方法：一个方法内调用它自身
2. 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无序循环控制

### 4.7 面向对象特征之一：封装与隐藏

程序设计追求“高内聚，低耦合”：

- 高内聚：类的内部数据操作细节自己完成，不允许外部干涉

- 低耦合：仅对外暴露少量的方法用于使用

封装性的体现：

- 将类的属性进行私有化（private），同时，提供公共的（public）方法来获取和设置属性值

- 不对外暴露的私有的方法
- 单例模式
- …

**4种权限修饰符**

- 可以用来修饰类的内部结构包括属性、方法、构造器、内部类

>  普通类（外部类）：只能用public、default（不写）、abstract、final修饰。
> （成员）内部类：可理解为外部类的成员，所以修饰类成员的public、protected、default、private、static等关键字都能使用。
> 局部内部类：出现在方法里的类，不能用上述关键词来修饰。
> 匿名内部类：给的是直接实现，类名都没有，没有修饰符。
>

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |
| :---------- | :----- | :------- | :------------- | :------------- | :----- |
| `public`    | Y      | Y        | Y              | Y              | Y      |
| `protected` | Y      | Y        | Y              | Y              | N      |
| `default`   | Y      | Y        | Y              | N              | N      |
| `private`   | Y      | N        | N              | N              | N      |

protected 需要从以下两个点来分析说明：

- **子类与基类在同一包中**：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；
- **子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。

### 4.8 类和类的成员之三：构造器（constructor）

略

---

**JavaBean**：用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地复制和粘贴的功能，而不用关心任何改变。

- 类是公共的
- 有一个无参的公共构造器
- 有属性，且有对应的get、set方法

----

**UML类图**

![1618390854932](.\images\1618390854932.png)

### 4.9 关键字：this的使用

- this可以用来修饰属性、方法、构造器

- this修饰属性和方法
  - this可以理解为：**当前对象**
  - 在类的方法中，我们可以使用“this.属性”或“this.方法”调用当前对象属性或方法。通常都选择省略“this.”，除非**形参和实参同名时不可省略**
- this修饰构造器
  - `this();`调用空参构造器
  - `this(age);`调用带参构造器
  - 构造器不能通过“this(形参列表)”方式调用自己
  - 如果一个类中有N个构造器，则最多N-1构造器使用了“this(形参列表)”
  - 规规：“this(形参列表)”必须声明在当前构造器的首行
  - 构造器内部最多只能声明一个“this(形参列表)”

### 4.10 关键字：package、import的使用

package关键字的使用：

- 为了更好的实现项目中类的管理，提供包的概念
- 使用package声明类或接口所属的包，声明在源文件的首行
- 包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”

- 每一个`.`表示一层文件目录

**JDK中主要的包介绍**

![1618475714334](.\images\1618475714334.png)

**MVC设计模式**

![1618475807694](.\images\1618475807694.png)

import关键字的使用：

- 在源文件中，显示的使用户import结构导入指定包下的类和接口
- 声明在包的声明和类的声明之间

- 如果使用的类或接口是本包下定义的，可以省略import
- 在源文件中，使用了不同包下的同名类，则必须至少有一个类需要以**全类名**的方式显示
- 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
- 使用“xxx.*”方式表名可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入
- import static：导入指定类或接口中的静态结构

```java
import static java.lang.System.*;
import static java.lang.Math.*;
public class PackageImportTest {
    public static void main(String[] args) {
        out.println ("hello");
        long round = round ( 3.45 );
        out.println (round);
    }
}
```

### 4.11 Eclispe快捷键

```
10.切换到下一行代码空位：shift + enter
12.如何查看源码：ctrl + 选中指定的结构   或  ctrl + shift + t
18.反撤销： ctrl + y
25.选中数行，整体往前移动：shift + tab
26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o
27.批量修改指定的变量名、方法名、类名等：alt + shift + r
28.选中的结构的大小写的切换：变成大写： ctrl + shift + x
32.快速查找：参照选中的Word快速定位到下一个 ：ctrl + k
36.查找与替换：ctrl + f
```

[CSDN-错误：非法字符：“\ufeff”](https://blog.csdn.net/u013066730/article/details/95305827)

### 项目二：客户信息管理系统

E:\idea_workspace\2021Study-Java\2021Study-JavaSE\src\day11\project2

**项目简图**：

![1618734027772](.\images\1618734027772.png)

## 5 面向对象编程（中）

### 5.1 面向对象特征之二：继承性

继承性的好处：why？

- 减少代码的冗余，提高了代码的复用性
- 便于功能的拓展
- 为之后多态性的使用，提供了前提

继承性的格式：`class A extends B{}`

- A:子类、派生类、subclass

- B:父类、超类、基类、superclass
- extends：拓展、延展

- **一旦子类A继承父类B以后，子类A中就获取了父类B中声明的结构（包括公有和私有）：属性、方法。**

- 子类继承父类之后，还可以声明自己特有的属性或方法，实现功能的拓展

Java中关于继承的规定：

- 一个类可以被多个子类继承
- Java中类的单继承性：一个类只能有一个父类
- 子父类是相对的概念
- 子类直接继承的父类称为：直接父类。简介继承的父类称为：间接父类
- 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法

### 5.2 方法的重写（Override/Overwrite）

重写的规定：

- 方法的声明：权限修饰符 返回值类型 方法名（形参列表）throws 异常的类型{

  ​				// 方法体

​			}

- 约定速成：子类中的叫重写的方法，父类中的叫被重写的方法(**两小一大**)

1. 子类重写的方法的方法名和形参列表和父类被重写的相同
2. **子类重写的方法权限修饰符不小于父类被重写的方法权限修饰符**（特殊情况：子类不能重写父类中声明为private权限的方法）
3. 返回值类型：
   - 父类被重写的方法返回值是void，则子类重写的方法的返回值只能是void
   - **父类被重写的方法返回值是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类**
   - 父类被重写的方法返回值类型时基本数据类型（比如double），则子类重写的方法的返回值类型必须是相同的基本数据类型
4. **子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型**



**子类和父类中同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）**

### 5.3 测试四种权限修饰符

**4种权限修饰符**

- 可以用来修饰类的内部结构包括属性、方法、构造器、内部类
- 修饰类只能用缺省、public

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)                                               | 其他包 |
| :---------- | :----- | :------- | :------------- | :----------------------------------------------------------- | :----- |
| `public`    | Y      | Y        | Y              | Y                                                            | Y      |
| `protected` | Y      | Y        | Y              | Y/N（[说明](https://www.runoob.com/java/java-modifier-types.html#protected-desc)） | N      |
| `default`   | Y      | Y        | Y              | N                                                            | N      |
| `private`   | Y      | N        | N              | N                                                            | N      |

protected 需要从以下两个点来分析说明：

- **子类与基类在同一包中**：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；
- **子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。

### 5.4 关键字：super

super用来是调用父类的属性、方法、构造器

- `super(形参列表)`必须声明在子类构造器的首行

- `super(形参列表)`和`this(形参列表)`只能二选一，不能同时出现。

- 在构造器首行**，没有显式的声明this和super，默认调用的是父类的空参构造器即super()。**

- **在类的多个构造器中，至少有一个类的构造器使用了`super(形参列表)`调用父类中的构造器。**

### 5.5 子类对象实例化过程

<img src=".\images\1618974251565.png" alt="1618974251565" style="zoom:67%;" />

从结果上来看：（继承性）

- 子类继承父类以后，就获取了父类中声明的属性或方法

- 创建子类的对象，**在堆空间中，就会加载所有父类中声明的属性**

从过程上来看：

- 当我们通过子类的构造区创建子类对象时，一定会直接或间接的调用父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器。正因为加载过所有父类的结构，所以才可以看到内存中有父类的结构，子类对象才可以考虑进行调用
- 虽然创建子类对象时，调用了父类的构造器，但是自始至终都只创建了一个对象

### 5.6 面向对象特征之三：多态性

子类对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的对象）

多态性**只适用于方法，不适用于属性。**属性编译运行都看左边

```java
Person p1=new Man();//编译看左边，运行看右边
p1.eat();
```

方法上**编译看左边，运行看右边**

父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译器是无法确定的。故**多态是运行时行为，这就是晚绑定或动态绑定**。

而对于重载，它们的调用地址在编译器就绑定了，故**重载是早绑定或静态绑定**



**不能调用子类特有的方法、属性**；编译时，p2是Person类型

有了对象的多态性之后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类中特有的属性和方法不能调用

如何才能调用子类特有的属性和方法？

**向下转型：使用强制类型转换符，向上转型：多态**

转换不成功会抛ClassCastException(),为了避免这种异常，引入了instanceof关键字

![1618994369975](.\images\1618994369975.png)

```java
if(p2 instanceof Woman){
            Woman w2=(Woman)p2;
            w2.goShopping ();
        }
```

### 5.7 Object类的使用

| 序号 |                         方法 & 描述                          |
| :--: | :----------------------------------------------------------: |
|  1   | [protected Object clone()](https://www.runoob.com/java/java-object-clone.html)创建并返回一个对象的拷贝 |
|  2   | [boolean equals(Object obj)](https://www.runoob.com/java/java-object-equals.html)比较两个对象是否相等 |
|  3   | [protected void finalize()](https://www.runoob.com/java/java-object-finalize.html)当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。 |
|  4   | [Class getClass()](https://www.runoob.com/java/java-object-getclass.html)获取对象的运行时对象的类 |
|  5   | [int hashCode()](https://www.runoob.com/java/java-object-hashcode.html)获取对象的 hash 值 |
|  6   | [void notify()](https://www.runoob.com/java/java-object-notify.html)唤醒在该对象上等待的某个线程 |
|  7   | [void notifyAll()](https://www.runoob.com/java/java-object-notifyall.html)唤醒在该对象上等待的所有线程 |
|  8   | [String toString()](https://www.runoob.com/java/java-object-tostring.html)返回对象的字符串表示形式 |
|  9   | [void wait()](https://www.runoob.com/java/java-object-wait.html)让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。 |
|  10  | [void wait(long timeout)](https://www.runoob.com/java/java-object-wait-timeout.html)让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过参数设置的timeout超时时间。 |
|  11  | [void wait(long timeout, int nanos)](https://www.runoob.com/java/java-object-wait-nanos.html)与 wait(long timeout) 方法类似，多了一个 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。 |

 ```java
/**
* 重写equals()
*/
@Override
public boolean equals(Object obj){
	if(this==obj){
		return true;
	}
	if(obj instanceof Customer){
		Customer cust=(Customer)obj;
		return this.age==cust.age&&this.name.equals(cust.name);
	}
	return false;
}
 ```

### 5.8 包装类的使用

略

## 6 面向对象编程（下）

### 6.1 关键字：static

static可以用来修饰属性、方法、代码块、内部类

静态变量存在静态域中

**类变量（静态变量）vs实例变量（非静态变量）**

![1619008608307](.\images\1619008608307.png)



----

### 单例设计模式

当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，**减少了系统性能开销**。举例java.lang.Runtime

**单例设计模式-应用场景**

![1619010086133](.\images\1619010086133.png)

饿汉式：

```java
public class SingletonTest1 {
    public static void main(String[] args) {
        Bank instance = Bank.getInstance ();

    }
}
class Bank{
    private Bank(){}
    private static Bank instance =new Bank();

    public static Bank getInstance() {
        return instance;
    }
}
```

懒汉式：

```java
public class SingletonTest2 {
    public static void main(String[] args) {
        Order o1=Order.getInstance ();
        Order o2=Order.getInstance ();
        System.out.println (o1==o2);
    }
}
class Order{
    private Order(){}
    private static Order instance=null;

    public static Order getInstance() {
        if(instance==null){
            instance=new Order();
        }
        return instance;

    }
}
```

区分饿汉式和懒汉式

饿汉式：坏处，对象加载时间过长；好处：饿汉式是线程安全的

懒汉式：好处，延迟对象的创建；坏处：目前写法是线程不安全的-->到多线程内容时再修改

### 6.2 理解main方法的语法

由于 Java 虚拟机需要调用类的 main() 方法，所以该方法的访问权限必须是
public 又 因为 Java 虚拟机在执行 main() 方法时不必创建对象，所以该方法必须
是 static 的，该方法接收一个 String 类型的数组参数，该数组中 保存 执行 Java 命令
时传递给所运行的类的参数 。

### 6.3 类的成员之四：代码块

1. 代码块的作用：用于初始化类、对象
2. 代码块可以用static来修饰
   - 静态代码块：随着类的加载而执行
   - 非静态代码块：随着对象的创建而执行

3. 非静态代码块、静态代码块、构造器执行顺序总结：**由父及子，静态先行**

对属性可以赋值的位置：

①默认初始化

②显示初始化/⑤在代码块中赋值

③构造器中初始化

④有了对象以后，可以通过对象.属性或对象.方法的方式，进行赋值

### 6.4 关键字：final

final修饰属性：可以考虑的赋值位置有：显示初始化、代码块中初始化、构造器中初始化（final的初始化不能逃逸出构造器）

final修饰局部变量：尤其是使用final修饰形参时，表名此形参时一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能重新赋值。

static final用来修饰属性是全局常量

### 6.5 抽象类与抽象方法

abstract修饰一个类：**抽象类**

- 此类不能实例化
- 抽象类中一定有构造器，便于子类实例化时调用
- 开发中，都会提供子类，让子类去实例化

abstract修饰一个方法：**抽象方法**

- 抽象方法只有方法的声明，没有方法体

- 包含抽象方法的类一定是抽象类，反之，抽象类中可以没有抽象方法

- 若子类重写了父类中所有的抽象方法后，此子类方可实例化；若子类没有重写了父类中所有的抽象方法，则子类也是抽象类

**abstract不能用来修饰私有方法、静态方法、final的方法**

----

**创建了一匿名子类的对象：p**

```java
Person p=new Person(){
	@Override
	public void eat(){
	
	}
	@Override 
	public void breath(){
	
	}
};
```

**创建匿名子类的匿名对象**

```java
method1(new Person(){
	@Override
	public void eat(){
	
	}
	@Override 
	public void breath(){
	
	}
});
```

----

### 模板方法设计模式

![1619067912479](.\images\1619067912479.png)

![1619067939870](.\images\1619067939870.png)

AQS中也用到了模板方法

### 6.6 接口（interface）

如何定义接口：定义接口中的成员

- JDK7及以前：只能定义全局变量和抽象方法
  - 全局变量：public static final 的，但是书写时，可以省略不写
  - 抽象方法：public abstract的
- JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）

Java类可以实现多个接口—>弥补了Java类的单继承性

**接口与接口之间可以多继承**

---

创建了接口的非匿名实现类的非匿名对象

```
Flash flash=new Flash();
com.transfer(flash);
```

创建了接口的非匿名实现类的匿名对象

```
com.transferData(new Printer());
```

创建了接口的匿名实现类的非匿名对象

```
USB phone =new USB(){
	@Override
	public void start(){
		System.out.println("手机开始工作");
	}
	@Override
	public void stop(){
		System.out.println("手机停止工作");
	}
};
```

---

### 代理模式（Proxy）设计模式

类似经纪人和明星的关系

![1619079046875](.\images\1619079046875.png)

![1619079546904](.\images\1619079546904.png)

JDK8：除了定义全局变量和抽象方法之外，还可以定义静态方法和默认方法

- 接口中定义的静态方法，只能通过接口来调用
- 通过实现类的对象，可以调用接口中的默认方法

- 如果子类（实现类）继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法情况下，默认调用的是父类的同名同参数的方法-->类优先原则
- 如果实现类实现了多个接口，而这多个接口定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，报错—>接口冲突。这就需要在实现类中重写此方法
- 如何在实现类的方法中调用接口中被重写的方法`CompareA.super.method3()`

```java
public interface CompareA {
    public static void method1(){
        System.out.println ("CompareA:北京");
    }
    public default void method2(){
        System.out.println ("CompareA:上海");
    }
    default void method3(){
        System.out.println ("CompareA:上海");
    }
}
```



 ### 工厂模式设计模式

《拓展：工厂设计模式.pdf》

### 6.7 类的成员之五：内部类

- 成员内部类

  - 静态成员内部类

  ```
  Person.Dog dog=new Person.Dog();
  dog.show();
  ```

  

  - 非静态成员内部类

  ```
  Person p=new Person();
  Person.Bird bird=p.new Bird();
  bird.sing();
  ```

  **外部类的属性**`Person.this.name`

- 局部内部类
  - 方法内
  - 代码块内
  - 构造器内

## 7 异常处理

### 异常概述与异常体系结构

很多问题不是靠代码能够避免的：客户输入数据的格式，读取的问题是否存在，网络是否始终保持通畅等。

异常时间可以分为：

- **Error**：Java虚拟机无法解决的严重问题，如JVM系统内部错误，资源耗尽等严重情况。比如：StackOverflowError和OutOfMemoryError。一般不写针对性代码进行处理

java.lang.StackOverflowError

```java
public void main(String[] args){
	main(args);
}
```

java.lang.OutOfMemoryError

```
Integer[] i=new Integer[1024*1024*1024];
```



- **Exception**：其他因编程错误或偶然的外在因素导致的一般性问题，捕获错误最理想的是在编译期间，但有的错误只有运行时才出现

  - 编译时异常（checked）

    - IOException
      - FileNotFoundException
    - ClassNotFoundException
    - CloneNotSupportedException

  - 运行时异常（unchecked）

    - NullPointerException
    - ArrayIndexOfBoundsException
    - ClassCastException
    - NumberFormatException
    - InputMismatchException
    - ArithmeticException

    - …

  ![1619338273221](.\images\1619338273221.png)

### try-catch-finally结构

**finally中声明的是一定会被执行**。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况

像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要自己手动进行资源的释放，此时，释放资源就写在finally中

### throws结构

只是将异常抛给了方法的调用者，并没有真正处理掉异常。异常代码后续的代码，就不再执行。



**开发中如何选择？**

- 如果父类中被重写的方法没有throws方法处理异常，则子类重写的方法也不能使用throws。意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理

- 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理

### 手动抛出异常throw Exception

```java
throw new RuntimeException("输入参数不合法");
```

### 用户自定义异常类

如何自定义异常类？

1. 继承于现有的异常结构：RuntimeException、Exception

2. 继承全局常量：servialVersionUID

```
public class MyException extends RuntimeException {
    static final long serialVersionUID = 1L;
    public MyException(){

    }
    public MyException(String msg){
        super (msg);
    }
}

```

